# 重构原则

## 何时重构

#### 重构（名词）

对软件内部的一种调整，目的是在**不改变软件可观察行为下的前提下，提高其可理解性，降低其修改成本**

#### 重构（动词）

使用一系列**重构手法**，在不改变软件可观察行为的前提下，**调整其结构**

#### 更容易理解和修改

在软件内部做很多修改，但必须对软件可观察的外部行为**只造成很小变化，甚至不造成变化**。并且达到性能优化

#### 不改变软件可观察的行为

任何用户，都不知道已经有**东西发生了变化**

### 两顶帽子

使用重构技术开发软件时，把自己的时间分配给两种截然不同的行为：**添加功能新功能、重构**

- 添加新功能时：**不应该修改既有的代码**，只管添加新功能，并且通过测试
- 重构：**不能添加新功能**，只管改进程序结构

## 为何重构

#### 改进软件设计

重构很像是在整理代码，让所有东西回到应处的位置上；代码结构的流失是累积性。

常常是因为代码在不同的地方使用完全相同的语句做同样的事；**消除重复代码**是优秀设计的根本。

#### 使软件更容易理解

可理解性还有另一方面：可以利用重构理解不熟悉的代码；不仅仅会看而且会真正动手去修改代码，让它更好地反映出我的理解，然后执行，是否正常运行，检验自己的理解是否正确

#### 帮助找到bug

对代码的理解，可以快速到bug

#### 提高编程速度

良好的设计是快速开发的根本 - 如果没有良好的设计，或许某一段时间内是可以迅速进展，但是恶劣的设计很快就让你慢下来，会把时间花到调试，无法添加新功能。修改时间越长，就必须花越多的时间去理解系统，寻找重复代码。

## 何时重构

**事不过三原则，三则重构**

### 添加功能

是否能对**这段代码进行重构，使我能更快地理解它。然后我就会重构**

### 修补错误时

调试过程中运用重构，多半是为了让代码更具**可读性**；让能一眼看出bug

### 复审代码

可以改善开发状况。这种活动有助于在开发团队中传播知识，也有助于让较有经验的开发者把知识传递给比较欠缺经验的人，并帮助更多人理解大型软件系统中的更多部分；

## 重构的难题

# 代码坏味道

# 重构列表

# 重新组织函数

# 重新组织数据

将一个值用于多个不同的用途，引用和值的混淆经常会造成问题，用将**引用对象改为值对象**和将**值对象改为引用对象**在**两者之间切换**

## 拆分变量

变量个各种不同的用途，某些用途会很自然地导致临时变量被多次赋值；有两种情况：循环变量、结果收集；变量应该只承担一种职责，过多会导致会令代码阅读者糊涂

### 做法

变量的第二次赋值动作为界，修改此前对该变量的所有引用，让它们引用新变量

在待**分解变量的声明及其第一次被赋值处，修改其名称**

## 字段改名

数据结构对帮助阅读者理解代码，非常有帮助；是理解程序行为的关键

### 做法

如果记录的作用域较小，可以直接修改所有该字段的代码

如果记录还未封装，请先使用封装记录

在对象内部对私有字段改名，对应调整内部访问该字段的函数

如果构造函数的参数用了旧的字段名，运用改变函数声明将其改名

## 以查询取代派生变量

可变数据是软件中最大的错误源头之一；对数据的修改常常导致代码的各个部分以丑陋的形式互相耦合：在一处修改数据，却在另一处造成难以发现的破坏

### 做法

识别出所有对变量做更新的地方，新建一个函数，用于计算该变量的值

## 将值对象改为引用对象

一个数据结构中可能包含多个记录，而这些记录都关联到同一个逻辑数据结构；遇到这样的共享关系时，也可以将其视为引用对象；如果有多处共享值需要更新，比较方便修改；可以考虑将多份数据副本变成单一的引用

### 做法

为相关对象创建一个仓库（如果还没有这样一个仓库的话）。确保构造函数有办法找到关联对象的正确实例。

修改宿主对象的构造函数，令其从仓库中获取关联对象。每次修改后执行测试

## 将引用对象改为值对象

在把一个对象（或数据结构）嵌入另一个对象时，位于内部的这个对象可以被视为引用对象，也可以被视为值对象如果将内部对象视为引用对象，在更新其属性时，我会保留原对象不动，更新内部对象的属性；如果将其视为值对象，我就会替换整个内部对象，新换上的对象会有我想要的属性值；值对象通常更容易理解，主要因为它们是不可变的。一般说来，不可变的数据结构处理起来更容易

### 做法

用移除设值函数（331）逐一去掉所有设值函数，提供一个基于值的相等性判断函数，在其中使用值对象的字段

# 简化条件表达式

## 分解条件表达式

复杂的条件逻辑是最常导致复杂度上升因素之一，代码来检查不同的条件分支，根据不同的条件做不同的事；代码来检查不同的条件分支，根据不同的条件做不同的事；

可以将它分解为多个独立的函数，根据每个小块代码的用途，为分解而得的新函数命名，并将原函数中对应的代码改为调用新函数，从而更清楚地表达自己的意图。可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因

### 做法

对条件判断和每个条件分支分别运用**提炼函数手法**

## 合并条件表达式

检查条件各不相同，最终行为却一致；就应该**使用“逻辑或”和“逻辑与”将它们合并为一个条件表达式**；

合并后的条件代码会表述“实际上只有一次条件检查，只不过有多个并列条件需要检查而已”，从而使这一次检查的用意更清晰；这项重构往往可以为使用**提炼函数做好准备**

### 做法

确定这些条件**表达式都没有副作用。**
如果某个条件表达式有副作用，可以先用将查询函数和修改函数分离处理。
使用适当的逻辑运算符，将两个相关条件表达式合并为一个。
顺序执行的条件表达式用逻辑或来合并，嵌套的if语句用逻辑与来合并。

## 以卫语句取代嵌套表达式

条件表达式通常有两种风格。

第一种风格是：两个条件分支都属于正常行为。
**应该使用形如if...else...的条件表达式**

第二种风格则是：只有一个条件分支是正常行为，另一个分支则是异常的情况
如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的**单独检查常常被称为“卫语句”（guard clauses）** if() return 

以卫语句取代嵌套条件表达式的精髓就是：给某一条分支以特别的重视。**如果使用if-then-else结构，你对if分支和else分支的重视是同等**
卫语句，它告诉阅读者：“这种情况不是本函数的核心逻辑所关心的，**如果它真发生了，请做一些必要的整理工作，然后退出。**”

### 做法

选中**最外层需要被替换的条件逻辑，将其替换为卫语句**

## 以多态取代条件表达式

可以将**条件逻辑拆分到不同的场景（或者叫高阶用例）**，从而拆解复杂的条件逻辑。这种拆分有时用条件逻辑本身的结构就足以表达，但使用**类和多态能把逻辑的拆分表述得更清晰**

### 做法

如果**现有的类尚不具备多态行为，就用工厂函数创建之，令工厂函数返回恰当的对象实例**

## 引入特例

一个数据结构的使用者都在检查某个特殊的值，并且当这个特殊值出现时所做的处理也都相同。**处理这种情况的一个好办法是使用“特例”（Special Case）模式：创建一个特例元素，用以表达对这种特例的共用行为的处理**

### 做法

给重构目标添加检查特例的属性，令其返回false。
创建一个特例对象，其中只有检查特例的属性，返回true。


# 简化函数调用

# 处理概括关系

# 重构，复用与实现



# 封装



# 搬移特性

## 搬移函数

**模块化**是优秀软件设计的核心所在，好的模块化能够让我在修改程序时只**需理解程序的一小部分**；

最直接的一个动因是，它**频繁引用其他上下文中的元素**，而对自身上下文中的元素却关心甚少；搬移到某些更通用的地方

### 做法

检查函数在当前上下文里引用的所有程序元素（包括变量和函数），考虑是否需要将它们一并搬

## 移动语句

### 动机

**让存在关联的东西一起出现，可以使代码更容易理解**

## 搬移字段

### 动机

往往数据结构才是一个健壮程序的根基；搬移字段的**操作通常是在其他更大的改动背景下发生的**

## 搬移语句到函数

### 动机

我发现调用某个函数时，**总有一些相同的代码也需要每次执行**，那么我会考虑将此段代码合并到函数里头

## 搬移语句到调用者

### 动机

把**表现不同的行为从函数里挪出，并搬移到其调用处**；要差异代码被搬移到调用点

## 以函数调用取代内联代码

### 动机

善用**函数可以帮助我将相关的行为打包起来**，这对于提升代码的表达力大有裨益—— 一**个命名良好的函数，本身就能极好地解释代码的用途，使读者不必了解其细节**；函数**同样有助于消除重复，因为同一段代码我不需要编写两次，每次调用一下函数即可**



## 拆分循环

### 动机

如果你在一次循环中做了两件不同的事，那么**每当需要修改循环时，你都得同时理解这两件事情**。如果能够将循环拆分，让一个循环只做一件事情，那就能确保每次修改时你需要理解要修改的那块代码的行为就可以了

## 以管道取代循环

集合管道是这样一种技术，**它允许我使用一组运算来描述集合的迭代过程**，其中每种运算接收的入参和返回值都是一个集合

## 移除死代码

当你尝试阅读代码、理解软件的运作原理时，**无用代码确实会带来很多额外的思维负担**；一旦代码不再被使用，我们就该立马删除它。**有可能以后又会需要这段代码，但我从不担心这种情况；就算真的发生，我也可以从版本控制系统里再次它翻找出来**

# 重构API

## 将查询函数和修改函数分离

保持函数单一原则，并且任何有返回值的函数，都不应该有看得到的副作用；如果遇到一个"既有返回值又有副作用"的函数，就将分开

### 做法

复制整个函数，将其作为一个查询命名

## 函数参数化

发现两个函数逻辑非常相似，只有一些字面量不同，可以将其合并成一个函数，以参数的形式传入不同的值

### 做法

从一组相似的函数中选择一个，运用改变函数声明，把需要作为参数传入的字面量添加到参数列表修改改函数所有的调用处，使其在调用时传入改字面量

## 移除标记参数

调用者用它来指示被调用者函数应该执行那一部分逻辑

### 做法

如果主函数有清晰的条件分发逻辑，可以用分解条件表达式创建明确函数；否则，可以在原函数之上创建包装函数



## 保持对象完整

函数有多个参数时，应传入对象，如果将来被调的函数需要从记录中导出更多的数据，我就不用为此修改参数列表。并且传递整个记录也能缩短参数列表，让函数调用更容易看懂

### 做法

新建一个空函数，给它以期望中的参数列表（即传入完整对象作为参数）。给这个函数起一个容易搜索的名字，这样到重构结束时方便替换。在新函数体内调用旧函数，并把新的参数（即完整对象）映射到旧的参数列表（即来源于完整对象的各项数据）。

## 以查询取代参数

函数的参数列表应该总结该函数的可变性，标示出函数可能体现出行为差异的主要方式。和任何代码中的语句一样，参数**列表应该尽量避免重复**，**并且参数列表越短就越容易理解**

### 做法

如果有必要，使用提炼函数将参数的计算过程提炼到一个独立的函数中。将函数体内引用该参数的地方改为调用新建的函数。每次修改后执行测试。全部替换完成后，使用改变函数声明将该参数去掉。

## 以参数取代查询

了让目标函数不再依赖于某个元素，我把这个元素的值以参数形式传递给该函数

### 做法

对执行查询操作的代码使用提炼变量，将其从函数体中分离出来。现在函数体代码已经不再执行查询操作（而是使用前一步提炼出的变量），对这部分代码使用提炼函数。给提炼出的新函数起一个容易搜索的名字，以便稍后改名。使用内联变量，消除刚才提炼出来的变量。对原来的函数使用内联函数。对新函数改名，改回原来函数的名字。

## 移除设值函数

如果为某个字段提供了设值函数，这就暗示这个字段可以被改变。如果不希望在对象创建之后此字段还有机会被改变，那就不要为它提供设值函数（同时将该字段声明为不可变）

### 做法

如果构造函数尚无法得到想要设入字段的值，就使用改变函数声明将这个值以参数的形式传入构造函数。在构造函数中调用设值函数，对字段设值。如果想移除多个设值函数，可以一次性把它们的值都传入构造函数，这能简化后续步骤

## 以工厂取代构造函数

**工厂函数的实现内部可以调用构造函数，但也可以换成别的方式实现**

### 做法

新建一个工厂函数，让它调用现有的构造函数。将调用构造函数的代码改为调用工厂函数。每修改一处，就执行测试

## 以命令取代函数

函数，不管是独立函数，还是以方法（method）形式附着在对象上的函数，是程序设计的基本构造块。不过，将函数封装成自己的对象，有时也是一种有用的办法

### 做法

为想要包装的函数创建一个空的类，根据该函数的名字为其命名。使用搬移函数把函数移到空的类里

## 以函数取代命令

借助命令对象，可以轻松地将原本复杂的函数拆解为多个方法，彼此之间通过字段共享状态；拆解后的方法可以分别调用；开始调用之前的数据状态也可以逐步构建

### 做法

运用提炼函数，把“创建并执行命令对象”的代码单独提炼到一个函数中。这一步会新建一个函数，最终这个函数会取代现在的命令对象。对命令对象在执行阶段用到的函数，逐一使用内联函数。如果被调用的函数有返回值，请先对调用处使用提炼变量，然后再使用内联函数。使用改变函数声明，把构造函数的参数转移到执行函数。对于所有的字段，在执行函数中找到引用它们的地方，并改为使用参数。每次修改后都要测试。把“调用构造函数”和“调用执行函数”两步都内联到调用方（也就是最终要替换命令对象的那个函数）

# 处理继承关系

## 函数上移

如果某个函数在各个子类的函数体都相同，这就是最显而易见的函数上移适用场合

### 做法

检查待提升函数，确定他们是完全一致的；如果他们做了相同的事情，但函数并不完全一致，那就先对他们进行重构，直到其函数体完全一致

如果待提升函数签名不同，使用改变函数声明，将哪些签名都修改为，想要在超类中使用的签名

## 字段上移

如果他们使用的方式很相似，可以将它们提升到超类中去；首先他先除去重复的数据声明；其次它使用该字段的行为子类移至超类

### 做法

针对待提升字段，检查它们的所有使用点，确认它们以同样方式使用；如果这些字段的名称不同，先使用变量改名为它们取相同的名字。在超类中新建一个字段。

## 构造函数本体上移

如果各个子类中的函数用共同行为，将使用以工厂函数取代构造函数

### 做法

如果超类不存在构造函数，首先定义一个，确保让子类调用超类的构造函数，使用移动语句将子类中构造函数中的公共语句移动到超类的构造函数调用语句之后；逐一移除子类间的公共代码，将其提升超类函数中，对于公共代码中引用到的变量，将其作为参数传递给超类的构造函数

## 函数下移

如果超类中的某个函数只与一个（或少数几个）子类有关，那么最好将其从超类中挪走，放到真正关心它的字类中去；且明确哪些子类需要用到这个函数中

### 做法

将超类中的函数本体复制到每个一个需要此函数的子类

## 字段下移

如果某个字段只被一个子类（或者一小部分子类）用到，就将其搬移到需要该字段的子类中

### 做法

在所有需要该字段的子类中声明该字段

## 以子类取代类型码

可以创建子类，然后用字段下移把这样的字段放到合适的子类中去

### 做法

自封装类型字段。任选一个类型码取值，为其创建一个子类，覆写类型码类的取值函数，令其返回该类型码的字面量值。创建一个选择器逻辑，把类型码参数映射到新的子类。如果选择直接继承的方案，就用工厂函数取代构造函数包装构造函数，把选择器逻辑放在工厂函数里；如果选择间接继承方案，选择器逻辑可以保留在构造函数里

## 移除子类

有时添加子类是为了应对未来的功能，结果想象中的功能没有出来，或者用另一种方式构造，是子类不在需要了，子类存在着就有成本，阅读者需要花心思去理解它的用意，如果子类的用处太少，就不值得存在了

### 做法

如果构造函数的客户端用一个数组字段来决定实例化哪个子类，可以把这个判断逻辑放到超类的工厂函数中

## 提炼超类

看见两个类在做相似的事，可以利用继承机制把它们的相似之处提炼到超类，另一种选择是提炼类委托，目的都是把重复的行为收拢一处。

### 做法

为原本的类新建一个空白的超类；如果需要可用函数声明调整构造函数的签名

## 折叠继承体系

在重构类继承体系时，经常把函数和字段上下移动，但是随着继承体系的演化，有时会发现一个类与其超类已经没多大差别，不值得再作为独立的类存在**。此时就会把超类和子类合并起来。**

## 以委托取代子类

## 以委托取代超类





