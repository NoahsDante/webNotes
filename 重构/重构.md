# 代码的坏味道

## 过大的类

想利用单个类做太多事情，其内往往就会出现太多字段；

用提炼类（182）将几个变量一起提炼至新类内。提炼时应该选择类内彼此相关的变量，将它们放在一起

如果类内的数个变量有着相同的前缀或后缀，这就意味着有机会把它们提炼到某个组件内。

如果这个组件适合作为一个子类，你会发现提炼超类（375）或者以子类取代类型码（362）（其实就是提炼子类）往往比较简单。

## 过长函数

活得最长、最好的程序，其中的函数都比较短。短小函数简介性带来的好处—更好的阐述力、更易于分享、更多的选择—都是小函数来支持。

函数越长越难理解；遵循这样一条原则：每当感觉需要以注释来说明什么的时候，就把需要说明的东西写进一个独立函数中，并以其用途命名。可以对一组甚至短短一行代码做这件事。只要函数名称能够解释其用途，关键不在于函数的长度，而在于函数"做什么"与"如何做"之间的语义取舍

## 过长参数列表

可以考虑使用保持对象完整手法，直接传入原来的数据结构。如果有几项参数总是同时出项，可以用引入参数对象将其合并成一个对象。如果某个参数被用作区分函数行为的标记，可以使用移除标记参数，使用类可以有效缩短参数列表。如果多个函数有同样的一个参数，引入一个类尤为有意义。

## 过长的消息链

如果你看到用户向一个对象请求另一个对象，然后再向后者请求另一个对象，然后再请求另一个对象这就是消息链；采取这种方式，意味客户端代码将与查找过程=中的导航结构紧密耦合。一旦对象间的关系发生任何变化，客户端就不得不做出相应修改。

使用隐藏委托关系（189）。你可以在消息链的不同位置采用这种重构手法

## 全局数据

全局数据的问题在于，从代码库的任何角落都可以修改它，而且没有任何机制可以探测出到底哪段代码做出了修改。

首要的防御手段是封装变量，把全局数据用一个函数包装起来，就能看见修改它的地方，并开始对它的访问。随后将这个函数搬移到一个类或模块中，之允许模块内的代码使用它，从而尽量控制其作用域。

## 可变数据

对数据的修改经常导致出乎意料的结果和难以发现的bug；在一处更新数据，却没有意识到软件中的另一处期望着完全不同的数据，于是一个功能失效了；

函数式编程完全建立在"数据永不改变"的基础上：如果要更新一个数据结构，就返回一个新的数据副本，旧的数据仍保持不变。

## 纯数据类

它们拥有一些字段，以及用于访问（读写）这些字段的函数，除此之外一无长物。这样的类只是一种不会说话的数据容器，它们几乎一定被其他类过分细琐地操控着；立刻运用封装记录（162）将它们封装起来；

于那些不该被其他类修改的字段，请运用移除设值函数。然后，找出这些取值/设值函数被其他类调用的地点。尝试以搬移函数把那些调用行为搬移到纯数据类里来。如果无法搬移整个函数，就运用提炼函数产生一个可被搬移的函数；

只要把处理数据的行为从客户端搬移到纯数据类里来；纯数据记录对象被用作函数调用的返回结果

## 重复的switch

每当你想增加一个选择分支时，必须找到所有的switch，并逐一更新；有条件逻辑都应该用多态取代

## 循环语句

使用以管道取代循环来让这些老古董退休。我们发现，管道操作（如filter和map）可以帮助我们更快地看清被处理的元素以及处理它们的动作

## 发散式变化

一旦需要修改，我们希望能够跳到系统的某一点，只在该处做修改。如果不能做到这一点，你就嗅出两种紧密相关的刺鼻味道中的一种了。如果某个模块经常因为不同的原因在不同的方向上发生变化，发散式变化就出现了；

将它们分别搬移到各自独立的模块中，能让程序变得更好；在程序刚开发出来还在随着软件系统的能力不断演进时，上下文边界通常不是那么清晰。如果发生变化的两个方向自然地形成了先后次序（比如说，先从数据库取出数据，再对其进行金融逻辑处理），就可以用拆分阶段（154）将两者分开，两者之间通过一个清晰的数据结构进行沟通

## 霰弹式修改

如果每遇到某种变化，你都必须在许多不同的类内做出许多小修改；

应该使用搬移函数和搬移字段把所有需要修改的代码放进同一个模块里。如果有很多函数都在操作相似的数据，可以使用函数组合成类。如果有些函数的功能是转化或者充实数据结构，可以使用函数组合成变换。如果一些函数的输出可以组合后提供给一段专门使用这些计算结果的逻辑，这种时候常常用得上拆分阶段。、面对霰弹式修改，一个常用的策略就是使用与内联（inline）相关的重构——如内联函数或是内联类——把本不该分散的逻辑拽回一处

## 依恋式情结

有时会发现，一个函数跟另外一个模块中的函数或者数据交流格外频繁，远胜于在自己所处模块内部的交流，这就是依恋情结。判断哪个模块拥有的此函数使用的数据最多，然后就把这个函数和那些数据摆在一起。如果先以提炼函数（106）将这个函数分解为数个较小的函数并分别置放于不同地点，上述步骤也就比较容易完成了、

## 中间人

对象的基本特征之一就是封装——对外部世界隐藏其内部细节。封装往往伴随着委托；看到某个类的接口有一半的函数都委托给其他类，这样就是过度运用；

这时应该使用移除中间人，直接和真正负责的对象打交道。如果这样“不干实事”的函数只有少数几个，可以运用内联函数把它们放进调用端。如果这些中间人还有其他行为，可以运用以委托取代超类或者以委托取代子类把它变成真正的对象

## 内幕交易

软件开发者喜欢在模块之间建起高墙，极其反感在模块之间大量交换数据，因为这会增加模块间的耦合；

在实际情况里，一定的数据交换不可避免，但我们必须尽量减少这种情况，并把这种交换都放到明面上来。

如果两个模块总是在咖啡机旁边窃窃私语，就应该用搬移函数和搬移字段减少它们的私下交流。

如果两个模块有共同的兴趣，可以尝试再新建一个模块，把这些共用的数据放在一个管理良好的地方；

或者用隐藏委托关系，把另一个模块变成两者的中介。继承常会造成密谋，因为子类对超类的了解总是超过后者的主观愿望。

如果你觉得该让这个孩子独立生活了，请运用以委托取代子类或以委托取代超类让它离开继承体系

## 被拒绝的遗赠

既然不愿意支持超类的接口，就不要虚情假意地糊弄继承体系，应该运用以委托取代子类或者以委托取代超类彻底划清界限

## 重复代码

如果在一个以上的地点看到相同的代码结构，设法将它们合而为一，程序会变得更好。要修改重复代码，必须找出所有的副本来修改。

如果重复代码只是相似而不是完全相同，首先尝试用移动语句重组代码顺序，把形式的部分放在一起以便提炼；如果重复代码段位于同一超类的不同子类，可以使用函数上移来避免在两个字类之间相互调用

## 冗赘的元素

程序元素（如类和函数）能给代码增加结构，从而支持变化、促进复用或者哪怕只是提供更好的名字也好，但有时我们真的不需要这层额外的结构

## 临时字段

其内部某个字段仅为某种特定情况而设。这样的代码让人不易理解，因为你通常认为对象在所有时候都需要它的所有字段。在字段未被使用的情况下猜测当初设置它的目的请使用提炼类给这个可怜的孤儿创造一个家，然后用搬移函数把所有和这些字段相关的代码都放进这个新家

## 夸夸其谈通用性

以各式各样的钩子和特殊情况来处理一些非必要的事情，这种坏味道就出现了如果所有装置都会被用到，就值得那么做；如果用不到，就不值得

## 异曲同工的类

今天用这个类，未来可以换成用另一个类。但只有当两个类的接口一致时，才能做这种替换。可以用改变函数声明将函数签名变得一致。但这往往还不够，请反复运用搬移函数将某些行为移入类中，直到两者的协议一致为止。如果搬移过程造成了重复代码，或许可运用提炼超类补偿一下

## 神秘命名

命名是编程中最难的两件事之一，改名是最常用的重构手法，包括改变函数声明、变量改名、字段改名；好的的名字能节省未来用在猜谜语上的大把时间。

## 注释

从嗅觉上说，注释不但不是一种坏味道，事实上它们还是一种香味呢。我们之所以要在这里提到注释，是因为人们常=把它当作“除臭剂”来使用；注释可以带我们找到本章先前提到的各种坏味道。

找到坏味道后，我们首先应该以各种重构手法把坏味道去除。

完成之后我们常常会发现：注释已经变得多余了，因为代码已经清楚地说明了一切如果你需要注释来解释一块代码做了什么，试试提炼函数；

如果函数已经提炼出来，但还是需要注释来解释其行为，试试用改变函数声明为它改名；

如果你需要注释说明某些系统的需求规格，试试引入断言。

当你感觉需要撰写注释时，请先尝试重构，试着让所有注释都变得多余

# 重构原则

## 重构

#### 重构（名词）

对软件内部的一种调整，目的是在**不改变软件可观察行为下的前提下，提高其可理解性，降低其修改成本**

#### 重构（动词）

使用一系列**重构手法**，在不改变软件可观察行为的前提下，**调整其结构**

#### 更容易理解和修改

在软件内部做很多修改，但必须对软件可观察的外部行为**只造成很小变化，甚至不造成变化**。并且达到性能优化

#### 不改变软件可观察的行为

任何用户，都不知道已经有**东西发生了变化**

### 两顶帽子

使用重构技术开发软件时，把自己的时间分配给两种截然不同的行为：**添加功能新功能、重构**

- 添加新功能时：**不应该修改既有的代码**，只管添加新功能，并且通过测试
- 重构：**不能添加新功能**，只管改进程序结构

## 为何重构

#### 改进软件设计

重构很像是在整理代码，让所有东西回到应处的位置上；代码结构的流失是累积性。

常常是因为代码在不同的地方使用完全相同的语句做同样的事；**消除重复代码**是优秀设计的根本。

#### 使软件更容易理解

可理解性还有另一方面：可以利用重构理解不熟悉的代码；不仅仅会看而且会真正动手去修改代码，让它更好地反映出我的理解，然后执行，是否正常运行，检验自己的理解是否正确

#### 帮助找到bug

对代码的理解，可以快速到bug

#### 提高编程速度

良好的设计是快速开发的根本 - 如果没有良好的设计，或许某一段时间内是可以迅速进展，但是恶劣的设计很快就让你慢下来，会把时间花到调试，无法添加新功能。修改时间越长，就必须花越多的时间去理解系统，寻找重复代码。

## 何时重构

**事不过三原则，三则重构**

### 添加功能

是否能对**这段代码进行重构，使我能更快地理解它。然后我就会重构**

### 修补错误时

调试过程中运用重构，多半是为了让代码更具**可读性**；让能一眼看出bug

### 复审代码

可以改善开发状况。这种活动有助于在开发团队中传播知识，也有助于让较有经验的开发者把知识传递给比较欠缺经验的人，并帮助更多人理解大型软件系统中的更多部分；

# 重新组织数据

将一个值用于多个不同的用途，引用和值的混淆经常会造成问题，用将**引用对象改为值对象**和将**值对象改为引用对象**在**两者之间切换**

## 拆分变量

变量个各种不同的用途，某些用途会很自然地导致临时变量被多次赋值；有两种情况：循环变量、结果收集；变量应该只承担一种职责，过多会导致会令代码阅读者糊涂

### 做法

变量的第二次赋值动作为界，修改此前对该变量的所有引用，让它们引用新变量

在待**分解变量的声明及其第一次被赋值处，修改其名称**

## 字段改名

数据结构对帮助阅读者理解代码，非常有帮助；是理解程序行为的关键

### 做法

如果记录的作用域较小，可以直接修改所有该字段的代码

如果记录还未封装，请先使用封装记录

在对象内部对私有字段改名，对应调整内部访问该字段的函数

如果构造函数的参数用了旧的字段名，运用改变函数声明将其改名

## 以查询取代派生变量

可变数据是软件中最大的错误源头之一；对数据的修改常常导致代码的各个部分以丑陋的形式互相耦合：在一处修改数据，却在另一处造成难以发现的破坏

### 做法

识别出所有对变量做更新的地方，新建一个函数，用于计算该变量的值

## 将值对象改为引用对象

一个数据结构中可能包含多个记录，而这些记录都关联到同一个逻辑数据结构；遇到这样的共享关系时，也可以将其视为引用对象；如果有多处共享值需要更新，比较方便修改；可以考虑将多份数据副本变成单一的引用

### 做法

为相关对象创建一个仓库（如果还没有这样一个仓库的话）。确保构造函数有办法找到关联对象的正确实例。

修改宿主对象的构造函数，令其从仓库中获取关联对象。每次修改后执行测试

## 将引用对象改为值对象

在把一个对象（或数据结构）嵌入另一个对象时，位于内部的这个对象可以被视为引用对象，也可以被视为值对象如果将内部对象视为引用对象，在更新其属性时，我会保留原对象不动，更新内部对象的属性；如果将其视为值对象，我就会替换整个内部对象，新换上的对象会有我想要的属性值；值对象通常更容易理解，主要因为它们是不可变的。一般说来，不可变的数据结构处理起来更容易

### 做法

用移除设值函数（331）逐一去掉所有设值函数，提供一个基于值的相等性判断函数，在其中使用值对象的字段

# 简化条件表达式

## 分解条件表达式

复杂的条件逻辑是最常导致复杂度上升因素之一，代码来检查不同的条件分支，根据不同的条件做不同的事；代码来检查不同的条件分支，根据不同的条件做不同的事；

可以将它分解为多个独立的函数，根据每个小块代码的用途，为分解而得的新函数命名，并将原函数中对应的代码改为调用新函数，从而更清楚地表达自己的意图。可以突出条件逻辑，更清楚地表明每个分支的作用，并且突出每个分支的原因

### 做法

对条件判断和每个条件分支分别运用**提炼函数手法**

## 合并条件表达式

检查条件各不相同，最终行为却一致；就应该**使用“逻辑或”和“逻辑与”将它们合并为一个条件表达式**；

合并后的条件代码会表述“实际上只有一次条件检查，只不过有多个并列条件需要检查而已”，从而使这一次检查的用意更清晰；这项重构往往可以为使用**提炼函数做好准备**

### 做法

确定这些条件**表达式都没有副作用。**
如果某个条件表达式有副作用，可以先用将查询函数和修改函数分离处理。
使用适当的逻辑运算符，将两个相关条件表达式合并为一个。
顺序执行的条件表达式用逻辑或来合并，嵌套的if语句用逻辑与来合并。

## 以卫语句取代嵌套表达式

条件表达式通常有两种风格。

第一种风格是：两个条件分支都属于正常行为。
**应该使用形如if...else...的条件表达式**

第二种风格则是：只有一个条件分支是正常行为，另一个分支则是异常的情况
如果某个条件极其罕见，就应该单独检查该条件，并在该条件为真时立刻从函数中返回。这样的**单独检查常常被称为“卫语句”（guard clauses）** if() return 

以卫语句取代嵌套条件表达式的精髓就是：给某一条分支以特别的重视。**如果使用if-then-else结构，你对if分支和else分支的重视是同等**
卫语句，它告诉阅读者：“这种情况不是本函数的核心逻辑所关心的，**如果它真发生了，请做一些必要的整理工作，然后退出。**”

### 做法

选中**最外层需要被替换的条件逻辑，将其替换为卫语句**

## 以多态取代条件表达式

可以将**条件逻辑拆分到不同的场景（或者叫高阶用例）**，从而拆解复杂的条件逻辑。这种拆分有时用条件逻辑本身的结构就足以表达，但使用**类和多态能把逻辑的拆分表述得更清晰**

### 做法

如果**现有的类尚不具备多态行为，就用工厂函数创建之，令工厂函数返回恰当的对象实例**

## 引入特例

一个数据结构的使用者都在检查某个特殊的值，并且当这个特殊值出现时所做的处理也都相同。**处理这种情况的一个好办法是使用“特例”（Special Case）模式：创建一个特例元素，用以表达对这种特例的共用行为的处理**

### 做法

给重构目标添加检查特例的属性，令其返回false。
创建一个特例对象，其中只有检查特例的属性，返回true。

# 封装

## 封装记录

对于可变数据类，使用对象而飞记录，对象可以隐藏结构细节，该对象的用户不必追究存储的细节和计算的过程。同时，这种封装还有助于字段的改名：可以重新命名字段，同时提供新老字段名的访问方法；

### 做法

对持有记录的变量使用封装变量，将其封装到一个函数中。记得为这个函数取一个容易搜索的名字。创建一个类，将记录包装起来，并将记录变量的值替换为该类的一个实例。然后再类上定义一个访问函数，用于返回原始记录。修改封装变量的函数，令其使用这个访问函数。

## 封装集合

只对集合变量的访问进行封装，但依然让取值函数返回集合本身。这是使得集合的成员变量可以直接被修改，而封装它的类则全然不知，无法介入。为了避免此终情况，会在类上提供一些修改集合的方法-通常是添加 和移除方法。这样就可使对集合的修改必须经过类，当程序演化变大时，依然能轻易找出修改点。

### 做法

如果集合的引用尚未被封装起来，先用封装变量封装它。在类上添加用于"添加集合元素"和"移除元素"的函数。

如果存在对集合的设值函数尽可能先用移除函数移除。如果不能移除该函数，至少让它返回集合的一份副本。执行静态检查。

查找集合的引用点。如果用调用者直接修改集合，令该处调用使用新的添加/移除元素的函数。每次修改后执行测试。修改集合的取值函数，使其返回一份只读的数据，可以使用只读代理或数据本。

## 以对象取代基本类型

发现对某个数据的操作不仅仅局限于打印时，就会为他创建一个新类，只要类有了，日后添加的业务逻辑就有地方可去了。

### 做法

如果变量尚未被封装起来，先使用封装变量封装它。为这个数据值创建一个简单的类。类的构造函数应该保持这个数据值，并为它提供一个取值函数。执行静态检查。修改第一步得到的设值函数，令其创建一个新类对象并将其存入字段，没如果有必要的话，同时修改字段的类型声明。修改取值函数，令其调用新类的取值函数，并返回结果。

## 以查询取代临时变量

将变量的计算逻辑放到函数中，有助于在提炼得到的函数与原函数之间设立清晰的边界，这能帮助发现依赖和副作用。

改用函数避免多个函数中重复编写计算逻辑。以查询取代临时变量手法只适用于处理某些类型的临时变量；

### 做法

检查变量在使用前是否己经完全计算完毕，检查计算那段代码是否每次都能得到一样的值。

如果变量目前不是只读，但是可以改造成只读变量

## 提炼类

在开发后期出现信号时类的子类化方式，如果发现子类化只影响类的部分特性，或如果发现某些特性需要以一种方式来子类化，某些特性则需要以另外一种方式子类化，这就意味着需要分解原来的类。

### 做法

创建一个新的类，用以表现从旧类中分离出来的责任。如果旧类剩下的责任与旧类的名称不符，为旧类改名。构造旧类时创建一个新类的实例，建立"从旧类访问新类"的连接关系

## 内联类

如果一个类不在承担足够责任，不再有单独存在的理由，就会把内联到相关类中去。

### 做法

对于待内联类中的所有函数，在目标上创建一个对应的函数，新创建的所有函数应该直接委托至源类。修改源类方法的所有引用点，令它们调用目标类对应的委托方法。每次更改后运行测试。

## 隐藏委托关系

"封装"意味着每个模块都应该尽可能少了解系统的其他部分，如此一来，一旦发生变化，需要了解这一变化的模块就会比较少-这会使变化比较容易进行。

### 做法

对于每个委托关系中的函数，在服务对象建立一个简单的委托函数，调整客户端，令它只调用服务对象提供的函数。每次调整运行测试。

## 移除中间人

每当客户端要使用受委托的新特性时，就必须在服务端添加一个简单委托函数，随着受托类的特性越来越多，更多的转发函数就会使人烦躁。服务类完全变成一个中间人，此时就应该让客户端直接调用委托类。

### 做法

为委托对象创建一个取值函数。对于每个委托函数，让其客户端转为连续的访问函数调用。每次替换后运行测试，替换完委托方法的所有调用点后，就可以删掉这个委托方法了。

## 替换算法

把原先的算法替换为一个较易修改的算法，这样后续的修改会轻松许多

### 做法

整理一下待替换的算法，保证它已经被抽取到一个独立函数中，先只为这个函数准备测试，以便固定它的行为。

# 搬移特性

## 搬移函数

**模块化**是优秀软件设计的核心所在，好的模块化能够让我在修改程序时只**需理解程序的一小部分**；

最直接的一个动因是，它**频繁引用其他上下文中的元素**，而对自身上下文中的元素却关心甚少；搬移到某些更通用的地方

### 做法

检查函数在当前上下文里引用的所有程序元素（包括变量和函数），考虑是否需要将它们一并搬

## 移动语句

### 动机

**让存在关联的东西一起出现，可以使代码更容易理解**

## 搬移字段

### 动机

往往数据结构才是一个健壮程序的根基；搬移字段的**操作通常是在其他更大的改动背景下发生的**

## 搬移语句到函数

### 动机

我发现调用某个函数时，**总有一些相同的代码也需要每次执行**，那么我会考虑将此段代码合并到函数里头

## 搬移语句到调用者

### 动机

把**表现不同的行为从函数里挪出，并搬移到其调用处**；要差异代码被搬移到调用点

## 以函数调用取代内联代码

### 动机

善用**函数可以帮助我将相关的行为打包起来**，这对于提升代码的表达力大有裨益—— 一**个命名良好的函数，本身就能极好地解释代码的用途，使读者不必了解其细节**；函数**同样有助于消除重复，因为同一段代码我不需要编写两次，每次调用一下函数即可**



## 拆分循环

### 动机

如果你在一次循环中做了两件不同的事，那么**每当需要修改循环时，你都得同时理解这两件事情**。如果能够将循环拆分，让一个循环只做一件事情，那就能确保每次修改时你需要理解要修改的那块代码的行为就可以了

## 以管道取代循环

集合管道是这样一种技术，**它允许我使用一组运算来描述集合的迭代过程**，其中每种运算接收的入参和返回值都是一个集合

## 移除死代码

当你尝试阅读代码、理解软件的运作原理时，**无用代码确实会带来很多额外的思维负担**；一旦代码不再被使用，我们就该立马删除它。**有可能以后又会需要这段代码，但我从不担心这种情况；就算真的发生，我也可以从版本控制系统里再次它翻找出来**

# 重构API

## 将查询函数和修改函数分离

保持函数单一原则，并且任何有返回值的函数，都不应该有看得到的副作用；如果遇到一个"既有返回值又有副作用"的函数，就将分开

### 做法

复制整个函数，将其作为一个查询命名

## 函数参数化

发现两个函数逻辑非常相似，只有一些字面量不同，可以将其合并成一个函数，以参数的形式传入不同的值

### 做法

从一组相似的函数中选择一个，运用改变函数声明，把需要作为参数传入的字面量添加到参数列表修改改函数所有的调用处，使其在调用时传入改字面量

## 移除标记参数

调用者用它来指示被调用者函数应该执行那一部分逻辑

### 做法

如果主函数有清晰的条件分发逻辑，可以用分解条件表达式创建明确函数；否则，可以在原函数之上创建包装函数



## 保持对象完整

函数有多个参数时，应传入对象，如果将来被调的函数需要从记录中导出更多的数据，我就不用为此修改参数列表。并且传递整个记录也能缩短参数列表，让函数调用更容易看懂

### 做法

新建一个空函数，给它以期望中的参数列表（即传入完整对象作为参数）。给这个函数起一个容易搜索的名字，这样到重构结束时方便替换。在新函数体内调用旧函数，并把新的参数（即完整对象）映射到旧的参数列表（即来源于完整对象的各项数据）。

## 以查询取代参数

函数的参数列表应该总结该函数的可变性，标示出函数可能体现出行为差异的主要方式。和任何代码中的语句一样，参数**列表应该尽量避免重复**，**并且参数列表越短就越容易理解**

### 做法

如果有必要，使用提炼函数将参数的计算过程提炼到一个独立的函数中。将函数体内引用该参数的地方改为调用新建的函数。每次修改后执行测试。全部替换完成后，使用改变函数声明将该参数去掉。

## 以参数取代查询

了让目标函数不再依赖于某个元素，我把这个元素的值以参数形式传递给该函数

### 做法

对执行查询操作的代码使用提炼变量，将其从函数体中分离出来。现在函数体代码已经不再执行查询操作（而是使用前一步提炼出的变量），对这部分代码使用提炼函数。给提炼出的新函数起一个容易搜索的名字，以便稍后改名。使用内联变量，消除刚才提炼出来的变量。对原来的函数使用内联函数。对新函数改名，改回原来函数的名字。

## 移除设值函数

如果为某个字段提供了设值函数，这就暗示这个字段可以被改变。如果不希望在对象创建之后此字段还有机会被改变，那就不要为它提供设值函数（同时将该字段声明为不可变）

### 做法

如果构造函数尚无法得到想要设入字段的值，就使用改变函数声明将这个值以参数的形式传入构造函数。在构造函数中调用设值函数，对字段设值。如果想移除多个设值函数，可以一次性把它们的值都传入构造函数，这能简化后续步骤

## 以工厂取代构造函数

**工厂函数的实现内部可以调用构造函数，但也可以换成别的方式实现**

### 做法

新建一个工厂函数，让它调用现有的构造函数。将调用构造函数的代码改为调用工厂函数。每修改一处，就执行测试

## 以命令取代函数

函数，不管是独立函数，还是以方法（method）形式附着在对象上的函数，是程序设计的基本构造块。不过，将函数封装成自己的对象，有时也是一种有用的办法

### 做法

为想要包装的函数创建一个空的类，根据该函数的名字为其命名。使用搬移函数把函数移到空的类里

## 以函数取代命令

借助命令对象，可以轻松地将原本复杂的函数拆解为多个方法，彼此之间通过字段共享状态；拆解后的方法可以分别调用；开始调用之前的数据状态也可以逐步构建

### 做法

运用提炼函数，把“创建并执行命令对象”的代码单独提炼到一个函数中。这一步会新建一个函数，最终这个函数会取代现在的命令对象。对命令对象在执行阶段用到的函数，逐一使用内联函数。如果被调用的函数有返回值，请先对调用处使用提炼变量，然后再使用内联函数。使用改变函数声明，把构造函数的参数转移到执行函数。对于所有的字段，在执行函数中找到引用它们的地方，并改为使用参数。每次修改后都要测试。把“调用构造函数”和“调用执行函数”两步都内联到调用方（也就是最终要替换命令对象的那个函数）

# 处理继承关系

## 函数上移

如果某个函数在各个子类的函数体都相同，这就是最显而易见的函数上移适用场合

### 做法

检查待提升函数，确定他们是完全一致的；如果他们做了相同的事情，但函数并不完全一致，那就先对他们进行重构，直到其函数体完全一致

如果待提升函数签名不同，使用改变函数声明，将哪些签名都修改为，想要在超类中使用的签名

## 字段上移

如果他们使用的方式很相似，可以将它们提升到超类中去；首先他先除去重复的数据声明；其次它使用该字段的行为子类移至超类

### 做法

针对待提升字段，检查它们的所有使用点，确认它们以同样方式使用；如果这些字段的名称不同，先使用变量改名为它们取相同的名字。在超类中新建一个字段。

## 构造函数本体上移

如果各个子类中的函数用共同行为，将使用以工厂函数取代构造函数

### 做法

如果超类不存在构造函数，首先定义一个，确保让子类调用超类的构造函数，使用移动语句将子类中构造函数中的公共语句移动到超类的构造函数调用语句之后；逐一移除子类间的公共代码，将其提升超类函数中，对于公共代码中引用到的变量，将其作为参数传递给超类的构造函数

## 函数下移

如果超类中的某个函数只与一个（或少数几个）子类有关，那么最好将其从超类中挪走，放到真正关心它的字类中去；且明确哪些子类需要用到这个函数中

### 做法

将超类中的函数本体复制到每个一个需要此函数的子类

## 字段下移

如果某个字段只被一个子类（或者一小部分子类）用到，就将其搬移到需要该字段的子类中

### 做法

在所有需要该字段的子类中声明该字段

## 以子类取代类型码

可以创建子类，然后用字段下移把这样的字段放到合适的子类中去

### 做法

自封装类型字段。任选一个类型码取值，为其创建一个子类，覆写类型码类的取值函数，令其返回该类型码的字面量值。创建一个选择器逻辑，把类型码参数映射到新的子类。如果选择直接继承的方案，就用工厂函数取代构造函数包装构造函数，把选择器逻辑放在工厂函数里；如果选择间接继承方案，选择器逻辑可以保留在构造函数里

## 移除子类

有时添加子类是为了应对未来的功能，结果想象中的功能没有出来，或者用另一种方式构造，是子类不在需要了，子类存在着就有成本，阅读者需要花心思去理解它的用意，如果子类的用处太少，就不值得存在了

### 做法

如果构造函数的客户端用一个数组字段来决定实例化哪个子类，可以把这个判断逻辑放到超类的工厂函数中

## 提炼超类

看见两个类在做相似的事，可以利用继承机制把它们的相似之处提炼到超类，另一种选择是提炼类委托，目的都是把重复的行为收拢一处。

### 做法

为原本的类新建一个空白的超类；如果需要可用函数声明调整构造函数的签名

## 折叠继承体系

在重构类继承体系时，经常把函数和字段上下移动，但是随着继承体系的演化，有时会发现一个类与其超类已经没多大差别，不值得再作为独立的类存在**。此时就会把超类和子类合并起来。**

### 做法

使用字段上移，字段下移，函数上移和函数下移，把所有元素都移到同一个类中。调整即将被移除的那个类的所有引用点，令它们改而引用合并后留下的类，移除我们的目标，此时它应该已经成为一个空类。

## 以委托取代子类

继承给类之间引入类非常紧密的关系，在超类上做任何修改，都很可能破坏子类；为决解这个问题可使用委托，对于不同的变化原因，可以委托不同的类。委托时对象之间常规的关系，与继承相比，使用委托关系时接口更清晰，耦合更少。

### 做法

如果构造函数有多个调用者，首先用以工厂函数取代构造函数把构造函数包装起来。

创建一个空的委托类，这个类的构造函数应该接受所有子类特有的数据项，并且经常以参数的形式接受一个指回超类的引用。在超类中添加一个字段，用于安放委托对象。修改子类的创建逻辑，使其初始化上述委托字段，放入一个委托对象的实例。这一步可在工厂函数中完成，也可以在构造函数中完成。

选择一个子类的函数，将其移入委托类。

使用搬移函数手法搬移上述函数，不要删除源类中的委托代码。如果这个方法用到的其他元素也应该被移入委托对象，就把它们一并搬移。如果它用到的元素应该留在超类中，就在委托对象中添加一个字段，令其指向超类的实例。

如果被搬移的源函数还在子类之外被调用了，就把留在源类中的委托代码从子类移到超类，并在委托代呢之前加上卫语句，检查对象存在。如果子类之外已经没有其他调用者，就用移除死代码去掉已经没人使用的委托代码。如果有多个委托类，并且其中的代码出现重复，就使用提炼函数手法消除重复。此时如果默认行为已经被移入委托类的超类，源超类得 委托函数就不再需要卫语句类。





