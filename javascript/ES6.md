# 块级绑定

## var 声明与变量提升

使用var关键声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部

## 块级声明

让所声明的变量在指定的作用域外无法被访问

被创建的情况

1. 在函数内部
2. 在一个代码块（由一对花括号包裹）内部

### let声明

let声明会将变量的作用域限制在当前的代码块中；由于let声明并不会被提升到当前代码块的顶部，因此需要手动将let声明放置到顶部，以便让变量在整个代码块内部可用

#### 禁止重复声明

如果一个标识符已经在**代码块内部被定义，在此代码块内使用同一个标识符进行let声明就会导致抛出错误**

### 常量声明

使用const声明的变量会被认为是常量，意味着它们的值被设置完成后就不能再被改变。

#### 对比常量声明于let声明

常量声明与let声明一样，都是块级声明。

试图对之前用const声明的常量进行赋值会抛出错误，无论在严格模式还是非严格模式。

JS的常量如果是一个对象，它所包含的值是可以被修改的。

#### 使用const声明对象

const声明会阻止对**变量绑定与变量自身值的修改**，这意味着const声明并不会阻止对变量成员的修改

### 暂时性死区

**使用let或const声明的常量，在达到声明之处都是无法访问**的，试图访问会导致一个引用错误，即使在通常是安全的操作，也是如此。

当JS引擎检视接下的代码块并发现变量声明时，它会面对var的情况下将声明变量提升到函数或全局作用域的顶部，而面对let或const时会将声明放在暂时性死区。任何在暂时性死区内访问变量的企图都会导致"运行"时错误。只有执行到变量的声明语句时，该变量才会从暂时性死区内被移除并可以安全使用。

使用let或const声明的变量，若试图在定义位置之前使用它，无论如何都不能避免暂时性死区。

## 循环中的块级绑定

开发者需要使用变量的块级作用域的场景，想让一次性循环计数器仅能在循环内部使用。

### 循环的函数

在for循环中去调函数调用，但达到的预期却不一致；这是因为变量i在循环的每次迭代中都被共享了，意味着循环内创建的那些函数都拥有对同一变量的引用。

### 循环内的常量声明

ES6规范没有明确禁止在循环中使用const声明，然而它会根据循环方式的不同有不同行为，在常规的for循环中，初始化时使用const，循环在你试图变量的值时抛出错误。

## 全局块级绑定

在全局作用域上使用let或const，虽然在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上。这也意味着你不能使用const或let来覆盖一个全局变量，只能将其屏蔽。

## 块级绑定新的最佳实践

默认情况下应当使用let而不是var；当对需要受到保护的变量使用const

# 字符串

## 更好的Unicode支持

### UTF - 16 代码点

用一个数字来代表一个字符。字符编码要求将代码点转换为内部一致的码元，而对于 UTF-16 来说，代码点可以由多个码元组成

### codePoinAt()方法

codePointAt() ，它可以在给定字符串中按位置提取 Unicode 代码点；该方法接受的是码元位置而非字符位置，并返回一个整数值

### String.fromCodePoint() 方法

给定的代码点来产生包含单个字符的字符串

### normalize() 方法

Unicode 另一个有趣之处是，不同的字符在排序或其它一些比较操作中可能会被认为是相同的；比较字符串时，它们必须被标准化为同一种形式

### 正则表达式U标志

使用正则表达式来完成字符串的很多通用操作。但要记住，正则表达式假定单个字符使用一个 16 位的码元来表示。为了解决这个问题， ES6 为正则表达式定义了用于处理Unicode 的   u 标志。

#### U标志如何运作

当一个正则表达式设置了 u 标志时，它的工作模式将切换到针对字符，而不是针对码元；

```js
var text = "" ;
console.log(text.length); // 2
console.log(/^.$/.test(text)); // false
console.log(/^.$/u.test(text)); // true
```

正则表达式   /^.$/ 会匹配只包含单个字符的任意输入字符串。当不使用   u 标志时，该正则
表达式只匹配码元，所以不能匹配由两个码元表示的这个日文字符。启用   u 标志后，正则表
达式就会比较字符而不是码元，所以这个日文字符就会被匹配到

#### 计算代码数量

```js
function codePointLength(text) {
var result = text.match(/[\s\S]/gu);
return result ? result.length : 0;
}
```

调用了   match() 方法来检查   text 中的空白字符与非空白字符（使用   [\s\S] 以确保该模式能匹配换行符），所用的正则表达式启用了全局与 Unicode 特性

#### 判断是否支持U标志

```js
function hasRegExpU() {
try {
var pattern = new RegExp(".", "u"); return true;
} catch (ex) {
function hasRegExpU() {
try {
var pattern = new RegExp(".", "u"); return true;
} catch (ex) {
```

此函数将   u 作为一个参数来调用   RegExp 构造器，该语法即使在旧版 JS 引擎中都是有效的，而构造器在   u 未被支持的情况下会抛出错误

## 字符串的其他改动

此函数将   u 作为一个参数来调用   RegExp 构造器，该语法即使在旧版 JS 引擎中都是有效的，而构造器在   u 未被支持的情况下会抛出错误

### 识别子字符串的方法

includes() 方法，在给定文本存在于字符串中的任意位置时会返回 true ，否则返回false ；

startsWith() 方法，在给定文本出现在字符串起始处时返回 true ，否则返回 false ；

endsWith() 方法，在给定文本出现在字符串结尾处时返回 true ，否则返回 false 。

每个方法都接受两个参数：需要搜索的文本，以及可选的搜索起始位置索引。

**当提供了第二个参数时，   includes() 与   startsWith() 方法会从该索引位置开始尝试匹配；**

而endsWith() 方法会将字符串长度减去该参数，以此为起点开始尝试匹配。当第二个参数未提

供时，  

 includes() 与   startsWith() 方法会从字符串起始处开始查找，而   endsWith() 方法

则从尾部开始。实际上，第二个参数减少了搜索字符串的次数

如果向   startsWith() 、   endsWith() 或   includes() 方法传入了**正则表达式而不是字符串**，会抛出错误。这与   i**ndexOf() 以及   lastIndexOf() 方法的表现形成了反差，**它们会将正则表达式转换为字符串并搜索它。

### repeat() 方法

它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串

此方法比相同目的的其余方法更加方便，在操纵文本时特别有用，尤其是在需要产生缩进的代码格式化工具中

## 正则表达式的其他改动

### 正则表达式Y标志

在 Firefox 实现了对正则表达式   y 标志的专有扩展之后，ES6 将该实现标准化。

   y 标志影响正则表达式搜索时的粘连（   sticky ）属性，它表示从正则表达式的   lastIndex 属性值的位置开始检索字符串中的匹配字符。如果在该位置没有匹配成功，那么正则表达式将停止检索

### 复制正则表达式

### flags属性

## 模版字面量

### 基本语法

使用反引号（   ` ）来包裹普通字符串，而不是用双引号或单引号;

想在字符串中包含反引号，只需使用反斜杠（   \ ）转义即可;

在模板字面量中无需对双引号或单引号进行转义。

### 多行字符串

S6 的模板字面量使多行字符串更易创建，因为它不需要特殊的语法。只需在想要的位置包含换行即可，而且它会显示在结果中

### 制造替换位

替换位允许你将任何有效的 JS 表达式嵌入到模板字面量中，并将其结果输出为字符串的一部分;

替换位由起始的   ${ 与结束的   } 来界定，之间允许放入任意的 JS 表达式

模板字面量能访问到作用域中任意的可访问变量。试图使用未定义的变量会抛出错误;

**模板字面量本身也是 JS 表达式，意味着你可以将模板字面量嵌入到另一个模板字面量内部**

### 标签化模版

模板字面量进行转换并返回最终的字符串值，标签在模板的起始处被指定，即在第一个   ` 之前模板字面量进行转换并返回最终的字符串值，标签在模板的起始处被指定，即在第一个   ` 之前

#### 定义标签

一个标签（ tag ）仅是一个函数，它被调用时接收需要处理的模板字面量数据。标签所接收的数据被划分为独立片段，并且必须将它们组合起来以创建结果

#### 使用模版字面量中原始值

板标签也能访问字符串的原始信息，主要指的是可以访问字符在转义之前的形式。获取原始字符串值的最简单方式是使用内置的   String.raw() 标签。