# 块级绑定

## var 声明与变量提升

使用var关键声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部

## 块级声明

让所声明的变量在指定的作用域外无法被访问

被创建的情况

1. 在函数内部
2. 在一个代码块（由一对花括号包裹）内部

### let声明

let声明会将变量的作用域限制在当前的代码块中；由于let声明并不会被提升到当前代码块的顶部，因此需要手动将let声明放置到顶部，以便让变量在整个代码块内部可用

#### 禁止重复声明

如果一个标识符已经在**代码块内部被定义，在此代码块内使用同一个标识符进行let声明就会导致抛出错误**

### 常量声明

使用const声明的变量会被认为是常量，意味着它们的值被设置完成后就不能再被改变。

#### 对比常量声明于let声明

常量声明与let声明一样，都是块级声明。

试图对之前用const声明的常量进行赋值会抛出错误，无论在严格模式还是非严格模式。

JS的常量如果是一个对象，它所包含的值是可以被修改的。

#### 使用const声明对象

const声明会阻止对**变量绑定与变量自身值的修改**，这意味着const声明并不会阻止对变量成员的修改

### 暂时性死区

**使用let或const声明的常量，在达到声明之处都是无法访问**的，试图访问会导致一个引用错误，即使在通常是安全的操作，也是如此。

当JS引擎检视接下的代码块并发现变量声明时，它会面对var的情况下将声明变量提升到函数或全局作用域的顶部，而面对let或const时会将声明放在暂时性死区。任何在暂时性死区内访问变量的企图都会导致"运行"时错误。只有执行到变量的声明语句时，该变量才会从暂时性死区内被移除并可以安全使用。

使用let或const声明的变量，若试图在定义位置之前使用它，无论如何都不能避免暂时性死区。

## 循环中的块级绑定

开发者需要使用变量的块级作用域的场景，想让一次性循环计数器仅能在循环内部使用。

### 循环的函数

在for循环中去调函数调用，但达到的预期却不一致；这是因为变量i在循环的每次迭代中都被共享了，意味着循环内创建的那些函数都拥有对同一变量的引用。

### 循环内的常量声明

ES6规范没有明确禁止在循环中使用const声明，然而它会根据循环方式的不同有不同行为，在常规的for循环中，初始化时使用const，循环在你试图变量的值时抛出错误。

## 全局块级绑定

在全局作用域上使用let或const，虽然在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上。这也意味着你不能使用const或let来覆盖一个全局变量，只能将其屏蔽。

## 块级绑定新的最佳实践

默认情况下应当使用let而不是var；当对需要受到保护的变量使用const

