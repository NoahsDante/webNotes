# 块级绑定

## var 声明与变量提升

使用var关键声明的变量，无论其实际声明位置在何处，都会被视为声明于所在函数的顶部

## 块级声明

让所声明的变量在指定的作用域外无法被访问

被创建的情况

1. 在函数内部
2. 在一个代码块（由一对花括号包裹）内部

### let声明

let声明会将变量的作用域限制在当前的代码块中；由于let声明并不会被提升到当前代码块的顶部，因此需要手动将let声明放置到顶部，以便让变量在整个代码块内部可用

#### 禁止重复声明

如果一个标识符已经在**代码块内部被定义，在此代码块内使用同一个标识符进行let声明就会导致抛出错误**

### 常量声明

使用const声明的变量会被认为是常量，意味着它们的值被设置完成后就不能再被改变。

#### 对比常量声明于let声明

常量声明与let声明一样，都是块级声明。

试图对之前用const声明的常量进行赋值会抛出错误，无论在严格模式还是非严格模式。

JS的常量如果是一个对象，它所包含的值是可以被修改的。

#### 使用const声明对象

const声明会阻止对**变量绑定与变量自身值的修改**，这意味着const声明并不会阻止对变量成员的修改

### 暂时性死区

**使用let或const声明的常量，在达到声明之处都是无法访问**的，试图访问会导致一个引用错误，即使在通常是安全的操作，也是如此。

当JS引擎检视接下的代码块并发现变量声明时，它会面对var的情况下将声明变量提升到函数或全局作用域的顶部，而面对let或const时会将声明放在暂时性死区。任何在暂时性死区内访问变量的企图都会导致"运行"时错误。只有执行到变量的声明语句时，该变量才会从暂时性死区内被移除并可以安全使用。

使用let或const声明的变量，若试图在定义位置之前使用它，无论如何都不能避免暂时性死区。

## 循环中的块级绑定

开发者需要使用变量的块级作用域的场景，想让一次性循环计数器仅能在循环内部使用。

### 循环的函数

在for循环中去调函数调用，但达到的预期却不一致；这是因为变量i在循环的每次迭代中都被共享了，意味着循环内创建的那些函数都拥有对同一变量的引用。

### 循环内的常量声明

ES6规范没有明确禁止在循环中使用const声明，然而它会根据循环方式的不同有不同行为，在常规的for循环中，初始化时使用const，循环在你试图变量的值时抛出错误。

## 全局块级绑定

在全局作用域上使用let或const，虽然在全局作用域上会创建新的绑定，但不会有任何属性被添加到全局对象上。这也意味着你不能使用const或let来覆盖一个全局变量，只能将其屏蔽。

## 块级绑定新的最佳实践

默认情况下应当使用let而不是var；当对需要受到保护的变量使用const

# 字符串

## 更好的Unicode支持

### UTF - 16 代码点

用一个数字来代表一个字符。字符编码要求将代码点转换为内部一致的码元，而对于 UTF-16 来说，代码点可以由多个码元组成

### codePoinAt()方法

codePointAt() ，它可以在给定字符串中按位置提取 Unicode 代码点；该方法接受的是码元位置而非字符位置，并返回一个整数值

### String.fromCodePoint() 方法

给定的代码点来产生包含单个字符的字符串

### normalize() 方法

Unicode 另一个有趣之处是，不同的字符在排序或其它一些比较操作中可能会被认为是相同的；比较字符串时，它们必须被标准化为同一种形式

### 正则表达式U标志

使用正则表达式来完成字符串的很多通用操作。但要记住，正则表达式假定单个字符使用一个 16 位的码元来表示。为了解决这个问题， ES6 为正则表达式定义了用于处理Unicode 的   u 标志。

#### U标志如何运作

当一个正则表达式设置了 u 标志时，它的工作模式将切换到针对字符，而不是针对码元；

```js
var text = "" ;
console.log(text.length); // 2
console.log(/^.$/.test(text)); // false
console.log(/^.$/u.test(text)); // true
```

正则表达式   /^.$/ 会匹配只包含单个字符的任意输入字符串。当不使用   u 标志时，该正则
表达式只匹配码元，所以不能匹配由两个码元表示的这个日文字符。启用   u 标志后，正则表
达式就会比较字符而不是码元，所以这个日文字符就会被匹配到

#### 计算代码数量

```js
function codePointLength(text) {
var result = text.match(/[\s\S]/gu);
return result ? result.length : 0;
}
```

调用了   match() 方法来检查   text 中的空白字符与非空白字符（使用   [\s\S] 以确保该模式能匹配换行符），所用的正则表达式启用了全局与 Unicode 特性

#### 判断是否支持U标志

```js
function hasRegExpU() {
try {
var pattern = new RegExp(".", "u"); return true;
} catch (ex) {
function hasRegExpU() {
try {
var pattern = new RegExp(".", "u"); return true;
} catch (ex) {
```

此函数将   u 作为一个参数来调用   RegExp 构造器，该语法即使在旧版 JS 引擎中都是有效的，而构造器在   u 未被支持的情况下会抛出错误

## 字符串的其他改动

此函数将   u 作为一个参数来调用   RegExp 构造器，该语法即使在旧版 JS 引擎中都是有效的，而构造器在   u 未被支持的情况下会抛出错误

### 识别子字符串的方法

includes() 方法，在给定文本存在于字符串中的任意位置时会返回 true ，否则返回false ；

startsWith() 方法，在给定文本出现在字符串起始处时返回 true ，否则返回 false ；

endsWith() 方法，在给定文本出现在字符串结尾处时返回 true ，否则返回 false 。

每个方法都接受两个参数：需要搜索的文本，以及可选的搜索起始位置索引。

**当提供了第二个参数时，   includes() 与   startsWith() 方法会从该索引位置开始尝试匹配；**

而endsWith() 方法会将字符串长度减去该参数，以此为起点开始尝试匹配。当第二个参数未提

供时，  

 includes() 与   startsWith() 方法会从字符串起始处开始查找，而   endsWith() 方法

则从尾部开始。实际上，第二个参数减少了搜索字符串的次数

如果向   startsWith() 、   endsWith() 或   includes() 方法传入了**正则表达式而不是字符串**，会抛出错误。这与   i**ndexOf() 以及   lastIndexOf() 方法的表现形成了反差，**它们会将正则表达式转换为字符串并搜索它。

### repeat() 方法

它接受一个参数作为字符串的重复次数，返回一个将初始字符串重复指定次数的新字符串

此方法比相同目的的其余方法更加方便，在操纵文本时特别有用，尤其是在需要产生缩进的代码格式化工具中

## 正则表达式的其他改动

### 正则表达式Y标志

在 Firefox 实现了对正则表达式   y 标志的专有扩展之后，ES6 将该实现标准化。

   y 标志影响正则表达式搜索时的粘连（   sticky ）属性，它表示从正则表达式的   lastIndex 属性值的位置开始检索字符串中的匹配字符。如果在该位置没有匹配成功，那么正则表达式将停止检索

### 复制正则表达式

### flags属性

## 模版字面量

### 基本语法

使用反引号（   ` ）来包裹普通字符串，而不是用双引号或单引号;

想在字符串中包含反引号，只需使用反斜杠（   \ ）转义即可;

在模板字面量中无需对双引号或单引号进行转义。

### 多行字符串

S6 的模板字面量使多行字符串更易创建，因为它不需要特殊的语法。只需在想要的位置包含换行即可，而且它会显示在结果中

### 制造替换位

替换位允许你将任何有效的 JS 表达式嵌入到模板字面量中，并将其结果输出为字符串的一部分;

替换位由起始的   ${ 与结束的   } 来界定，之间允许放入任意的 JS 表达式

模板字面量能访问到作用域中任意的可访问变量。试图使用未定义的变量会抛出错误;

**模板字面量本身也是 JS 表达式，意味着你可以将模板字面量嵌入到另一个模板字面量内部**

### 标签化模版

模板字面量进行转换并返回最终的字符串值，标签在模板的起始处被指定，即在第一个   ` 之前模板字面量进行转换并返回最终的字符串值，标签在模板的起始处被指定，即在第一个   ` 之前

#### 定义标签

一个标签（ tag ）仅是一个函数，它被调用时接收需要处理的模板字面量数据。标签所接收的数据被划分为独立片段，并且必须将它们组合起来以创建结果

#### 使用模版字面量中原始值

板标签也能访问字符串的原始信息，主要指的是可以访问字符在转义之前的形式。获取原始字符串值的最简单方式是使用内置的   String.raw() 标签。

# 函数

## 带参数默认值的函数

JS 函数的独特之处是可以接受任意数量的参数，而无视函数声明处的参数数量。这让你定义的函数可以使用不同的参数数量来调用，调用时未提供的参数经常会使用默认值来代替。

### 在ES5中模拟参数默认值

```javascript
function makeRequest(url, timeout, callback) {
timeout = timeout || 2000;
callback = callback || function() {};
// 函数的剩余部分
}
```

逻辑或运算符（   || ）在左侧的值为假的情况下总会返回右侧的操作数;由于函数的具名参数在未被明确提供时会是   undefined ，逻辑或运算符就经常被用来给缺失的参数提供默认值;

此处的   timeout 的有效值实际上有可能是   0 ，但因为   0 是假值，就会导致   timeout 的值在这种情况下会被替换为   2000;

```javascript
function makeRequest(url, timeout, callback) {
timeout = (typeof timeout !== "undefined") ? timeout : 2000; callback = (typeof callback !== "undefined") ? callback : function() {};
// 函数的剩余部分
}
```

### ES6中的参数默认值

使用初始化形式，以便在参数未被正式传递进来时；

```javascript
function makeRequest(url, timeout = 2000, callback = function() {}) {
// 函数的剩余部分
}
```

### 参数默人值如何影响arguments对象

在 ES5 的非严格模式下，   **arguments 对象会反映出具名参数的变化**;在非严格模式下，   a**rguments 对象总是会被更新以反映出具名参数的变化**;

在 ES5 的严格模式下，关于   arguments 对象的这种混乱情况被消除了，**它不再反映出具名参数的变化**;

ES6 参数默认值的函数中，   **arguments 对象的表现总是会与 ES5 的严格模式一致**，无论此时函数是否明确运行在严格模式下。参数默认值的存在触发了   arguments 对象与具名参数的分离

### 参数默认值表达式

默认值并不要求一定是基本类型的值。例如，你可以执行一个函数来产生参数的默认值一个新的标识符绑定，它在初始化之前不允许被访问，否则会抛出错误

### 参数默认值的暂时性死区

函数每个参数都会创建

## 使用不具名参数

### ES5中的不具名参数

JS 提供了arguments 对象用于查看传递给函数的所有参数;

### 剩余参数

剩余参数（ rest parameter ）由三个点（   ... ）与一个紧跟着的具名参数指定，**它会是包含传递给函数的其余参数的一个数组**，名称中的“剩余”也由此而来

#### 剩余参数的限制条件

第一是函数只能有一个剩余参数，并且它必须被放在最后

第二个限制是剩余参数不能在对象字面量的 setter 属性中使用

#### 剩余参数如何影响arguments对象

arguments 对象在函数被调用时反映了传入的参数，与剩余参数能协同工作

## 函数构造器的增强能力

允许使用默认参数以及剩余参数

## 扩展运算符

而扩展运算符则允许将一个数组分割，并**将各个项作为分离的参数传给函数**

## ES6的名称属性

ES6 给所有函数添加了   name 属性选择合适的名称；ES6 中所有函数都有适当的   name 属性值。为了理解其实际运作

## 明确函数的双重用途

JS 为函数提供了两个不同的内部方法：   [[Call]] 与   [[Construct]] 。当函数未使用   new 进行调用时，   [[call]] 方法会被执行，运行的是代码中显示的函数体。

而当函数使用   new 进行调用时，   [[Construct]] 方法则会被执行，**负责创建一个被称为新目标的新的对象**，并且使用该**新目标作为   this 去执行函数体。拥有   [[Construct]] 方法的函数被称为构造器。**



### 在ES5中判断函数如何被使用

最流行的方式是使用**instanceof**

```javascript
function Person(name) {
if (this instanceof Person) {
this.name = name; // 使用 new
} else {
throw new Error("You must use new with Person.")
}
}

```

可惜的是，该方法并不绝对可靠，因为在不使用   new 的情况下   this 仍然可能是   Person 的实例

```javascript
Person.call(person, "Michael"); // 奏效了！
```

### new.target 元属性

当函数的   [[Construct]] 方法被调用时，   new.target 会被填入   new 运算符的作用目标，该目标通常是新创建的对象实例的构造器，并且会成为函数体内部的   this 值。而若   [[Call]] 被执行，   new.target 的值则会是

undefined ;

通过检查   new.target 是否被定义，这个新的元属性就让你能安全地判断函数是否被使用new 进行了调用

## 块级函数

在代码块中声明函数（即块级函数）严格来说应当是一个语法错误;最佳实践就是不要在代码块中声明函数（**更好的选择是使用函数表达式**）

为了控制这种不兼容行为， **ES5 的严格模式为代码块内部的函数声明引入了一个错误**

ES6 会将doSomething() 函数视为块级声明;并允许它在定义所在的代码块内部被访问;块级函数会被提升到定义所在的代码块的顶部

### 决定何时使用块级函数

级函数与   let 函数表达式相似，在执行流跳出定义所在的代码块之后，函数定义就会被移除;

块级函数会被提升到所在代码块的顶部；而使用   let 的函数表达式则不会

### 非严格模式的块级函数

在非严格模式下同样允许使用块级函数，但行为有细微不同。块级函数的作用域会被提升到所在函数或全局环境的顶部，而不是代码块的顶部

## 箭头函数

使用一个“箭头”（   => ）来定义，但它的行为在很多重要方面与传统的 JS 函数不同：没有   this 、   super 、  arguments ，

  没有new.target 绑定：   this 、   super 、arguments 、以及函数内部的   new.target 的值由所在的、最靠近的非箭头函数来决定不能被使用  

 new 调用： 箭头函数没有   [[Construct]] 方法，因不能被用为构造函数，使用   new 调用箭头函数会抛出错误。

没有原型： 既然不能对箭头函数使用   new ，那么它也不需要原型，也就是没有prototype 属性。

不能更改   this ：   this 的值在函数内部不能被修改，在函数的整个生命周期内其值会保持不变。

没有   arguments 对象： 既然箭头函数没有   arguments 绑定，你必须依赖于具名参数或剩余参数来访问函数的参数。

不允许重复的具名参数： 箭头函数不允许拥有重复的具名参数，无论是否在严格模式下

### 箭头函数语法

### 创建立即调用函数表达式

将其包裹在括号内括号既可以连函数定义与参数调用一起包裹，也可以只用于包裹函数定义

使用传统函数时，   (function(){/*函数体*/})(); 与   (function(){/*函数体*/}()); 这两种方式都是可行的

使用箭头函数，则只有下面的写法是有效的：   **(() => {/*函数体*/})();** 

### 没有this 绑定

箭头函数没有   this 绑定，意味着箭头函数内部的   this 值只能通过查找作用域链来确定；

箭头函数没有   this 绑定，意味着箭头函数内部的   this 值只能通过查找作用域链来确定。如果箭头函数被包含在一个非箭头函数内，那么   this 值就会与该函数的相等；

否则，this 值就会是全局对象（在浏览器中是   window ，在 nodejs 中是   global ）；

### 箭头函数与数组

```javascript
var result = values.sort((a, b) => a - b);
```

### 没有arguments绑定

尽管箭头函数没有自己的   arguments 对象，但仍然能访问包含它的函数的   arguments 对象

### 识别箭头函数

尽管语法不同，但箭头函数依然属于函数，并能被照常识别

## 尾调用优化

调用函数的语句是另一个函数的最后语句

```javascript
function doSomething() {
return doSomethingElse(); // 尾调用
}
```

1. 尾调用不能引用当前栈帧中的变量（意味着该函数不能是闭包）；

2. 进行尾调用的函数在尾调用返回结果后不能做额外操作；

3. 尾调用的结果作为当前函数的返回值。

调用优化是你在书写任意递归函数时都需要考虑的因素，因为它能提供显著的性能提升，尤其是被应用到计算复杂度很高的函数时

# 扩展的对象功能

## 对象的类别

普通对象：拥有 JS 对象所有默认的内部行为。

奇异对象：其内部行为在某些方面有别于默认行为。

标准对象：在 ES6 中被定义的对象，例如   Array 、   Date ，等等。标准对象可以是普通的，也可以是奇异的。

内置对象：在脚本开始运行时由 JS 运行环境提供的对象。所有的标准对象都是内置对象

## 对象字面量语法的扩展

### 属性初始化器的速记法

以使用属性初始化器的速记法来消除对象名称与本地变量的重复情况。**当对象的一个属性名称与本地变量名相同时，你可以简单书写名称而省略冒号与值**

### 方法简写

通过省略冒号与   function 关键字

### 需计算属性名

需计算属性名是对象字面量语法的一部分，它用的也是方括号表示法，与此前在对象实例上的用法一致；对象字面量内的方括号表明该属性名需要计算，其结果是一个字符串

使用方括号表示法，任何能放在对象实例方括号内的东西，都可以作为需计算属性名用在对象字面量中。

## 新的方法

### Object.is() 方法

ES6 引入了   Object.is() 方法来弥补严格相等运算符残留的怪异点；

此方法接受两个参数，并会在二者的值相等时返回   true ，此时要求二者类型相同并且值也相等；

### Object.assign()方法

在一次混入中，一个对象会从另一个对象中接收属性与方法；该方法接受一个接收者，以及任意数量的供应者，并会返回接收者；

接受任意数量的供应者，而接收者会按照供应者在参数中的顺序来依次接收它们的属性。这意味着在接收者中，第二个供应者的属性可能会覆盖第一个供应者；

由于   Object.assign() 使用赋值运算符，供应者的访问器属性就会转变成接收者的数据属性；

## 重复的对象字面量属性

ES5 严格模式为重复的对象字面量属性引入了一个检查，若找到重复的属性名，就会抛出错误

ES6 这是赋给该属性的最后一个值。不会出错

## 自有属性的枚举顺序

自有属性枚举时基本顺序如下：

1. 所有的数字类型键，按升序排列。

2. 所有的字符串类型键，按被添加到对象的顺序排列。

3. 所有的符号类型（详见第六章）键，也按添加顺序排列。

注意，数值类型的键会被合并并排序，即使这未遵循在对象字面量中的顺序。字符串类型的键会跟在数值类型的键之后，按照被添加到   obj 对象的顺序，在对象字面量中定义的键会首先出现，接下来是此后动态添加到对象的键。

## 更强大的原型

ES6 通过添加   Object.setPrototypeOf() 方法而改变了这种假定，此方法允许你修改任意指

定对象的原型。它接受两个参数：需要被修改原型的对象，以及将会成为前者原型的对象修改对象的原型

### 使用super引用的简单原型访问

# 解构：更方便的数据访问

ES6 新增了解构（destructuring ），这是将一个数据结构分解为更小的部分的过程

## 解构为何有用？

把数据结构分解为更小的部分时，从中提取你要的数据会变得容易许多。很多语言都能用精简的语法来实现解构，让它更易使用

## 对象解构

对象解构语法在**赋值语句的左侧使用了对象字面量；**

### 解构赋值

在变量声明之后改变它们的值；注意你必须用圆括号包裹解构赋值语句，这是因为暴露的花括号会被解析为代码块语句，而块语句不允许在赋值操作符（即等号）左侧出现。圆括号标示了里面的花括号并不是块语句、而应该被解释为表达式，从而允许完成赋值操作

### 默认值

当你使用解构赋值语句时，如果所指定的本地变量在对象中没有找到同名属性，那么该变量会被赋值为   undefined；若要这么做，需要在属性名后面添加一个等号并指定默认值

### 赋值给不同的本地变量名

```javascript
let { type: localType, name: localName } = node; console.log(localType); // "Identifier"
console.log(localName); // "foo"
```

```javascript
let { type: localType, name: localName = "bar" } = node; console.log(localType); // "Identifier"
console.log(localName); // "bar"
```

### 嵌套的对象解构

每当有一个冒号在解构模式中出现，就意味着冒号之前的标识符代表需要检查的位置，而冒号右侧则是赋值的目标。当冒号右侧存在花括号时，表示目标被嵌套在对象的更深一层中

## 数组解构

解构作用在数组内部的位置上，而不是作用在对象的具名属性上;**是由于它们在数组中的位置，实际的变量名称是任意的（与位置无关）**

### 解构赋值

### 默认值

数组解构赋值同样允许在数组任意位置指定默认值。当指定位置的项不存在、或其值为undefined ，那么该默认值就会被使用

### 嵌套的解构

与解构嵌套的对象相似，可以用类似的方式来解构嵌套的数组

### 剩余项

它使用   ... 语法来**将剩余的项目赋值给一个指定的变量**

## 参数解构

提供了更清楚地标明函数期望输入的替代方案。它使用对象或数组解构的模式替代了具名参数

### 解构的参数是必需的

默认情况下调用函数时未给参数解构传值会抛出错误;可以给解构的参数提供默认值来处理这种行为

```javascript
function setCookie(name, value, options) {
let { secure, path, domain, expires } = options;
// 设置 cookie 的代码
}
```

### 参数解构的默认值

参数解构给每个属性都提供了默认值，所以你可以避免检查指定属性是否已被传入（以便在未传入时使用正确的值）。而整个解构的参数同样有一个默认值，即一个空对象