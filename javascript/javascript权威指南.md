[TOC]

# 词法结构

> 一套基础性规则，用来描述如何使用这门语言来编写程序

## 字符集

###   Unicode转义序列

> 为了支持那些使用老旧技术的程序员，JavaScript定义了一种特殊序列，**使用6个ASCII字符来代表任意16位Unicode内码。这些Unicode转义序列均以\u为前缀，其后跟随4个十六进制数（使用数字以及大写或小写的字母A～F表示）**

字符é的Unicode转义写法为\u00E9，如下两个JavaScript字符串是完全一样的：

```javascript
"café"==="caf\u00e9"//=＞true
```

##  注释

###  “//”

> 在行尾“//”之后的文本都会被JavaScript当做注释忽略掉的

### “/*”和“*/”

> “/*”和“*/”之间的文本也会当做注释，**这种注释可以跨行书写，但不能有嵌套的注释**

## 标识符和保留字

### 标识符

- 标识符用来对变量和函数进行命名，或者用做JavaScript代码中某些循环语句中的跳转位置的标记
- JavaScript标识符必须以**字母、下划线（_）或美元符（$）开始**。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便JavaScript可以轻易区分 开标识符和数字）

## 可选的分号

> **使用分号（;）将语句分隔开**

- 如果语句句各自独占一行，通常可以省略语句之间的分号（程序结尾或右花括号“}”之前的分号也可以省略）
- 只有在缺少了分号就无法正确解析代码的时候，JavaScript才会填补分号
  - 通常来讲，如果一条语句以**“(”、“[”、“/”、“+”或“-”开始**，那么它极有可能和前一条语句合在一起解析。
- 如果当前语句和下一行语句无法合并解析，JavaScript则在第一行后填补分号
  - 有例外
    - 涉及return、break和continue语句的场景中 - 如果这三个关键字后紧跟着换行，JavaScript则会在换行处填补分号
    - 涉及“++”和“——”运算符的时候。如果将其用做后缀表达式，它和表达式应当在同一行。否则，行尾将填补分号，同时“++”或“——”将会作为下一行代码的前缀操作符并与之一起解析

# 类型、值和变量

## 数字

> JavaScript中的所有数字均用浮点数值表示。JavaScript采用IEEE 754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是**±1.7976931348623157×10308，最小值是±5×10-324**

### 整型直接量

> 除了了**十进制的整型直接量**，JavaScript同样能识别**十六进制（以16为基数）值**

**但JavaScript的某些实现可以允许采用八进制（基数为8）形式表示整数**

> 由于某些JavaScript的实现支持八进制直接量，而有些不支持，因此最好不要使用以0为前缀的整型直接量，毕竟我们也无法得知当前JavaScript的实现是否支持八进制的解析。在的严格模式下，八进制直接量是明令禁止的

### JavaScript中的算术运算

#### 溢出（overflow）

- 当数字运算结果超过了JavaScript所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，在JavaScript中以Infinity表示。
- 当负数的值超过了JavaScript所能表示的负数范围，结果为负无穷大，在JavaScript中以-Infinity表示。
- 无穷大值的行为特性和我们所期望的是一致的：基于它们的加、减、乘和除运算结果还是无穷大值（当然还保留它们的正负号）

#### 下溢（underflow）

- 当运算结果无限接近于零并比JavaScript能表示的最小值还小的时候发生的这种情况下，JavaScript将会返回0。
- 当一个负数发生下溢时，JavaScript返回一个特殊的值“负零”。这个**值（负零）几乎和正常的零完全一样**，

#### 特殊

- 被零整除在JavaScript并不报错：它只是简单的返回无穷大（Infinity）或负无穷大（-Infinity）
- **NaN的情况**

  - **零除以零**是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值
  - **无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作**数一起使用时
- **负零值同样有些特殊，它和正零值是相等**的（甚至使用JavaScript的严格相等测试来判断）

### 二进制浮点数和四舍五入错误

> JavaScript采用了IEEE-754浮点数表示法（几乎所有现代编程语言所采用），这是一种二进制表示法，可以精确地表示分数，比如1/2、1/8和1/1024。遗憾的是，我们常用的分数（特别是在金融计算方面）都是十进制分数1/10、1/100等。二进制浮点数表示法并不能精确表示类似0.1这样简单的数字

## 文本

> 字符串（string）是一组由16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集;字符串的长度（length）**是其所含16位值的个数**

### 字符串直接量

> 由单引号定界的字符串中可以包含双引号，由双引号定界的字符串中也可以包含单引号

- 在JavaScript表达式中使用单引号表示字符串
- 在HTML事件处理程序属性中则使用双引号表示字符串

### 转义字符

> 反斜线符号后加一个字符，就不再表示它们的字面含义

### 字符串的使用

- 号(+)运算符用字符串；则表示字符串连接
- 要确定一个字符串的长度- 使用字符串的**length属性**
- **在JavaScript中字符串是固定不变的**，类似**replace()和toUpperCase()的方法都返回新字符串**，原字符串本身并没有发生改变

## 布尔值

> 指代真或假、开或关、是或否。这个类型只有两个值，保留字true和false

- 布尔值通常用于JavaScript中的控制结构中（if/else语句）
- 所有其他值，包括所有对象（数组）都会转换成true
  - 假值
    - **Undefined、null、0、0、NaN、""**
  - 真值
    - **除了假植以外**
- toString()方法，因此可以使用这个方法将字符串转换为**"true"或"false"**，但它并不包含其他有用的方法

## null和undefined

### null

> 它表示一个**特殊值，常用来描述“空值”**。对null执行typeof预算，结果返回字符串"object"，也就是说，可以将null认为是一个特殊的对象值，含义是“非对象”。 

### undefined

> 用未定义的值表示更深层次的“空值”;它是变量的一种取值，表明变量没有初始化

- 要**查询对象属性或数组元素的值**时返回undefined则说明这个属性或元素不存在
- **如果函数没有返回任何值**，则返回undefined
- 用**没有提供实参的函数形参的值**也只会得到undefined

### 注意

> 尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换

- 判断**相等运算符“==”认为两者是相等的（要使用严格相等运算符“===”来区分它们）**

## 包装对象

> JavaScript对象是一种复合值：它是**属性或已命名值的集合**。通过“.”符号来引用属性值。当属性值是一个函数的时候，称其为方法

- **存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象**，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象

## 不可变的原始值和可变的对象引用

### 原始值

> undefined、null、布尔值、数字和字符串

- 任何**方法都无法更改（或“突变”）一个原始值**
- 字符串看起来像由字符组成的数组;字符串中所有的方法看上去返回了一个**修改后的字符串**，实际上返回的是一个**新的字符串值**
- 原始值的比较是值的比较：
  - 只有在它们的**值相等时它们才相等**

### 对象

- 它们是可变的——它们的值是**可修改**
- 对象的**比较并非值**的比较
  - 即使**两个对象包含同样的属性及相同的值**，它们也是不相等的。
  - 各个索引元素完全相等的两个数组也不相等
  - **当且仅当它们引用同一个基对象时，它们才相等**

## 类型转换

![image](https://github.com/NoahsDante/webNotes/blob/master/javascript/img/1.png)

### 转换和相等

> **一个值转换为另一个值并不意味着两个值相等**

### 显式类型转换

- 最简单的方法就是使用Boolean()、Number()、String()或Object()函数
  - 当不通过new运算符调用这些函数时，它们会作为类型转换函数并按照上表所描述的规则做类型转换
  - 除了null或undefined之外的任何值都具有toString()方法

### 对象转换为原始值

#### 对象到布尔值

> 所有的对象（包括数组和函数）都转换为true

#### 对象到字符串和对象到数字

> 通过调用待转换对象的一个方法来完成

##### **toString()**:

> 返回一个反映这个对象的字符串

- 数组类（Array class）的toString()方法将每个数组元素转换为一个字符串,并在元素之间添加逗号后合并成结果字符串
- 函数类（Function class）的toString()方法返回这个函数的实现定义的表示方式
- 日期类（Date class）定义的toString()方法返回了一个可读的（可被JavaScript解析的[[9\]](#filepos207999)）日期和时间字符串
- RegExp类（RegExp class）定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串

```javascript
[1,2,3].toString()//=＞"1,2,3"
(function(x){f(x);}).toString()//=＞"function(x){\n f(x);\n}"
/\d+/g.toString()
//=＞"/\\d+/g"
new Date(2010,0,1).toString()//=＞"Fri Jan 01 2010 00:00:00 GMT-0800(PST)"
```

##### JavaScript中对象到字符串的转换

1. 如果对象具有toString()方法，则调用这个方法如果它返回一个原始值，JavaScript将这个值转换为字符串(如果本身不是字符串的话)，并返回这个字符串结果
2. 如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么JavaScript会调用valueOf()方法。
   1. 如果存在这个方法，则JavaScript调用它。
   2. 如果返回值是原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果
3. JavaScript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常

##### valueOf()

> 如果存在任意原始值，它就**默认将对象转换为表示它的原始值**。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此**默认的valueOf()方法简单地返回对象本身**，而不是返回一个原始值

##### JavaScript中对象到数字的转换

1. 只是它会首先尝试使用valueOf()方法;后者返回一个原始值，则JavaScript将这个原始值转换为数字（如果需要的话）并返回这个数字
2. 如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回
3. JavaScript抛出一个类型错误异常

## 变量声明

使用一个变量之前应当先声明。**变量是使用关键字var来声明的，可以通过一个var关键字来声明多个变量**；还可以将变量的**初始赋值和变量合写在一起。如果未在var声明语句中给变量指定初始值**，那么虽然**声明了这个变量**，但在给它存入一个值之前，它的**初始值就是undefined。**

### 重复声明和遗漏声明

- 试图读取一个没有声明的变量的值，会报错（在严格模式下也一样）
- 在非严格模式下，如果给一个未声明的变量赋值，JavaScript实际上会给全局对象创建一个同名属性，并且它工作起来像，一个正确声明的全局变量

## 变量作用域

全局变量拥有全局作用域，在JavaScript代码中的任何地方都是有定义的。

函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，只在函数体内有定义。

在函数体内，局部变量的优先级高于同名的全局变量。

### 函数作用域和声明提前

JavaScript中没有块级作用域。JavaScript取代地使用了函数作用域：变量子啊声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。这意味着变量在声明之前甚至已经可用。JavaScript的这个特性被非正式地称为声明提前。即**函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部**

```javascript
var scope="global";
function f(){
console.log(scope);//输出"undefined"，而不是"global"
var scope="local";//变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的
console.log(scope);//输出"local"
}
```

### 作为属性的变量

当声明一个JavaScript全局变量时，实际上时定义全局对象的一个属性。当使用var声明一个变量时，创建这个属性时不可配置的(不可被删除的)。如果没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们：

```javascript
var truevar=1;//声明一个不可删除的全局变量
fakevar=2;//创建全局对象的一个可删除的属性
this.fakevar2=3;//同上
delete truevar//=＞false:变量并没有被删除
delete fakevar//=＞true:变量被删除
delete this.fakevar2//=＞true:变量被删除
```

### 作用域链















