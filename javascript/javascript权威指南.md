
# 词法结构

> 一套基础性规则，用来描述如何使用这门语言来编写程序

## 字符集

###   Unicode转义序列

> 为了支持那些使用老旧技术的程序员，JavaScript定义了一种特殊序列，**使用6个ASCII字符来代表任意16位Unicode内码。这些Unicode转义序列均以\u为前缀，其后跟随4个十六进制数（使用数字以及大写或小写的字母A～F表示）**

字符é的Unicode转义写法为\u00E9，如下两个JavaScript字符串是完全一样的：

```javascript
"café"==="caf\u00e9"//=＞true
```

##  注释

###  “//”

> 在行尾“//”之后的文本都会被JavaScript当做注释忽略掉的

### “/*”和“*/”

> “/*”和“*/”之间的文本也会当做注释，**这种注释可以跨行书写，但不能有嵌套的注释**

## 标识符和保留字

### 标识符

- 标识符用来对变量和函数进行命名，或者用做JavaScript代码中某些循环语句中的跳转位置的标记
- JavaScript标识符必须以**字母、下划线（_）或美元符（$）开始**。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便JavaScript可以轻易区分 开标识符和数字）

## 可选的分号

> **使用分号（;）将语句分隔开**

- 如果语句句各自独占一行，通常可以省略语句之间的分号（程序结尾或右花括号“}”之前的分号也可以省略）
- 只有在缺少了分号就无法正确解析代码的时候，JavaScript才会填补分号
  - 通常来讲，如果一条语句以**“(”、“[”、“/”、“+”或“-”开始**，那么它极有可能和前一条语句合在一起解析。
- 如果当前语句和下一行语句无法合并解析，JavaScript则在第一行后填补分号
  - 有例外
    - 涉及return、break和continue语句的场景中 - 如果这三个关键字后紧跟着换行，JavaScript则会在换行处填补分号
    - 涉及“++”和“——”运算符的时候。如果将其用做后缀表达式，它和表达式应当在同一行。否则，行尾将填补分号，同时“++”或“——”将会作为下一行代码的前缀操作符并与之一起解析

# 类型、值和变量

## 数字

> JavaScript中的所有数字均用浮点数值表示。JavaScript采用IEEE 754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是**±1.7976931348623157×10308，最小值是±5×10-324**

### 整型直接量

> 除了了**十进制的整型直接量**，JavaScript同样能识别**十六进制（以16为基数）值**

**但JavaScript的某些实现可以允许采用八进制（基数为8）形式表示整数**

> 由于某些JavaScript的实现支持八进制直接量，而有些不支持，因此最好不要使用以0为前缀的整型直接量，毕竟我们也无法得知当前JavaScript的实现是否支持八进制的解析。在的严格模式下，八进制直接量是明令禁止的

### JavaScript中的算术运算

#### 溢出（overflow）

- 当数字运算结果超过了JavaScript所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，在JavaScript中以Infinity表示。
- 当负数的值超过了JavaScript所能表示的负数范围，结果为负无穷大，在JavaScript中以-Infinity表示。
- 无穷大值的行为特性和我们所期望的是一致的：基于它们的加、减、乘和除运算结果还是无穷大值（当然还保留它们的正负号）

#### 下溢（underflow）

- 当运算结果无限接近于零并比JavaScript能表示的最小值还小的时候发生的这种情况下，JavaScript将会返回0。
- 当一个负数发生下溢时，JavaScript返回一个特殊的值“负零”。这个**值（负零）几乎和正常的零完全一样**，

#### 特殊

- 被零整除在JavaScript并不报错：它只是简单的返回无穷大（Infinity）或负无穷大（-Infinity）
- **NaN的情况**

  - **零除以零**是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值
  - **无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作**数一起使用时
- **负零值同样有些特殊，它和正零值是相等**的（甚至使用JavaScript的严格相等测试来判断）

### 二进制浮点数和四舍五入错误

> JavaScript采用了IEEE-754浮点数表示法（几乎所有现代编程语言所采用），这是一种二进制表示法，可以精确地表示分数，比如1/2、1/8和1/1024。遗憾的是，我们常用的分数（特别是在金融计算方面）都是十进制分数1/10、1/100等。二进制浮点数表示法并不能精确表示类似0.1这样简单的数字

## 文本

> 字符串（string）是一组由16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集;字符串的长度（length）**是其所含16位值的个数**

### 字符串直接量

> 由单引号定界的字符串中可以包含双引号，由双引号定界的字符串中也可以包含单引号

- 在JavaScript表达式中使用单引号表示字符串
- 在HTML事件处理程序属性中则使用双引号表示字符串

### 转义字符

> 反斜线符号后加一个字符，就不再表示它们的字面含义

### 字符串的使用

- 号(+)运算符用字符串；则表示字符串连接
- 要确定一个字符串的长度- 使用字符串的**length属性**
- **在JavaScript中字符串是固定不变的**，类似**replace()和toUpperCase()的方法都返回新字符串**，原字符串本身并没有发生改变

## 布尔值

> 指代真或假、开或关、是或否。这个类型只有两个值，保留字true和false

- 布尔值通常用于JavaScript中的控制结构中（if/else语句）
- 所有其他值，包括所有对象（数组）都会转换成true
  - 假值
    - **Undefined、null、0、0、NaN、""**
  - 真值
    - **除了假植以外**
- toString()方法，因此可以使用这个方法将字符串转换为**"true"或"false"**，但它并不包含其他有用的方法

## null和undefined

### null

> 它表示一个**特殊值，常用来描述“空值”**。对null执行typeof预算，结果返回字符串"object"，也就是说，可以将null认为是一个特殊的对象值，含义是“非对象”。 

### undefined

> 用未定义的值表示更深层次的“空值”;它是变量的一种取值，表明变量没有初始化

- 要**查询对象属性或数组元素的值**时返回undefined则说明这个属性或元素不存在
- **如果函数没有返回任何值**，则返回undefined
- 用**没有提供实参的函数形参的值**也只会得到undefined

### 注意

> 尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换

- 判断**相等运算符“==”认为两者是相等的（要使用严格相等运算符“===”来区分它们）**

## 包装对象

> JavaScript对象是一种复合值：它是**属性或已命名值的集合**。通过“.”符号来引用属性值。当属性值是一个函数的时候，称其为方法

- **存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象**，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象

## 不可变的原始值和可变的对象引用

### 原始值

> undefined、null、布尔值、数字和字符串

- 任何**方法都无法更改（或“突变”）一个原始值**
- 字符串看起来像由字符组成的数组;字符串中所有的方法看上去返回了一个**修改后的字符串**，实际上返回的是一个**新的字符串值**
- 原始值的比较是值的比较：
  - 只有在它们的**值相等时它们才相等**

### 对象

- 它们是可变的——它们的值是**可修改**
- 对象的**比较并非值**的比较
  - 即使**两个对象包含同样的属性及相同的值**，它们也是不相等的。
  - 各个索引元素完全相等的两个数组也不相等
  - **当且仅当它们引用同一个基对象时，它们才相等**

## 类型转换

![image](https://github.com/NoahsDante/webNotes/blob/master/javascript/img/1.png)

### 转换和相等

> **一个值转换为另一个值并不意味着两个值相等**

### 显式类型转换

- 最简单的方法就是使用Boolean()、Number()、String()或Object()函数
  - 当不通过new运算符调用这些函数时，它们会作为类型转换函数并按照上表所描述的规则做类型转换
  - 除了null或undefined之外的任何值都具有toString()方法

### 对象转换为原始值

#### 对象到布尔值

> 所有的对象（包括数组和函数）都转换为true

#### 对象到字符串和对象到数字

> 通过调用待转换对象的一个方法来完成

##### **toString()**:

> 返回一个反映这个对象的字符串

- 数组类（Array class）的toString()方法将每个数组元素转换为一个字符串,并在元素之间添加逗号后合并成结果字符串
- 函数类（Function class）的toString()方法返回这个函数的实现定义的表示方式
- 日期类（Date class）定义的toString()方法返回了一个可读的（可被JavaScript解析的[[9\]](#filepos207999)）日期和时间字符串
- RegExp类（RegExp class）定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串

```javascript
[1,2,3].toString()//=＞"1,2,3"
(function(x){f(x);}).toString()//=＞"function(x){\n f(x);\n}"
/\d+/g.toString()
//=＞"/\\d+/g"
new Date(2010,0,1).toString()//=＞"Fri Jan 01 2010 00:00:00 GMT-0800(PST)"
```

##### JavaScript中对象到字符串的转换

1. 如果对象具有toString()方法，则调用这个方法如果它返回一个原始值，JavaScript将这个值转换为字符串(如果本身不是字符串的话)，并返回这个字符串结果
2. 如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么JavaScript会调用valueOf()方法。
   1. 如果存在这个方法，则JavaScript调用它。
   2. 如果返回值是原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果
3. JavaScript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常

##### valueOf()

> 如果存在任意原始值，它就**默认将对象转换为表示它的原始值**。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此**默认的valueOf()方法简单地返回对象本身**，而不是返回一个原始值

##### JavaScript中对象到数字的转换

1. 只是它会首先尝试使用valueOf()方法;后者返回一个原始值，则JavaScript将这个原始值转换为数字（如果需要的话）并返回这个数字
2. 如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回
3. JavaScript抛出一个类型错误异常

## 变量声明

使用一个变量之前应当先声明。**变量是使用关键字var来声明的，可以通过一个var关键字来声明多个变量**；还可以将变量的**初始赋值和变量合写在一起。如果未在var声明语句中给变量指定初始值**，那么虽然**声明了这个变量**，但在给它存入一个值之前，它的**初始值就是undefined。**

### 重复声明和遗漏声明

- 试图读取一个没有声明的变量的值，会报错（在严格模式下也一样）
- 在非严格模式下，如果给一个未声明的变量赋值，JavaScript实际上会给全局对象创建一个同名属性，并且它工作起来像，一个正确声明的全局变量

## 变量作用域

全局变量拥有全局作用域，在JavaScript代码中的任何地方都是有定义的。

函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，只在函数体内有定义。

在函数体内，局部变量的优先级高于同名的全局变量。

### 函数作用域和声明提前

JavaScript中没有块级作用域。JavaScript取代地使用了函数作用域：变量子啊声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。这意味着变量在声明之前甚至已经可用。JavaScript的这个特性被非正式地称为声明提前。即**函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部**

```javascript
var scope="global";
function f(){
console.log(scope);//输出"undefined"，而不是"global"
var scope="local";//变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的
console.log(scope);//输出"local"
}
```

### 作为属性的变量

当声明一个JavaScript全局变量时，实际上时定义全局对象的一个属性。当使用var声明一个变量时，创建这个属性时不可配置的(不可被删除的)。如果没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们：

```javascript
var truevar=1;//声明一个不可删除的全局变量
fakevar=2;//创建全局对象的一个可删除的属性
this.fakevar2=3;//同上
delete truevar//=＞false:变量并没有被删除
delete fakevar//=＞true:变量被删除
delete this.fakevar2//=＞true:变量被删除
```

### 作用域链

如果将一个布局变量看做是自定义实现的对象的属性的话。没段JavaScript代码（全局代码或函数）都有一个与之关联的作用域链这个作用域链是一个对象列表或者链表，这组对象定义这段代码“作用域中的变量”。当需要查找变量X的值的时候（这个过程称做“变量解析”），它会从链中的第一个对象开始了查找，如果这个对象有一个名为X的属性，会直接使用这个属性值，如果第一个对象中不存在名为X的属性，则会继续查找链上的下一个对象，如果还没有，那么就会继续查找下一个对象，以此类推，如果作用域上没有任何一个对象含有属性X，那么就认为这段代码的作用域链上不存在X，并最终抛出一个引用错误异常。

# 表达式和运算符

表达式式JavaScript中的一个短语，JavaScript解释器会将其计算出一个结果。

将简单表达式组合成**复杂表达式最常用的方法就是使用运算符。**

## 原始表达式

原始表达式式表达式的最小单位-它们不再包含其他表达式。包含**常量、直接量、关键字和变量。**

```javascript
1.23//数字直接量
"hello"//字符串直接量
/pattern///正则表达式直接量
true//返回一个布尔值：真
false//返回一个布尔值：假
null//返回一个值：空
this//返回"当前"对象
i//返回变量i的值
sum//返回sum的值
undefined//undefined是全局变量，和null不同，它不是一个关键字
```

## 对象和数组的初始化表达式

实际上是一个新创建的对象和数组。有时称做“对象直接量”和“数组直接量”。然而和布尔直接量不同，它们不是原始表达式，因为它们所包含的成员或者元素都是子表达式。

数组直接量中的列表都好之间的元素可以省略，这是省略的空位会填充undefined。

数组直接量的元素列表结尾处可以留下单个逗号，但这时并不会创建一个新的值为undefined。

对象同数组非常类似。

## 函数定义表达式

是定义一个JavaScript函数。表达式的值是这个新定义的函数。函数定义表达式同样可以包含函数的名字。函数也可以通过函数语句来定义，而不是函数表达式。

```javascript
//这个函数返回传入参数值的平方
var square=function(x){return x*x;}
```

## 属性访问表达式

运算得到一个对象属性或一个数组元素的值。

JavaScript属性访问定义两种语法：

```javascript
expression.identifer
expression[expression]
```

第一种写法是表达式指定对象，标识符则指定需要访问属性的名称。

第二种使用方括号，方括号内是另外一个表达式（适用于对象和数组）。表达式指定要防伪的属性的名称或者代表访问数组元素的索引。

不管使用哪种形式的属性访问表达式，在“.”和“[”之前的表达式总是会首先计算。

- 如果计算结果是null和undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任意属性。
- 如果运算结果不是对象（或者数组），JavaScript会将其转换为对象，
- 如果对象表达式后跟随句点和标识符，则会查找由这个标识符所指定的属性的值，并将其作为整个表达式的值返回
- 如果对象表达式后跟随一对方括号，则会计算方括号内的表达式的值并将它转换为字符串

.identifier的写法只适用于要访问的属性名称是合法的标识符，并且需要知道要访问的属性名字。

使用方括号写法

- 如果属性名称是一个**保留字或者包含空、标点符号或者是一个数字**
- 当属性名是通过**计算得出的值而不是固定的值时候**

## 调用表达式

是一种调用（或者执行）函数或方法的语法表示。

当对调用表达式进行求值的时候，

1. 首先计算函数表达式，然后计算参数表达式，得到一组参数值。如果函数表达式的值不是一个可调用对象，则抛出一个类型错误异常。
2. 实参的值被依次赋值给形参，这些形参是定义函数时指定的
3. 接下来开始执行函数体
4. 如果函数使用return语句给出一个返回值，那么这个返回值就是整个调用表达式的值；否则调用表达式的值就是undefined

如果这个表达式是一个属性访问表达式，这个调用称做"方法调用"。在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this的指向。

并不是方法调用的调用表达式通常使用全局呀对象作为this关键字的值。通过严格模式定义的函数在调用时将使用undefined作为this的值，this不会指向全局对象。

## 对象创建表达式

创建一个对象并调用一个函数（这个函数称做构造函数）初始化新对象的属性。

当计算一个对象创建表达式的值是，和对象初始化表达式通过{}创建对象一样，

1. JavaScript首先创建一个新的空对象，
2. JavaScript通过传入指定的参数并将这个新对象当做this的值来调用一个指定的函数，这个函数可以使用thsi来初始化这个新创建对象的属性。那些被当成构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果构造函数确实返回了一个对象值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了。

# 运算符概述

运算符用于算术表达、比较表达式、逻辑表达式、赋值表达式

![image](https://github.com/NoahsDante/webNotes/blob/master/javascript/img/2.png)

按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级。

被水平分割线分隔开来的运算符具有不同的优先级。

标题为A的列表示运算符的结合性，L（从左至右）或R（从右至左），

标题为N的列表示操作数的个数。

标题为“类型”的列表示期望的操作数类型，以及运算符的结果类型（在“→”符号之后）

## 操作数个数

### 一元运算符

将一个表达式转换为另外一个稍复杂的表达式：-x中的“-x”运算符就是

### 二元运算符

将来将两个表达式合成一个稍复杂的表达式：“*”乘法运算法

### 三元运算符

条件判断运算符“?:”，它将三个表达式合并成一个表达式条件判断运算符“?:”，它将三个表达式合并成一个表达式

### 操作数类型和结果类型

一些运算符可以作用于任何数据类型，但是仍然希望它们的操作数是指定类型的数据，并且大多数运算符返回（或计算出一个特定类型的值）

### 左值

表达式只能出现在赋值运算符的左侧。在JavaScript中变量、对象属性和数组元素均是左值。

### 运算符的副作用

一些前后的表达式运算会相互影响。赋值运算符是最明显的一个例子：如果给一个变量或属性赋值，那么那些使用这个变量或属性的表达式的值都会改变。“++”和“—”递增和递减运算符与此类似，因为它们包含隐式的赋值。delete运算符同样有副作用：删除一个属性就像给这个属性赋值undefined。

### 运算符优先级

运算符优先级控制着运算符的执行顺序。**优先级高的运算符的执行总是先于优先级低的运算符。**

**运算符的优先级可以通过显式使用圆括号来重写。**

**属性访问表达式和调用表达式的优先级是最高的。**

### 运算符的结合性

指定了在**多个具有同样优先级的运算符表达式中的运算顺序。**

### 运算顺序

运算符的优先级和结合性规定了它们在复杂的表达式中的运算顺序，

但没有规定**子表达式的计算过程的运算顺序。**

例如，在表达式w=x+y*z中，将首先计算子表达式w，然后计算x、y和z，然后，y的值和z的值相乘，再加上x的值，最后将其赋值给表达式w所指代的变量或属性。给表达式添加圆括号将会改变乘法、加法和赋值运算的关系，但从左至右的顺序是不会改变的

## 算术表达式

### ”+“运算符

二元加法运算符“+”可以对两个数字做加法，也可以做字符串连接操作：

加号的转换规则**优先考虑字符串连接**，如果其中一个操作数是字符串或者转换为字符串的对象，另外一个操作数将会转换为字符串，加法将进行字符串连接操作。如果两个操作数多都不是类字符串，都将进行算术加法运算。

- 如果其中一个操作数是对象，则对象遵循对象到原始值的转换规则转换为原始类值：日期对象通过toString()方法执行转换，其他对象则通过valueOf方法执行转换。由于多数对象都不具备可用的valueOf方法，因此它们通过toString()方法来执行转换。
- 在进行对象到原始值的转换后，如果其中一个操作数是字符串，另一个操作数也会转换为字符串，然后进行字符串连接。
- 否则，两个操作数都将转换为数字（NaN），然后进行加法操作。

```javascript
1+2//=＞3:加法
"1"+"2"//=＞"12":字符串连接
"1"+2//=＞"12":数字转换为字符串后进行字符串连接
1+{}//=＞"1[object Object]":对象转换为字符串后进行字符串连接
true+true//=＞2:布尔值转换为数字后做加法
2+null//=＞2:null转换为0后做加法
2+undefined//=＞NaN:undefined转换为NaN后做加法
```

当加号运算符和字符串和数字一起使用时，需要考**虑加法的结合性对运算顺序的影响。运算结果是依赖于运算符的运算顺序。**

### 一元算术运算符

一元运算符作用于一个独立的操作数，并产生一个新值。在JavaScript中，**一元运算符具有很高的优先级，而且都是右结合。必要时，它们会将操作数转换为数字**。并且“+”和“-”既是一元看运算符，也是二元运算符。

#### 一元加法（+）

把操作数转换为数字（NaN），并返回这个转换后的数字。如果操作数本身就是数字，则直接返回这个数字。

#### 一元减法（-）

它会根据需要把操作数转换为数字，然后改变运算结果的符号。

#### 递增（++）

对操作数进行增量（加一）操作，操作数是一个左值（变量、数组或对象）。运算符将操作数转换为数字，然后给数字加一，并将加一后的数值重新赋值给变量、数组或对象。

递增“++”运算符的返回值依赖于它相对操作数的位置。

当运算符在操作数之前，称为“前增量”运算符，**它对操作数进行增量计算，并返回计算后的值。**

当运算符在操作数之后，称为“后增量”，**它对操作数进行增量计算，但返回未做增量计算。**

但是表达式++x并总和x=x+1完全一样，**“++”运算符从不进行字符串连接操作，它总是会将操作数转换为数字并增1。**如果x是字符串“1”，++x的结果就是数字2，而x+1是字符串“11”。

同样需要注意的是，由于JavaScript会自动进行分号补全，因此不能在后增量运算符和操作数之间插入换行符。如果插入了换行符，JavaScript将会把操作数当做一条单独的语句，并在其之前补上一个分号。

#### 递减（--）

递减“-”运算符的操作数也是一个左值。它把操作数转换为数字，然后减1，并将计算后的值重新赋值给操作数。和“++”运算符一样，递减“--”运算符的返回值依赖于它相对操作数的位置，**当递减运算符在操作数之前，操作数减1并返回减1之后的值。**当递减运算符在操作数之后，操作数减1并返回减1之前的值。当递减运算符在操作符的右侧时，运算符和操作数之间不能有换行符。

## 关系表达式

关系运算符**用于测试两个值之间的关系，根据关系是否存在而返回true或false。**关系表达式总是返回一个布尔值，通常在if、while或者for语句中使用关系表达式，用以控制程序的执行流程。

### 相等和不等运算符

#### "=="

称做“相等”，允许进行类型转换。

- 如果两个操作数的类型相同，则和严格相等的比较规则一样。如果严格相等，那么比较结果为相对。如果它们不严格相等，则比较结果为不相等。
- 如果两个操作数类型不同，“==”相等操作符也可能会认为它们相等。
  1. 如果一个值是null，另一个是undefined，则它们相等
  2. 如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较
  3. 如果其中一个值是true，则将其转换为1再进行比较。如果其中一个值是false，则将其转换为0再进行比较
  4. 如果一个值是对象，另一个值是数字或字符串，则使用将对象转换为原始值，然后再进行比较。对象通过toString()方法或者valueOf()方法转换为原始值。JavaScript语言核心的内置类首先尝试使用valueOf()，再尝试使用toString()，除了日期类，日期类只使用toString()转换。那些不是JavaScript语言核心中的对象则通过各自的实现中定义的方法转换为原始值
  5. 其他不同类型之间的比较均不相等

#### "==="

严格相等运算符“===”首先计算其操作数的值，然后比较这两个值，比较过程没有任何类型转换

- 如果两个值类型不相同，则它们不相等
- 如果两个值都是null或者都是undefined，则它们不相等
- 如果两个值都是布尔值true或都是布尔值false，则它们相等
- 如果其中一个值是NaN，或者两个值都是NaN，则它们不相等。NaN和其他任何值都是不相等的，包括它本身！通过x!==x来判断x是否为NaN，只有在x为NaN的时候，这个表达式的值才为true
- 如果两个值为数字且数值相等，则它们相等。如果一个值为0，另一个值为-0，则它们同样相等
- 如果两个值为字符串，且所含的对应位上的16位数完全相等，则它们相等。如果它们的长度或内容不同，则它们不等。两个字符串可能含义完全一样且所显示出的字符也一样，但具有不同编码的16位值。JavaScript并不对Unicode进行标准化的转换，因此像这样的字符串通过“===”和“==”运算符的比较结果也不相等
- 如果两个引用值指向同一个对象、数组或函数，则它们是相等的。如果指向不同的对象，则它们是不等的，尽管两个对象具有完全一样的属性

### 比较运算法

比较运算符用来检测两个操作数的大小关系；比较操作符的操作数可能是任意类型。然而只有数字和字符串才能真正执行比较操作。

不是数字和字符串的操作数都将进行类型转换：

- 如果操作数为对象，转换规则转换为原始值：如果valueOf()返回一个原始值，那么直接使用这个原始值。否则，使用toString()的转换结果进行比较操作。在对象转换为原始值之后，如果两个操作数都是字符串，那么将依照字母表的顺序对两个字符串进行比较，这里提到的“字母表顺序”是指组成这个字符串的16位Unicode字符的索引顺序
- 在对象转换为原始值之后，如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行数值比较。0和-0是相等的。Infinity比其他任何数字都大（除了Infinity本身），-Infinity比其他任何数字都小（除了它自身）。如果其中一个操作数是（或转换后是）NaN，那么比较操作符总是返回false

JavaScript字符串是一个由16位整数值组成的序列，字符串的比较也只是两个字符串中的字符的数值比较。由Unicode定义的字符编码顺序和任何特定语言或者本地语言字符集中的传统字符编码顺序不尽相同。注意，字符串**比较是区分大小写的，所有的大写的ASCII字母都“小于”小写的ASCII字母**

**比较运算符则更偏爱数字，**只有在两个操作数都是字符串的时候，才会进行字符串的比较：

```javascript
1+2//加法.结果是3
"1"+"2"//字符串连接，结果是"12"
"1"+2//字符串链接，2转换为"2"，结果是"12"
11＜3//数字的比较，结果为false
"11"＜"3"//字符串比较，结果为true
"11"＜3//数字的比较，"11"转换为11，结果为false
```

### in 运算符

它的操作数是一个字符串或可以转换为字符串，它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，表达式返回true。

### instanceof运算符

instanceof运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回true；否则返回false。

## 逻辑表达式

逻辑运算符“＆＆”、“||”和“!”是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式

### 逻辑与（&&）

- 操作数都是布尔值的时候，“＆＆”对两个值执行布尔与（AND）操作，只有在第一个操作数和第二个操作数都是true的时候，它才返回true。如果其中一个操作数是false，它返回false。
- ＆＆”可以对真值和假值进行布尔与（AND）操作。如果两个操作数都是真值，那么返回一个真值；否则，至少一个操作数是假值的话，则返回一个假值
- 运算符首先计算左操作数的值，即首先计算“＆＆”左侧的表达式。**如果计算结果是假值，那么整个表达式的结果一定也是假值，因此“＆＆”这时简单地返回左操作数的值，而并不会对右操作数进行计算；**如果左操作数是真值，那么整个表达式的结果则依赖于右操作数的值。**如果右操作数是真值，那么整个表达式的值一定是真值；**如果右操作数是假值，那么整个表达式的值一定是假值。因此，当左操作数是真值时，“＆＆”运算符将计算右操作数的值并将其返回作为整个表达式的计算结果

### 逻辑或（||）

“||”运算符对两个操作数做布尔或（OR）运算。如果其中一个或者两个操作数是真值，**它返回一个真值。如果两个操作数都是假值，它返回一个假值；**它会首先计算第一个操作数的值，也就是说会首先计算左侧的表达式。如果计算结果为真值，那么返回这个真值。否则，再计算第二个操作数的值，即计算右侧的表达式，并返回这个表达式的计算结果；**这种惯用法通常用在函数体内，用来给参数提供默认值**

### 逻辑非（!）

!”运算符首先将其操作数转换为布尔值，然后再对布尔值求反。也就是说“!”总是返回true或者false，并且，可以通过使用两次逻辑非运算来得到一个值的等价布尔值：!!x

作为一个一元运算符，“!”具有很高的优先级，并且和操作数紧密绑定在一起。

## 赋值表达式

它的左操作数是一个左值：**一个变量或者对象属性（或数组元素）。它的右操作数可以是任意类型的任意值。赋值表达式的值就是右操作数的值。**

赋值操作符的结合性是**从右至左，**也就是说，如果一个表达式中出现了多个赋值运算符，运算顺序是从右到左。

## 表达式计算

JavaScript同样可以解释运行由JavaScript源代码组成的字符串，并产生一个值。JavaScript通过全局函数eval()来完成这个工作

### eval()

eval()只有一个参数。

1. 如果传入的参数不是字符串，它直接返回这个参数。

2. 如果参数是字符串，它会把字符串当成JavaScript代码进行编译（parse），

3. 如果编译失败则抛出一个语法错误（SyntaxError）异常。

4. 如果编译成功，则开始执行这段代码，并返回字符串中的最后一个表达式或语句的值，

5. 如果最后一个表达式或语句没有值，则最终返回undefined。

6. 如果字符串抛出一个异常，这个异常将把该调用传递给eval()。

它使用了调用它的变量作用域环境。也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。

不能通过eval()往函数中任意粘贴代码片段，比如，eval("return;")是没有意义的，因为return只有在函数中才起作用;

eval的字符串执行时的上下文环境和调用函数的上下文环境是一样的

在严格模式下，eval执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新的变量或函数。

严格模式将"eval"列为保留字，这让eval()更像一个运算符。不能用一个别名覆盖eval()函数。并且变量名、函数名、函数参数或者异常捕获的参数都不能取名为"eval"

## 其他运算符

### 条件运算符（?:）

条件运算符是JavaScript中唯一的一个三元运算符（三个操作数），有时直接称做“三元运算符”。通常这个运算符写成“?:”，当然在代码中往往不会这么简写，因为这个运算符拥有三个操作数，第一个操作数在“?”之前，第二个操作数在“?”和“:”之间，第三个操作数在“:”之后

### typeof运算符

typeof是一元运算符，放在其单个操作数的前面，操作数可以是任意类型。**返回值为表示操作数类型的一个字符串；**

当操作数是null的时候，typeof将返回"object"。如果想将null和对象区分开，则必须针对特殊值显式检测

### delete运算符

delete是一元操作符，它用来删除对象属性或者数组元素。就像赋值、递增、递减运算符一样；

除属性或者删除数组元素**不仅仅是设置了一个undefined的值。当删除一个属性时，这个属性将不再存在。读取一个不存在的属性将返回undefined；**

并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，**用户通过var语句声明的变量不能删除。同样，通过function语句定义的函数和函数参数也不能删除。**

在严格模式下：只有操作数是一个属性访问表达式的时候它才会正常工作。

### void运算符

它出现在操作数之前，操作数可以是任意类型。**操作数会照常计算，但忽略计算结果并返回undefined**

这个运算符最常用在客户端的URL——javascript:URL中，在URL中可以写带有副作用的表达式，而void则让浏览器不必显示这个表达式的计算结果

### 逗号运算符

它的操作数可以是任意类型。它首先计算左操作数，然后计算右操作数，最后返回右操作数的值；

逗号运算符最常用的场景是在for循环中

# 语句

**语句就是JavaScript整句或命令，是以分号结束。**语句用来**执行以使某件事发生。**

"使某件事发生"的一个方法是计算带有副作用的表达式。如赋值和函数调用的表达式，可以作为单独的语句的，也称做表达式语句。类似的语句还有声明语句，声明语句用来声明新变量或定义新函数。

JavaScript是一系列可执行语句的集合。

## 表达式语句

赋值语句

递增运算符和递减运算符

delete运算符

函数调用

## 复合语句和空语句

可以将多条语句联合在一起，**形成一条复合语句。只须用花括号将多条语句括起来。**

**语句块的结尾不需要分号，块中的原始语句必须以分号结束；**在语句块中声明的变量并不是语句私有的。

### 空语句

```javascript
;
```

## 声明语句

var和function都是声明语句，它们声明或定义变量或函数。这些语句定义标识符（变量名和函数名）并给其赋值，这些标识符可以在程序中任意地方使用

### var

var语句用来声明一个或者多个变量;变量都可以带有初始化表达式，用于指定它的初始值

1. var语句出现在**函数体内，那么它定义的是一个局部变量，**其作用域就是这个函数
2. 在顶层代码中使用var语句，它声明的是**全局变量，在整个JavaScript程序中都是可见**
3. var声明的变量是**无法通过delete删除**
4. var语句中的**变量没有指定初始化表达式，那么这个变量的值初始为undefined**

### function

关键字function用来定义函数;

函数声明语句通常出现在JavaScript代码的最顶层，也可以嵌套在其他函数体内;

函数定义不能出现在if语句、while循环或其他任何语句中；

函数定义与函数声明的区别：

- 函数声明语句中的函数名是一个变量名，变量指向函数对象函数名称和函数体均提前：脚本中的所有函数和函数中所有嵌套的函数都会在当前上下文中其他代码之前声明
- 函数定义使用var的话，只有变量声明提前了——变量的初始化代码仍然在原来的位置

## 条件语句

通过判断指定表达式的值来**决定执行还是跳过某些语句**；这些语句是代码的“决策点”，有时称为“分支”

### if

f语句是一种基本的控制语句，它让JavaScript程序可以选择执行路径，更准确地说，就是有条件地执行语句

#### 第一种

```javascript
if(expression)
statement
// 使用语句块将多条语句合并成一条
if(!address){
address="";
message="Please specify a mailing address.";
}
```

#### 第二种

javaScript中的**if、else匹配规则是，else总是和就近的if语句匹配**

```javascript
if(expression)
statement1
else
statement2

```

### else if

if/else语句通过判断一个表达式的计算结果来选择执行两条分支中的一条

```javascript
if(n==1){//执行代码块1
}
else if(n==2){//执行代码块2
}
else if(n==3){//执行代码块3
}
else{//之前的条件都为false，则执行这里的代码块4
}
```

### switch

当所有的分支都**依赖于同一个表达式的值时**

```javascript
switch(n){
case 1://如果n===1，从这里开始执行
//执行代码块1
break;//停止执行switch语句
case 2://如果n===2，从这里执行
//执行代码块2
break;//在这里停止执行switch语句
case 3://如果n===3，从这里执行
//执行代码块3
break;//在这里停止执行switch语句
default://如果所有的条件都不匹配
//执行代码块4
break;//在这里停止执行switch语句
}
```

在switch语句中，case只是指明了要执行的代码起点，但并没有指明终点。

如果没有break语句，那么switch语句就会从与expression的值相匹配的case标签处的代码块开始执行，依次执行后续的语句，一直到整个switch代码块的结尾

如果在函数中使用switch语句，可以使用return来代替break，return和break都用于终止switch语句，也会防止一个case语句块执行完后继续执行下一个case语句块。

如果switch表达式与所有case表达式都不匹配，则执行标记为"default:"的语句块；如果没有"default:"标签，则switch的整个语句块都将跳过

## 循环

就是程序路径的一个回路，可以**让一部分代码重复执行**

### while

```javascript
while(expression)
statement
```

JavaScript解释器**将执行循环体内的逻辑，然后再次计算表达式expression的值，这种循环会一直继续下去，直到expression的值为假值为止**;表达式expression是真值时则循环执行statement，注意，使用while(true)则会创建一个死循环

### do/while

do/while循环和while循环非常相似，只不过它是在循环的尾部而不是顶部检测循环表达式，**这就意味着循环体至少会执行一次**

### for

```javascript
for(initialize;test;increment)
statement
```

initialize、test和increment三个表达式之间用分号分隔，它们分别负责**初始化操作、循环条件判断和计数器变量的更新**;

initialize表达式只在循环开始之前执行一次;

每次循环执行之前会执行test表达式，并判断表达式的结果来决定是否执行循环体，如果test计算结果为真值，则执行循环体中的statement

最后，执行increment表达式

for循环中那三个表达式中的**任何一个都可以忽略，但是两个分号必不可少**。如果省略test表达式，那么这将是一个死循环，同样，和while(true)类似，死循环的另外一种写法是for(;;)

用for循环来遍历数组元素是非常简单

### for/in

```javascript
for(variable in object)
statement
```

variable通常是一个变量名，也可以是一个可以产生左值的表达式或者一个通过var语句声明的变量，总之必须是一个适用于赋值表达式左侧的值。

object是一个表达式，这个表达式的计算结果是一个对象。

statement是一个语句或语句块，它构成了循环的主体。

用来更方便地遍历对象属性成员

#### 执行过程

在执行for/in语句的过程中，JavaScript解释器首先计算object表达式

1. 如果表达式为null或者undefined，JavaScirpt解释器将会跳过循环并执行后续的代码
2. 如果否则，expression本身已经是对象了表达式等于一个原始值，这个原始值将会转换为与之对应的包装对象
3. JavaScript会依次枚举对象的属性来执行循环。然而在每次循环之前，JavaScript都会先计算variable表达式的值，并将属性名（一个字符串）赋值给它

只要for/in循环中**variable的值可以当做赋值表达式的左值，它可以是任意表达式**

for/in循环并**不会遍历对象的所有属性，只有“可枚举”（enumerable）的属性才会遍历到;代码中定义的所有属性和方法都是可枚举的;**

如果for/in的循环体**删除了还未枚举的属性，那么这个属性将不会再枚举到;如果循环体定义了对象的新属性，这些属性通常也不会枚举到**

#### 属性枚举的顺序

主流浏览器厂商的JavaScript实现是按照属性定义的**先后顺序来枚举简单对象的属性，先定义的属性先枚举。如果使用对象直接量的形式创建对象，则将按照直接量中属性的出现顺序枚举**

## 跳转

它使得JavaScript的执行可以从一个位置跳转到另一个位置。

break语句是跳转到循环或者其他语句的结束。

continue语句是终止本次循环的执行并开始下一次循环的执行。

return语句让解释器跳出函数体的执行，并提供本次调用的返回值。

throw语句触发或者“抛出”一个异常，它是与try/catch/finally语句一同使用

### 标签语句

标签是由**语句前的标识符和冒号组成：**

```javascript
identifer:statement
mainloop:while(token!=null){//忽略这里的代码...
continue mainloop;//跳转到下一次循环
//忽略这里的代码...
}
```

通过给**语句定义标签，就可以在程序的任何地方通过标签名引用这条语句;**

通过给循环定义一个标签名，**可以在循环体内部使用break和continue来退出循环或者直接跳转到下一个循环的开始。**

这里用做标签的identifier必须是**一个合法的JavaScript标识符，而不能是一个保留字。**

标签的命名空间和可以**使用同一个标识符作为语句标签和作为变量名或函数名。**

语句标签只有在它所起作用的语句（当然也可以在它的子句中）内是有定义的。

一个语句标签不能和它内部的语句标签重名，但在两个代码段不相互嵌套的情况下是可以出现同名的语句标签的。

**带有标签的语句还可以带有标签，也就是说，任何语句可以有很多个标签**

### break语句

作用是**立即退出最内层的循环或switch语句**；不论出于什么原因，只要不想继续执行整个循环，就可以用break来提前退出

### continue语句

转**而执行下一次循环；它只能在循环体内使用**。在其他地方使用将会报语法错误。

### return语句

函数中的return语句既是指定函数调用后的返回值；**return语句只能在函数体内出现。**

如果没有return语句，**则函数调用仅依次执行函数体内的每一条语句直到函数结束，最后返回调用程序。这种情况下，调用表达式的结果是undefined；**

return语句经常作为函数内的最后一条语句出现，**但并不是说要一定放在函数最后，即使在执行return语句的时候还有很多后续代码没有执行到，这时函数也还会返回调用程序。**

### throw语句

当发生了某种异常情况或错误时产生的一个信号。抛出异常，就是用信号通知发生了错误或异常状况。捕获异常是指处理这个信号，即采取必要的手段从异常中恢复

```javascript
throw expression;
//
function factorial(x){//如果输入参数是非法的，则抛出一个异常
if(x＜0)throw new Error("x不能是负数");//否则，计算出一个值，并正常地返回它
for(var f=1;x＞1;f*=x,x--)/*empty*/;
return f;
}
```

expression的值可以是任意类型的。可以抛出一个代表错误码的数字，或者包含可读的错误消息的字符串。当JavaScript解释器抛出异常的时候通常采用Error类型和其子类型，当然也可以使用它们。一个Error对象有一个name属性表示错误类型，一个message属性用来存放传递给构造函数的字符串。

**当抛出异常时，JavaScript解释器会立即停止当前正在执行的逻辑，并跳转至就近的异常处理程序；**异常处理程序是用try/catch/finally语句的catch从句编写；

如果抛出异常的代码块没有一条相关联的catch从句，解释器会检查更高层的闭合代码块，看它是否有相关联的异常处理程序。以此类推，直到找到一个异常处理程序为止。

如果抛出异常的函数没有处理它的try/catch/finally语句，异常将向上传播到调用该函数的代码。这样的话，异常就会沿着JavaScript方法的词法结构和调用栈向上传播。

如果没有找到任何异常处理程序，JavaScript将把异常当成程序错误来处理，并报告给用户。

### try/catch/finally语句

try从句定义了需要处理的异常所在的代码块。

catch从句跟随在try从句之后，当try块内某处发生了异常时，调用catch内的代码逻辑。

finally块，后者中放置清理代码，不管try块中是否产生异常，finally块内的逻辑总是会执行

```javascript
try{//要求用户输入一个数字
var n=Number(prompt("请输入一个正整数",""));//假设输入是合法的，计算这个数的阶乘
var f=factorial(n);//显示结果
alert(n+"!="+f);
}
catch(ex){//如果输入不合法，将执行这里的逻辑
alert(ex);//告诉用户产生了什么错误
}
```

关键字catch后跟随了一对圆括号，圆括号内是一个标识符。这个标识符和函数参数很像。**当捕获一个异常时，把和这个异常相关的值（比如Error对象）赋值给这个参数。和普通的变量不同，这条catch子句中的标识符具有块级作用域，它只在catch语句块内有定义**。

不管try语句块中的代码执行完成了多少，**只要try语句中有一部分代码执行了，finally从句就会执行**。它通常在try从句的代码后用于清理工作；**当由于return、continue或break语句使得解释器跳出try语句块时，解释器在执行新的目标代码之前先执行finally块中的逻辑**

如果在try中产生了异常，而且存在一条与之相关的catch从句来处理这个异常，**解释器会首先执行catch中的逻辑，然后执行finally中的逻辑**。如果不存在处理异常的局部catch从句，**解释器会首先执行finally中的逻辑，然后向上传播这个异常，直到找到能处理这个异常的catch从句**

**如果finally块使用了return、continue、break或者throw语句使程序发生跳转**，或者通过调用了抛出异常的方法改变了程序执行流程，不管这个跳转使程序挂起还是继续执行，**解释器都会将其忽略。**

在没有catch从句的情况下try从句可以和finally从句一起使用

## 其他语句类型

### with语句

一个可以按序检索的对象列表，通过它可以进行变量名解析。with语句用于临时扩展作用域链

```javascript
// 将object添加到作用域链的头部，然后执行statement，最后把作用域链恢复到原始状态
with(object)
statement
// 对象嵌套层次很深的时候通常会使用with语句来简化代码编写；这个对象临时挂载在作用域链上，当JavaScript需要解析诸如address的标识符时，就会自动在这个对象中查找；
// 只有在查找标识符的时候才会用到作用域链，创建新的变量的时候不使用它
with(document.forms[0]){//直接访问表单元素，例如:
name.value="";
address.value="";
email.value="";
}
// 不使用with语句的等价代码可以写成这样
var f=document.forms[0];
f.name.value="";
f.address.value="";
f.email.value="";
```

在严格模式中是禁止使用with语句的，并且在非严格模式里也是不推荐使用with语句的，尽可能避免使用with语句。那些使用with语句的JavaScript代码非常难于优化，并且同没有使用with语句的代码相比，它运行得更慢。

### debugger语句

用来产生一个断点（breakpoint），JavaScript代码的执行会停止在断点的位置，这时可以使用调试器输出变量的值、检查调用栈等

### "use strict"

它不包含任何语言的关键字，指令仅仅是一个包含一个特殊字符串直接量的表达式（可以是使用单引号也可以使用双引号），对于那些没有实现ECMAScript 5的JavaScript解释器来说，它只是一条没有副作用的表达式语句，它什么也没做。

使用"use strict"指令的目的是说明（脚本或函数中）后续的代码将会解析为严格代码（strict code）。

如果顶层（不在任何函数内的）代码使用了"use strict"指令，那么它们就是严格代码。

如果函数体定义所处的代码是严格代码或者函数体使用了"use strict"指令，那么函数体的代码也是严格代码。

如果eval()调用时所处的代码是严格代码或者eval()要执行的字符串中使用了"scrict code"指令，则eval()内的代码是严格代码。

#### 格模式和非严格模式之间的区别

- 在严格模式中禁止使用with语句
- 在严格模式中，所有的变量都要先声明，如果给一个未声明的变量、函数、函数参数、catch从句参数或全局对象的属性赋值，将会抛出一个引用错误异常（在非严格模式中，这种隐式声明的全局变量的方法是给全局对象新添加一个新属性）
- 在严格模式中，调用的函数（不是方法）中的一个this值是undefined。（在非严格模式中，调用的函数中的this值总是全局对象）。可以利用这种特性来判断JavaScript实现是否支持严格模式
- 在严格模式中，当通过call()或apply()来调用函数时，其中的this值就是通过call()或apply()传入的第一个参数（在非严格模式中，null和undefined值被全局对象和转换为对象的非对象值所代替）
- 在严格模式中，给只读属性赋值和给不可扩展的对象创建新成员都将抛出一个类型错误异常（在非严格模式中，这些操作只是简单地操作失败，不会报错）
- 在严格模式中，传入eval()的代码不能在调用程序所在的上下文中声明变量或定义函数，而在非严格模式中是可以这样做
- 在严格模式中，函数里的arguments对象拥有传入函数值的静态副本。在非严格模式中，arguments对象具有“魔术般”的行为，arguments里的数组元素和函数参数都是指向同一个值的引用
- 严格模式中，当delete运算符后跟随非法的标识符（比如变量、函数、函数参数）时，将会抛出一个语法错误异常（在非严格模式中，这种delete表达式什么也没做，并返回false）
- 在严格模式中，试图删除一个不可配置的属性将抛出一个类型错误异常（在非严格模式中，delete表达式操作失败，并返回false）。
- 在严格模式中，在一个对象直接量中定义两个或多个同名属性将产生一个语法错误（在非严格模式中不会报错）。
- 在严格模式中，函数声明中存在两个或多个同名的参数将产生一个语法错误（在非严格模式中不会报错）。
- 在严格模式中是不允许使用八进制整数直接量（以0为前缀，而不是0x为前缀）的（在非严格模式中某些实现是允许八进制整数直接量的）。
- 在严格模式中，标识符eval和arguments当做关键字，它们的值是不能更改的。不能给这些标识符赋值，也不能把它们声明为变量、用做函数名、用做函数参数或用做catch块的标识符。
- 在严格模式中限制了对调用栈的检测能力，在严格模式的函数中，arguments.caller和arguments.callee都会抛出一个类型错误异常。严格模式的函数同样具有caller和arguments属性，当访问这两个属性时将抛出类型错误异常（有一些JavaScript的实现在非严格模式里定义了这些非标准的属性）

# 对象

对象是基本数据类型。是一种复合值：将很多值聚合在一起，可通过名字访问这些值，对象也可看做是属性的无序集合，每个属性都是一个名/值对。

## 创建对像

可以通过对象直接量、关键字new、object.create()

### 对象直接量

```javascript
var empty={};//没有任何属性的对象
var point={x:0,y:0};//两个属性
var point2={x:point.x,y:point.y+1};//更复杂的值
var book={
    "main title":"JavaScript",//属性名字里有空格,必须用字符串表示
'sub-title':"The Definitive Guide",//属性名字里有连字符，必须用字符串表示
"for":"all audiences",//"for"是保留字，因此必须用引号
author:{//这个属性的值是一个对象
firstname:"David",//注意，这里的属性名都没有引号
surname:"Flanagan"
}
};
```

对象直接量是一个表达式，这个表达式的每次运算都创建并初始化一个新的对象。每次计算对象直接量的时候，也会都会计算每个属性值。

### 通过new创建对象

new运算符创建并初始化一个新对象。关键字new后跟随一个函数调用。这里的函数称做构造函数，构造函数初始化一个新创建的对象。

```javascript
var o=new Object();//创建一个空对象，和{}一样
var a=new Array();//创建一个空数组，和[]一样
var d=new Date();//创建一个表示当前时间的Date对象
var r=new RegExp("js");//创建一个可以进行模式匹配的EegExp对象
```

### 原型

通过对象直接量创建对象都具有一个原型对象。并通过JavaScript	Object.prototype获得对原型对象的引用。

通过关键字new和构造函数调用创建对象的原型就是构造函数的prototype属性的值。

### Object.create()

它创建一个新对象，其中第一个参数是这个对象原型，第二个参数，用以对象的属性进一步描述。

它是一个静态函数，不是提供给某个对象调用方法。

```javascript
var o1=Object.create({x:1,y:2});//o1继承了属性x和y
//可以通过传入参数null来创建一个没有原型的新对象，但通过这种方式创建的对象不会继承任何东西，甚至不包括基础方法，比如toString()
var o2=Object.create(null);//o2不继承任何属性和方法
// 如果想创建一个普通的空对象（比如通过{}或new Object()创建的对象），需要传入Object.prototype
var o3=Object.create(Object.prototype);
```

## 属性的查询和设置

以通过点(.)或方括号([])运算符来获取属性的值。运算符左侧应当是一个表达式，它返回一个对象。对于点(.)来说，右侧必须是一个以属性名称命名的简单标识符。对于方括号来说([])，方括号内必须是一个计算结果为字符串的表达式

### 作为关联数组的对象

第一种语法使用点运算符和一个标识符，这和C和Java中访问一个结构体或对象的静态字段非常类似。

第二种语法使用方括号和一个字符串，看起来更像数组，只是这个数组元素是通过字符串索引而不是数字索引

使用数组写法和用字符串表达是非常灵活。它使用字符串值（字符串值是动态的，可以在运行时更改）而不是标识符（标识符是静态的，必须写死在程序中）作为索引对属性进行访问

### 继承

一些属性是从原型对象继承而来的。

假设要查询对象o的属性x，如果o中不存在x，那么将会继续在o的原型对象中查询属性x。如果原型对象中也没有x，但这个原型对象也有原型，那么继续在这个原型对象的原型上执行查询，直到找到x或者查找到一个原型是null的对象为止。可以看到，对象的原型属性构成了一个“链”，通过这个“链”可以实现属性的继承

### 属性访问错误

属性访问并不总是返回或设置一个值。当查询一个不存在的属性并不会报错，如果在对象o自身的属性或继承属性中均未找到属性x，属性访问表达式o.x返回undefined。

## 删除属性

delete运算符可以删除对象的属性。它的操作数应当是一个属性访问表达式；delete只是断开属性和宿主对象的联系，而不会去操作属性中的属性。

delete运算符只能删除自有属性，不能删除继承属性（要删除继承属性必须从定义这个属性的原型对象上删除它，而且这会影响到所有继承自这个原型的对象。

当delete表达式删除成功或没有任何副作用（比如删除不存在的属性）时，它返回true。如果delete后不是一个属性访问表达式，delete同样返回true。

delete不能删除那些可配置性为false的属性（尽管可以删除不可扩展对象的可配置属性）。某些内置对象的属性是不可配置

## 检测属性

JavaScript对象可以看做属性的集合，——判断某个属性是否存在于某个对象中。

可以通过in运算符、hasOwnPreperty()和propertyIsEnumerable()。

**in运算符的左侧是属性名（字符串），右侧是对象。**如果对象的自有属性或继承属性中包含这个属性则返回true;可以区分不存在的属性和存在但值为undefined的属性

对象的**hasOwnProperty()方法用来检测给定的名字是否是对象的自有属性。对于继承属性它将返回false**

**propertyIsEnumerable()是hasOwnProperty()的增强版，只有检测到是自有属性且这个属性的可枚举性（enumerable attribute）为true时它才返回true**

除了使用in运算符之外，另一种更简便的方法是使用**“!==”判断一个属性是否是undefined**

## 枚举属性

```javascript
/*
*把p中的可枚举属性复制到o中，并返回o
*如果o和p中含有同名属性，则覆盖o中的属性
*这个函数并不处理getter和setter以及复制属性
*/
function extend(o,p){
for(prop in p){//遍历p中的所有属性
o[prop]=p[prop];//将属性添加至o中
}
return o;
}/*
*将p中的可枚举属性复制至o中，并返回o
*如果o和p中有同名的属性，o中的属性将不受影响
*这个函数并不处理getter和setter以及复制属性
*/
function merge(o,p){
for(prop in p){//遍历p中的所有属性
if(o.hasOwnProperty[prop])continue;//过滤掉已经在o中存在的属性
o[prop]=p[prop];//将属性添加至o中
}
return o;
}/*
*如果o中的属性在p中没有同名属性，则从o中删除这个属性
*返回o
*/
function restrict(o,p){
for(prop in o){//遍历o中的所有属性
    if(!(prop in p))delete o[prop];//如果在p中不存在，则删除之
}
return o;
}/*
*如果o中的属性在p中存在同名属性，则从o中删除这个属性
*返回o
*/
function subtract(o,p){
for(prop in p){//遍历p中的所有属性
delete o[prop];//从o中删除（删除一个不存在的属性不会报错）
}
return o;
}/*
*返回一个新对象，这个对象同时拥有o的属性和p的属性
*如果o和p中有重名属性，使用p中的属性值
*/
function union(o,p){return extend(extend({},o),p);}/*
*返回一个新对象，这个对象拥有同时在o和p中出现的属性
*很像求o和p的交集，但p中属性的值被忽略
*/
function intersection(o,p){return restrict(extend({},o),p);}/*
*返回一个数组，这个数组包含的是o中可枚举的自有属性的名字
*/
function keys(o){
if(typeof o!=="object")throw TypeError();//参数必须是对象
var result=[];//将要返回的数组
for(var prop in o){//遍历所有可枚举的属性
if(o.hasOwnProperty(prop))//判断是否是自有属性
result.push(prop);//将属性名添加至数组中
}
return result;//返回这个数组
}
```

## 属性getter和setter

**对象是有名字、值和一组特性构成，属性值可以用一个或两个方法替代，getter和setter；由getter和setter定义的属性称做“存取器属性”（accessor property），它不同于“数据属性”（data property），数据属性只有一个简单的值。** 

当程序查询存取器属性的值时，JavaScript调用getter方法（无参数）。这个方法的返回值就是属性存取表达式的值。

当程序设置一个存取器属性的值时，JavaScript调用setter方法，将赋值表达式右侧的值当做参数传入setter。从某种意义上讲，这个方法负责“设置”属性值。可以忽略setter方法的返回值。

存取器属性不具有可写性（writable attribute）。

如果属性同时具有getter和setter方法，那么它是一个读/写属性。

如果它只有getter方法，那么它是一个只读属性。

如果它只有setter方法，那么它是一个只写属性（数据属性中有一些例外），读取只写属性总是返回undefined。

存取器属性是**可以继承的**

## 属性的特性

可以对对象进行配置

- 将它们设置成不可枚举，让它们更像内置方法
- 将它们设置对象定义不能修改或删除属性。

数据属性4个特性分别是它的值（value）、可写性（writable）、可枚举性（enumerable）和可配置性（configurable）

存取器属性的4个特性是读取（get）、写入（set）、可枚举性和可配置性

通过调用Object.getOwnPropertyDescriptor()可以获得某个对象特定属性的属性描述符

要想设置属性的特性，或者想让新建属性具有某种特性，则需要调用Object.definePeoperty()，传入要修改的对象、要创建或修改的属性的名称以及属性描述符对象

```javascript
var o={};//创建一个空对象
//添加一个不可枚举的数据属性x，并赋值为1
Object.defineProperty(o,"x",{value:1,
writable:true,
enumerable:false,
configurable:true});//属性是存在的，但不可枚举
o.x;//=＞1
Object.keys(o)//=＞[]//现在对属性x做修改，让它变为只读
Object.defineProperty(o,"x",{writable:false});//试图更改这个属性的值
o.x=2;//操作失败但不报错，而在严格模式中抛出类型错误异常
o.x//=＞1//属性依然是可配置的，因此可以通过这种方式对它进行修改:
Object.defineProperty(o,"x",{value:2});
o.x//=＞2//现在将x从数据属性修改为存取器属性
Object.defineProperty(o,"x",{get:function(){return 0;}});
o.x//=＞0
```

传入Object.defineProperty()的属性描述符对象不必包含所有4个特性。对于新创建的属性来说，默认的特性值是false或undefined。对于修改的已有属性来说，默认的特性值没有做任何修改。

如果要同时修改或创建多个属性，则需要使用Object.defineProperties()。第一个参数是要修改的对象，第二个参数是一个映射表，它包含要新建或修改的属性的名称，以及它们的属性描述符

```javascript
var p=Object.defineProperties({},{
x:{value:1,writable:true,enumerable:true,configurable:true},
y:{value:1,writable:true,enumerable:true,configurable:true},
r:{
get:function(){return Math.sqrt(this.x*this.x+this.y*this.y)},
enumerable:true,
configurable:true
}
});
```

对于那些不允许创建或修改的属性来说，如果用Object.defineProperty()和Object.defineProperties()对其操作或修改）就会抛出类型错误异常

## 对象的三个属性

每一个对象都有与之相关的原型（prototype）、类（class）和可扩展性（extensible attribute）；

### 原型属性

对象的原型属性是用来继承属性。原型属性是在实例对象创建之初就设置好的。

要想检测一个对象是否是另一个对象的原型（或处于原型链中），请使用isPrototypeOf()方法

### 类属性

对象的类属性（class attribute）是一个字符串，用以表示对象的类型信息；想获得对象的类，可以调用对象的toString()方法

```javascript
Object.prototype.toString.call(o).slice(8,-1)
```

### 可扩展性

表示是否可以给对象添加新属性;所有内置对象和自定义对象都是显式可扩展的，宿主对象的可扩展性是由JavaScript引擎定义。

用来查询和设置对象可扩展性的函数

#### Object.esExtensible()

通过将对象传入**来判断该对象是否是可扩展的。**

#### Object.preventExtensions()

如果想将**对象转换为不可扩展的，**

- 将待**转换的对象作为参数传进去。注意，一旦将对象转换为不可扩展的，就无法再将其转换回可扩展的了。**
- **preventExtensions()只影响到对象本身的可扩展性。**
- 如果给**一个不可扩展的对象的原型添加属性，这个不可扩展的对象同样会继承这些新属性**

#### Object.seal()

能够将对象设置为不可扩展;将对象的所有自有属性都设置为不可配置;不能给这个对象添加新属性，**而且它已有的属性也不能删除或配置，不过它已有的可写属性依然可以设置;**

#### Object.isSealed()

检测对象是否封闭

#### Object.freeze()

更严格地锁定对象——“冻结”（frozen）。**除了将对象设置为不可扩展的和将其属性设置为不可配置的之外，还可以将它自有的所有数据属性设置为只读**（如果对象的存取器属性具有setter方法，存取器属性将不受影响，仍可以通过给属性赋值调用它们）

#### Object.isFrozen()

检测对象是否冻结

## 序列化对象

将对象的状态转换为字符串，也可将字符串还原为对象

### 转换规则

- NaN、Infinity和-Infinity序列化的结果是null
- 日期对象序列化的结果是ISO格式的日期字符串（参照Date.toJSON()函数）
- 函数、RegExp、Error对象和undefined值不能序列化和还原

# 数组

数组是值的有序集合。每个值叫做一个元素，而每个元素在数组中有一个位置，以数字表示，称为索引。数组类型可以任意类型，并且同一个数组中的不同元素可能有不同的类型。数组的索引是基于零的32位数值：第一个元素的索引位0，最大可能的索引为4294967294（2^32-2）。

数组是动态的：根据需要它们会增长或缩减，并且在创建数组是无须声明一个固定大小或者在数组大小变化是无须重新分配空间。

**通常，数组的实现是经过优化的，用数字索引来访问数组元素一般来说比访问常规的对象属性要快很多。**

## 创建数组

使用数组直接量是创建数组最简单的方法，在方括号中将数组元素用逗号隔开即可。

数组直接量的语法允许有可选的结尾的逗号，故[,,]只有两个元素而非三个。

## 数组元素的读和写

使用[]操作符来访问数组中的一个元素。数组的引用位于方括号的左边。**方括号中是一个返回非负整数值的任意表达式**；

数组是对象的特殊形式。使用方括号访问数组元素就像用方括号访问对象的属性一样。**JavaScript将指定的数字索引值转换成字符串——索引值1变成“1”**——然后将其作为属性名来使用。

区分数组的索引和对象的属性名

- 只有在0～232-2之间的整数属性名才是索引

### 注意

可以使用负数或非整数来索引数组。这种情况下，**数值转换为字符串，字符串作为属性名来用**。既然名字不是非负整数，它就只能当做常规的对象属性，而非数组的索引。同样，如果凑巧使用了是非负整数的字符串，它就当做数组索引，而非对象属性

## 稀疏数组

从0开始的不连续索引的数组；数组的length属性值代表数组中元素的个数；数组是稀疏的，length属性值大于元素的个数。

```javascript
a=new Array(5);//数组没有元素，但是a.length是5
a=[];//创建一个空数组，length=0
a[1000]=0;//赋值添加一个元素，但是设置length为1001
// 当在数组直接量中省略值时不会创建稀疏数组。省略的元素在数组中是存在的，其值为undefined
var a1=[,,,];//数组是[undefined,undefined,undefined]
var a2=new Array(3);//该数组根本没有元素
0 in a1//=＞true:a1在索引0处有一个元素
0 in a2//=＞false:a2在索引0处没有元素
```

**足够稀疏的数组通常在实现上比稠密的数组更慢、内存利用率更高，**在这样的**数组中查找元素的时间与常规对象属性的查找时间一样长**

## 数组长度

每个数组有一个length属性，length属性值代表数组中元素的个数。其值比数组中最大的索引大1。

**为了保证一个元素的索引值大于或等于它的长度，数组有两个特殊的行为：**

1. 如果为一个数组元素赋值，它的索引i大于或等于现有数组的长度时，length属性的值将设置为i+1；

2. 设置length属性为一个小于当前长度的非负整数n时，当前数组中那些索引值大于或等于n的元素将从中删除

## 数组元素的添加和删除

为新索引赋值

使用push()方法在数组末尾增加一个或多个元素；与给数组a[a.length]赋值是一样

可以像删除对象属性一样使用delete运算符来删除数组元素

- 删除数组元素与为其赋undefined值是类似；**对一个数组元素使用delete不会修改数组的length属性，**也**不会将元素从高索引处移下来填充已删除属性留下的空白**。如果从数组中删除一个元素，它就变成稀疏数组

## 数组遍历

使用for循环

可以使用for/i n循环：循环每次将一个可枚举的属性名（包括数组索引）赋值给循环变量。不存在的索引将不会遍历到

## 数组方法

### join()

数组中所有元素都转化为字符串并连接在一起，返回最后生成的字符串。可以指定一个可选的字符串在生成的字符串中来分隔数组的各个元素。如果不指定分隔符，默认使用逗号。

### reverse()

将数组中的元素颠倒顺序，返回逆序的数组；它**不通过重新排列的元素创建新的数组，而是在原先的数组中重新排列它们**

### sort()

将数组中的元素排序并返回排序后的数组。当不带参数调用sort()时，数组元素以字母表顺序排序（如有必要将临时转化为字符串进行比较）；**如果数组包含undefined元素，它们会被排到数组的尾部；**

为了按照其他方式而非字母表顺序进行数组排序，必须给sort()方法传递一个比较函数。该函数决定了它的两个参数在排好序的数组中的先后顺序

### concat()

创建并返回一个新数组，**它的元素包括调用concat()的原始数组的元素和concat()的每个参数。**如果这些参数中的任何一个自身是数组，则连接的是数组的元素，而非数组本身。但要注意，concat()不会递归扁平化数组的数组。concat()也不会修改调用的数组。

### slice()

返回指定数组的一个片段或子数组。它的两个参数分别指定了片段的开始和结束的位置。

返回的数组包含第一个参数指定的位置和所有到但不含第二个参数指定的位置之间的所有数组元素。

如果只指定一个参数，返回的数组将包含从开始位置到数组结尾的所有元素。

如参数中出现负数，它表示相对于数组中最后一个元素的位置

```javascript
var a=[1,2,3,4,5];
a.slice(0,3);//返回[1,2,3]
a.slice(3);//返回[4,5]
a.slice(1,-1);//返回[2,3,4]
a.slice(-3,-2);//返回[3]
```

### splice()

在数组中插入或删除元素的通用方法;**splice()会修改调用的数组;**

能够从数组中删除元素、插入元素到数组中或者同时完成这两种操作;

splice()的第一个参数**指定了插入和（或）删除的起始位置。**第二个参数指定了应该**从数组中删除的元素的个数**。如果省略第二个参数，**从起始点开始到数组结尾的所有元素都将被删除。**splice()返回一个由删除元素组成的数组，或者如果没有删除元素就返回一个空数组

```javascript
var a=[1,2,3,4,5,6,7,8];
a.splice(4);//返回[5,6,7,8];a是[1,2,3,4]
a.splice(1,2);//返回[2,3];a是[1,4]
a.splice(1,1);//返回[4];a是[1]

```

splice()的前两个参数指定了需要删除的数组元素。紧随其后的任意个数的参数指定了需要插入到数组中的元素，从第一个参数指定的位置开始插入

```javascript
var a=[1,2,3,4,5];
a.splice(2,0,'a','b');//返回[];a是[1,2,'a','b',3,4,5]
a.splice(2,2,[1,2],3);//返回['a','b'];a是[1,2,[1,2],3,3,4,5]
```

### push()和pop()

ush()方法在数组的尾部添加一个或多个元素，并返回数组新的长度。

pop()方法则相反：它删除数组的最后一个元素，减小数组长度并返回它删除的值。

**两个方法都修改并替换原始数组而非生成一个修改版的新数组**

### unshift()和shift()

unshift()在数组的头部添加一个或多个元素，并将已存在的元素移动到更高索引的位置来获得足够的空间，最后返回数组新的长度

shift()删除数组的第一个元素并将其返回，然后把所有随后的元素下移一个位置来填补数组头部的空缺

当使用多个参数调用unshift()时它的行为令人惊讶。参数是**一次性插入的（就像splice()方法）而非一次一个地插入。**这意味着最终的数组中插入的**元素的顺序和它们在参数列表中的顺序一致。**

### map()

调用的数组的每个元素传递给指定的函数，**并返回一个数组，它包含该函数的返回值。**

**传递给map()的函数应该有返回值。map()返回的是新数组：它不修改调用的数组**

### filter()

返回的数组元素是调用的数组的一个子集。传递的函数是**用来逻辑判定的**：该函数返回true或false。调用判定函数就像调用forEach()和map()一样。**如果返回值为true或能转化为true的值，那么传递给判定函数的元素就是这个子集的成员，它将被添加到一个作为返回值的数组中**。

filter()会**跳过稀疏数组中缺少的元素，它的返回数组总是稠密的。为了压缩稀疏数组的空缺**（甚至，压缩空缺并删除undefined和null元素）

### every()和some()

数组的逻辑判定：它们对数组元素应用指定的函数进行判定，返回true或false;

every当且仅当**针对数组中的所有元素调用判定函数都返回true，它才返回true;**

```javascript
a=[1,2,3,4,5];
a.every(function(x){return x＜10;})//=＞true:所有的值＜10
a.every(function(x){return x%2===0;})//=＞false:不是所有的值都是偶数
```

当数组中**至少有一个元素调用判定函数返回true，它就返回true；**并且当且**仅当数值中的所有元素调用判定函数都返回false，它才返回false**

```javascript
a=[1,2,3,4,5];
a.some(function(x){return x%2===0;})//=＞true：a含有偶数值
a.some(isNaN)//=＞false：a不包含非数值元素
```

一旦every()和some()确认该返回什么值它们就会停止;

遍历数组元素。some()在判定函数第一次返回true后就返回true，但如果判定函数一直返回false，它将会遍历整个数组。

every()判定函数第一次返回false后就返回false，但如果判定函数一直返回true，它将会遍历整个数组。

### reduce()和reduceRight()

#### reduce()

用指定的函数将数组元素进行组合，生成单个值。也可以称为**“注入”和“折叠”**

```javascript
var a=[1,2,3,4,5]
var sum=a.reduce(function(x,y){return x+y},0);//数组求和
var product=a.reduce(function(x,y){return x*y},1);//数组求积
var max=a.reduce(function(x,y){return(x＞y)?x:y;});//求最大值
```

需要两个参数。第一个是执行化简操作的函数。第二个（可选）的参数是一个传递给函数的初始值；

当不指定初始值调用reduce()时，它将使用数组的第一个元素作为其初始值。

#### reduceRight()

它按照数组索引**从高到低（从右到左）处理数组。**

### indexOf()和lastIndexOf()

搜索整个数组中具有给定值的元素，**返回找到的第一个元素的索引或者如果没有找到就返回-1。**indexOf()从**头至尾搜索**，而lastIndexOf()则**反向搜索**

```javascript
a=[0,1,2,1,0];
a.indexOf(1)//=＞1:a[1]是1
a.lastIndexOf(1)//=＞3:a[3]是1
a.indexOf(3)//=＞-1:没有值为3的元素
```

第一个参数是需要搜索的值，

第二个参数是可选的：它指定数组中的一个索引，从那里开始搜索。如果省略该参数，indexOf()从头开始搜索，而lastIndexOf()从末尾开始搜索。

第二个参数也可以是负数，它代表相对数组末尾的偏移量

## 数组类型

```javascript
var isArray=Function.isArray||function(o){
return typeof o==="object"＆＆
Object.prototype.toString.call(o)==="[object Array]";
};
```

## 类数组对象

拥有一个数值length属性和对应非负整数属性的对象看做一种类型的数组;仍然可以用针对真正数组遍历的代码来遍历它们

- 常规对象增加了一些属性使其变成类数组对象，然后遍历生成的伪数组的“元素”
- Arguments对象就是一个类数组对象
- 一些DOM方法（如document.getElementsByTagName()）返回类数组对象

## 作为数组的字符串

符串的行为类似于只读的数组。除了用charAt()方法来访问单个的字符以外，还可以使用方括号

```javascript
var s=test;
s.charAt(0)//=＞"t"
s[1]//=＞"e"
```

针对字符串的typeof操作符仍然返回"string"，但是如果给Array.isArray()传递字符串，它将返回false;可索引的字符串的最大的好处就是简单，用方括号代替了charAt()调用，这样更加简洁、可读并且可能更高效;字符串是不可变值，故当把它们作为数组看待时，它们是只读。

# 函数

它只定义了一次，但可能被执行或调用任意。函数的定义会包括一个称为形参（parameter）的标识符列表，这些参数在函数体中像局部变量一样工作。函数调用会为形参提供实参的值。函数使用它们实参的值来计算返回值，成为该函数调用表达式的值。除了实参之外，每次调用还会拥有另一个值——本次调用的上下文——这就是this关键字的值。

如果函数挂载在一个对象上，作为对象的一个属性，就称它为对象的方法。当通过这个对象来调用函数时，该对象就是此次调用的上下文（context），也就是该函数的this的值。用于初始化一个新创建的对象的函数称为构造函数（constructor）。

函数即对象，程序可以随意操控它们。比如，JavaScript可以把函数赋值给变量，或者作为参数传递给其他函数。因为函数就是对象，所以可以给它们设置属性，甚至调用它们的方法。

函数可以嵌套在其他函数中定义，这样它们就可以访问它们被定义时所处的作用域中的任何变量。

## 函数定义

函数使用function关键字来定义，它可以用在函数定义表达式或者函数声明语句里。

### 注意

以表达式方式定义的函数，函数的名称是可选的。一条函数声明语句实际上声明了一个变量，并把一个函数对象赋值给它。

定义函数表达式时并没有声明一个变量；如果一个函数定义表达式包含名称，函数的局部作用域将会包含一个绑定到函数对象的名称。实际上，函数的名称将成为函数内部的一个局部变量。

**函数声明语句并非真正的语句，ECMAScript规范只是允许它们作为顶级语句。**它们可以出现在全局代码里或者内嵌在其他函数中，**但它们不能出现在循环、条件判断，或者try/cache/finally以及with语句中。**此限制仅适用于以语句声明形式定义的函数。

**函数定义表达式可以出现在JavaScript代码的任何地方。**

### 函数命名

函数名称通常是**动词或以动词为前缀的词组**。通常函数名的第一个字符为小写，这是一种编程约定。当函数名包含多个单词时，一种约定是将单词以下划线分隔，就像like_this()。还有另外一种约定，**就是除了第一个单词之外的单词首字母使用大写字母，就像likeThis()**。有一些函数是用做**内部函数或私有函数（不是作为公用API的一部分），这种函数名通常以一条下划线为前缀**

### 嵌套函数

函数可以嵌套在其他函数里；

它的变量作用域规则：

它们可以访问嵌套它们（或多重嵌套）的函数的参数和变量

## 函数调用

只有调用该函数时，它们才会执行。

### 函数调用

一个调用表达式由多个函数表达式组成，每个函数表达式都是由**一个函数对象和左圆括号、参数列表和右圆括号组成，参数列表是由逗号分隔的零个或多个参数表达式组成**。如果函数表达式是一个属性访问表达式，即该函数是一个对象的属性或数组中的一个元素，那么它就是一个方法调用表达式。

对于普通的函数调用，函数的返回值成为调用表达式的值。**如果该函数返回是因为解释器到达结尾，返回值就是undefined。如果函数返回是因为解释器执行到一条return语句，返回值就是return之后的表达式的值，如果return语句没有值，则返回undefined**

### 方法调用

是个保存在一个对象的属性里的JavaScript函数。

对方法调用的参数和返回值的处理，和上面所描述的普通函数调用完全一致；**调用上下文函数体可以使用关键字this引用该对象**

大多数方法调用使用点符号来访问属性，使用方括号（的属性访问表达式）也可以进行属性访问操作

#### 方法链

当方法的返回值是一个对象，这个对象还可以再调用它的方法

**this是一个关键字，不是变量，也不是属性名。JavaScript的语法不允许给this赋值；**和变量不同，关键字this没有作用域的限制，嵌套的函数不会从调用它的函数中继承this

### 构造函数调用

如果函数或者方法调用之前带有关键字new，它就构成构造函数调用。但如果构造函数没有形参，JavaScript构造函数调用的语法是允许省略实参列表和圆括号。

构造函数调用**创建一个新的空对象**，这个对象继承自构造函数的prototype属性。**构造函数试图初始化这个新创建的对象，并将这个对象用做其调用上下文**，因此构造函数可以**使用this关键字来引用这个新创建的对象**

构造函数通常不使用return关键字，它们通常初始化新对象，当构造函数的函数体执行完毕时，它会显式返回

构造函数调用表达式的**计算结果就是这个新对象的值。**

**如果构造函数显式地使用return语句返回一个对象，那么调用表达式的值就是这个对象**

如果构造函数使用return语句但没有指定返回值，或者返回一个原始值，那么这时将忽略返回值，同时使用这个新对象作为调用结果

### 间接调用

函数也是对象，和其他JavaScript对象没什么两样，**函数对象也可以包含方法。其中的两个方法call()和apply()可以用来间接地调用函数。两个方法都允许显式指定调用所需的this值，也就是说，**任何函数可以作为任何对象的方法来调用，哪怕这个函数不是那个对象的方法。**两个方法都可以指定调用的实参。call()方法使用它自有的实参列表作为函数的**实参，**apply()方法则要求以**数组的形式传入参数**

## 函数的实参和形参

函数定义并未指定函数形参的类型，函数调用未对传入的实参值做任何类型检查

### 可选形参

当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。在调用函数时形参是否可选以及是否可以省略应当保持较好的适应性。为了做到这一点，**应当给省略的参数赋一个合理的默认值。**

### 可变长的实参列表：实参对象

调用函数的时候传入的实参个数超过函数定义时的形参个数时，没有办法直接获得未命名值的引用。参数对象解决了这个问题。在函数体内，标识符arguments是指向实参对象的引用，实参对象是一个类数组对象，这样可以通过数字下标就能访问传入函数的实参值，而不用非要通过名字来得到实参。

arguments并不是真正的数组，它是一个实参对象。**每个实参对象都包含以数字为索引的一组元素以及length属性，但它毕竟不是真正的数组。可以这样理解，它是一个对象，只是碰巧具有以数字为索引的属性**

#### callee和caller属性

实参对象还定义了callee和caller属性。在ECMAScript 5严格模式中，对这两个属性的读写操作都会产生一个类型错误。**而在非严格模式下，ECMAScript标准规范规定callee属性指代当前正在执行的函数。** **caller是非标准的，但大多数浏览器都实现了这个属性，它指代调用当前正在执行的函数的函数**。**通过caller属性可以访问调用栈。**callee属性在某些时候会非常有用，比如在匿名函数中通过callee来递归地调用自身

### 将对象属性用做实参

要记住调用函数中实参的正确顺序实在让人头疼；最好通过名/值对的形式来传入参数，这样参数的顺序就无关紧要了

### 实参类型

JavaScript方法的形参并未声明类型，在形参传入函数体之前也未做任何类型检查。可以采用语义化的单词来给函数实参命名。

JavaScript在必要的时候会进行类型转换。因此如果函数期望接收一个字符串实参，而调用函数时传入其他类型的值，所传入的值会在函数体内将其用做字符串的地方转换为字符串类型。所有的原始类型都可以转换为字符串，所有的对象都包含toString()方法。

当所传不一致时，**应当添加类似的实参类型检查逻辑，因为宁愿程序在传入非法值时报错，也不愿非法值导致程序在执行时报错**

## 作为值的函数

**可以将函数赋值给变量，存储在对象的属性或数组的元素中，作为参数传入另外一个函数**

### 自定义函数属性

JavaScript中的函数并不是原始值，**而是一种特殊的对象**；**函数可以拥有属性。**

当函数需要一个“静态”变量来在调用时保持某个值不变，最方便的方式就是给函数定义属性，而不是定义全局变量，显然定义全局变量会让命名空间变得更加杂乱无章

## 作为命名空间的函数

在函数中声明的变量在整个函数体内都是可见的（包括在嵌套的函数中），在函数的外部是不可见

## 闭包

采用词法作用域（lexical scoping）。函数的执行依赖于变量作用域，这个作用域是在函数定义时决定的，而不是函数调用时决定；由你在写代码时将变量和块作用域写在哪里来决定。

javaScript函数对象的内部状态不仅包含函数的代码逻辑，还必须引用当前的作用域链；函数对象可以通过作用域链相互关联起来，函数体内部的变量都可以保存在函数作用域内

函数数当作值传递，即所谓的first class对象。就是可以把函数当作一个值来赋值，当作参数传给别的函数，也可以把函数当作一个值 return。一个函数被当作值返回时，也就相当于返回了一个通道，这个通道可以访问这个函数词法作用域中的变量，即函数所需要的数据结构保存了下来，数据结构中的值在外层函数执行时创建，外层函数执行完毕时理因销毁，但由于内部函数作为值返回出去，这些值得以保存下来。而且无法直接访问，必须通过返回的函数。这也就是私有性

## 函数属性、方法和构造函数

### length属性

函数的length属性是只读属性；代表函数实参的数量；在函数定义时给出的实参个数，通常也是在函数调用时期望传入函数的实参个数。

### prototype属性

每一个函数都包含一个prototype属性，这个属性是指向一个对象的引用，这个对象称做“原型对象”（prototype object）。每一个函数都包含不同的原型对象。当将函数用做构造函数的时候，新创建的对象会从原型对象上继承属性；

### call()方法和apply()方法

将call()和apply()看做是某个对象的方法，通过调用方法的形式来间接调用函数。

call()和apply()的第一个实参是要调用函数的母对象，它是调用上下文，在函数体内通过this来获得对它的引用。要想以对象o的方法来调用函数f()，可以这样使用call()和apply()

### bind()方法

要作用就是将函数绑定至某个对象

### toString()方法

这个方法返回一个字符串，这个字符串和函数声明语句的语法相关。实际上，大多数（非全部）的toString()方法的实现都返回函数的完整源码

### Function()构造函数

Function()构造函数可以传入任意数量的字符串实参，最后一个实参所表示的文本就是函数体；它可以包含任意的JavaScript语句，每两条语句之间用分号分隔。传入构造函数的其他所有的实参字符串是指定函数的形参名字的字符串。如果定义的函数不包含任何参数，只须给构造函数简单地传入一个字符串——函数体——即可

- Function()构造函数允许JavaScript在运行时动态地创建并编译函数
- 每次调用Function()构造函数都会解析函数体，并创建新的函数对象。如果是在一个循环或者多次调用的函数中执行这个构造函数，执行效率会受影响。相比之下，循环中的嵌套函数和函数定义表达式则不会每次执行时都重新编译
- 它所创建的函数并不是使用词法作用域，相反，函数体代码的编译总是会在顶层函数执行

## 函数式编程

### 高阶函数

操作函数的函数，它接收一个或多个函数作为参数，并返回一个新函数












