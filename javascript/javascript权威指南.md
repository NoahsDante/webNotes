
# 词法结构

> 一套基础性规则，用来描述如何使用这门语言来编写程序

## 字符集

###   Unicode转义序列

> 为了支持那些使用老旧技术的程序员，JavaScript定义了一种特殊序列，**使用6个ASCII字符来代表任意16位Unicode内码。这些Unicode转义序列均以\u为前缀，其后跟随4个十六进制数（使用数字以及大写或小写的字母A～F表示）**

字符é的Unicode转义写法为\u00E9，如下两个JavaScript字符串是完全一样的：

```javascript
"café"==="caf\u00e9"//=＞true
```

##  注释

###  “//”

> 在行尾“//”之后的文本都会被JavaScript当做注释忽略掉的

### “/*”和“*/”

> “/*”和“*/”之间的文本也会当做注释，**这种注释可以跨行书写，但不能有嵌套的注释**

## 标识符和保留字

### 标识符

- 标识符用来对变量和函数进行命名，或者用做JavaScript代码中某些循环语句中的跳转位置的标记
- JavaScript标识符必须以**字母、下划线（_）或美元符（$）开始**。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便JavaScript可以轻易区分 开标识符和数字）

## 可选的分号

> **使用分号（;）将语句分隔开**

- 如果语句句各自独占一行，通常可以省略语句之间的分号（程序结尾或右花括号“}”之前的分号也可以省略）
- 只有在缺少了分号就无法正确解析代码的时候，JavaScript才会填补分号
  - 通常来讲，如果一条语句以**“(”、“[”、“/”、“+”或“-”开始**，那么它极有可能和前一条语句合在一起解析。
- 如果当前语句和下一行语句无法合并解析，JavaScript则在第一行后填补分号
  - 有例外
    - 涉及return、break和continue语句的场景中 - 如果这三个关键字后紧跟着换行，JavaScript则会在换行处填补分号
    - 涉及“++”和“——”运算符的时候。如果将其用做后缀表达式，它和表达式应当在同一行。否则，行尾将填补分号，同时“++”或“——”将会作为下一行代码的前缀操作符并与之一起解析

# 类型、值和变量

## 数字

> JavaScript中的所有数字均用浮点数值表示。JavaScript采用IEEE 754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是**±1.7976931348623157×10308，最小值是±5×10-324**

### 整型直接量

> 除了了**十进制的整型直接量**，JavaScript同样能识别**十六进制（以16为基数）值**

**但JavaScript的某些实现可以允许采用八进制（基数为8）形式表示整数**

> 由于某些JavaScript的实现支持八进制直接量，而有些不支持，因此最好不要使用以0为前缀的整型直接量，毕竟我们也无法得知当前JavaScript的实现是否支持八进制的解析。在的严格模式下，八进制直接量是明令禁止的

### JavaScript中的算术运算

#### 溢出（overflow）

- 当数字运算结果超过了JavaScript所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，在JavaScript中以Infinity表示。
- 当负数的值超过了JavaScript所能表示的负数范围，结果为负无穷大，在JavaScript中以-Infinity表示。
- 无穷大值的行为特性和我们所期望的是一致的：基于它们的加、减、乘和除运算结果还是无穷大值（当然还保留它们的正负号）

#### 下溢（underflow）

- 当运算结果无限接近于零并比JavaScript能表示的最小值还小的时候发生的这种情况下，JavaScript将会返回0。
- 当一个负数发生下溢时，JavaScript返回一个特殊的值“负零”。这个**值（负零）几乎和正常的零完全一样**，

#### 特殊

- 被零整除在JavaScript并不报错：它只是简单的返回无穷大（Infinity）或负无穷大（-Infinity）
- **NaN的情况**

  - **零除以零**是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值
  - **无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作**数一起使用时
- **负零值同样有些特殊，它和正零值是相等**的（甚至使用JavaScript的严格相等测试来判断）

### 二进制浮点数和四舍五入错误

> JavaScript采用了IEEE-754浮点数表示法（几乎所有现代编程语言所采用），这是一种二进制表示法，可以精确地表示分数，比如1/2、1/8和1/1024。遗憾的是，我们常用的分数（特别是在金融计算方面）都是十进制分数1/10、1/100等。二进制浮点数表示法并不能精确表示类似0.1这样简单的数字

## 文本

> 字符串（string）是一组由16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集;字符串的长度（length）**是其所含16位值的个数**

### 字符串直接量

> 由单引号定界的字符串中可以包含双引号，由双引号定界的字符串中也可以包含单引号

- 在JavaScript表达式中使用单引号表示字符串
- 在HTML事件处理程序属性中则使用双引号表示字符串

### 转义字符

> 反斜线符号后加一个字符，就不再表示它们的字面含义

### 字符串的使用

- 号(+)运算符用字符串；则表示字符串连接
- 要确定一个字符串的长度- 使用字符串的**length属性**
- **在JavaScript中字符串是固定不变的**，类似**replace()和toUpperCase()的方法都返回新字符串**，原字符串本身并没有发生改变

## 布尔值

> 指代真或假、开或关、是或否。这个类型只有两个值，保留字true和false

- 布尔值通常用于JavaScript中的控制结构中（if/else语句）
- 所有其他值，包括所有对象（数组）都会转换成true
  - 假值
    - **Undefined、null、0、0、NaN、""**
  - 真值
    - **除了假植以外**
- toString()方法，因此可以使用这个方法将字符串转换为**"true"或"false"**，但它并不包含其他有用的方法

## null和undefined

### null

> 它表示一个**特殊值，常用来描述“空值”**。对null执行typeof预算，结果返回字符串"object"，也就是说，可以将null认为是一个特殊的对象值，含义是“非对象”。 

### undefined

> 用未定义的值表示更深层次的“空值”;它是变量的一种取值，表明变量没有初始化

- 要**查询对象属性或数组元素的值**时返回undefined则说明这个属性或元素不存在
- **如果函数没有返回任何值**，则返回undefined
- 用**没有提供实参的函数形参的值**也只会得到undefined

### 注意

> 尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换

- 判断**相等运算符“==”认为两者是相等的（要使用严格相等运算符“===”来区分它们）**

## 包装对象

> JavaScript对象是一种复合值：它是**属性或已命名值的集合**。通过“.”符号来引用属性值。当属性值是一个函数的时候，称其为方法

- **存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象**，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象

## 不可变的原始值和可变的对象引用

### 原始值

> undefined、null、布尔值、数字和字符串

- 任何**方法都无法更改（或“突变”）一个原始值**
- 字符串看起来像由字符组成的数组;字符串中所有的方法看上去返回了一个**修改后的字符串**，实际上返回的是一个**新的字符串值**
- 原始值的比较是值的比较：
  - 只有在它们的**值相等时它们才相等**

### 对象

- 它们是可变的——它们的值是**可修改**
- 对象的**比较并非值**的比较
  - 即使**两个对象包含同样的属性及相同的值**，它们也是不相等的。
  - 各个索引元素完全相等的两个数组也不相等
  - **当且仅当它们引用同一个基对象时，它们才相等**

## 类型转换

![image](https://github.com/NoahsDante/webNotes/blob/master/javascript/img/1.png)

### 转换和相等

> **一个值转换为另一个值并不意味着两个值相等**

### 显式类型转换

- 最简单的方法就是使用Boolean()、Number()、String()或Object()函数
  - 当不通过new运算符调用这些函数时，它们会作为类型转换函数并按照上表所描述的规则做类型转换
  - 除了null或undefined之外的任何值都具有toString()方法

### 对象转换为原始值

#### 对象到布尔值

> 所有的对象（包括数组和函数）都转换为true

#### 对象到字符串和对象到数字

> 通过调用待转换对象的一个方法来完成

##### **toString()**:

> 返回一个反映这个对象的字符串

- 数组类（Array class）的toString()方法将每个数组元素转换为一个字符串,并在元素之间添加逗号后合并成结果字符串
- 函数类（Function class）的toString()方法返回这个函数的实现定义的表示方式
- 日期类（Date class）定义的toString()方法返回了一个可读的（可被JavaScript解析的[[9\]](#filepos207999)）日期和时间字符串
- RegExp类（RegExp class）定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串

```javascript
[1,2,3].toString()//=＞"1,2,3"
(function(x){f(x);}).toString()//=＞"function(x){\n f(x);\n}"
/\d+/g.toString()
//=＞"/\\d+/g"
new Date(2010,0,1).toString()//=＞"Fri Jan 01 2010 00:00:00 GMT-0800(PST)"
```

##### JavaScript中对象到字符串的转换

1. 如果对象具有toString()方法，则调用这个方法如果它返回一个原始值，JavaScript将这个值转换为字符串(如果本身不是字符串的话)，并返回这个字符串结果
2. 如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么JavaScript会调用valueOf()方法。
   1. 如果存在这个方法，则JavaScript调用它。
   2. 如果返回值是原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果
3. JavaScript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常

##### valueOf()

> 如果存在任意原始值，它就**默认将对象转换为表示它的原始值**。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此**默认的valueOf()方法简单地返回对象本身**，而不是返回一个原始值

##### JavaScript中对象到数字的转换

1. 只是它会首先尝试使用valueOf()方法;后者返回一个原始值，则JavaScript将这个原始值转换为数字（如果需要的话）并返回这个数字
2. 如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回
3. JavaScript抛出一个类型错误异常

## 变量声明

使用一个变量之前应当先声明。**变量是使用关键字var来声明的，可以通过一个var关键字来声明多个变量**；还可以将变量的**初始赋值和变量合写在一起。如果未在var声明语句中给变量指定初始值**，那么虽然**声明了这个变量**，但在给它存入一个值之前，它的**初始值就是undefined。**

### 重复声明和遗漏声明

- 试图读取一个没有声明的变量的值，会报错（在严格模式下也一样）
- 在非严格模式下，如果给一个未声明的变量赋值，JavaScript实际上会给全局对象创建一个同名属性，并且它工作起来像，一个正确声明的全局变量

## 变量作用域

全局变量拥有全局作用域，在JavaScript代码中的任何地方都是有定义的。

函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，只在函数体内有定义。

在函数体内，局部变量的优先级高于同名的全局变量。

### 函数作用域和声明提前

JavaScript中没有块级作用域。JavaScript取代地使用了函数作用域：变量子啊声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。这意味着变量在声明之前甚至已经可用。JavaScript的这个特性被非正式地称为声明提前。即**函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部**

```javascript
var scope="global";
function f(){
console.log(scope);//输出"undefined"，而不是"global"
var scope="local";//变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的
console.log(scope);//输出"local"
}
```

### 作为属性的变量

当声明一个JavaScript全局变量时，实际上时定义全局对象的一个属性。当使用var声明一个变量时，创建这个属性时不可配置的(不可被删除的)。如果没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们：

```javascript
var truevar=1;//声明一个不可删除的全局变量
fakevar=2;//创建全局对象的一个可删除的属性
this.fakevar2=3;//同上
delete truevar//=＞false:变量并没有被删除
delete fakevar//=＞true:变量被删除
delete this.fakevar2//=＞true:变量被删除
```

### 作用域链

如果将一个布局变量看做是自定义实现的对象的属性的话。没段JavaScript代码（全局代码或函数）都有一个与之关联的作用域链这个作用域链是一个对象列表或者链表，这组对象定义这段代码“作用域中的变量”。当需要查找变量X的值的时候（这个过程称做“变量解析”），它会从链中的第一个对象开始了查找，如果这个对象有一个名为X的属性，会直接使用这个属性值，如果第一个对象中不存在名为X的属性，则会继续查找链上的下一个对象，如果还没有，那么就会继续查找下一个对象，以此类推，如果作用域上没有任何一个对象含有属性X，那么就认为这段代码的作用域链上不存在X，并最终抛出一个引用错误异常。

# 表达式和运算符

表达式式JavaScript中的一个短语，JavaScript解释器会将其计算出一个结果。

将简单表达式组合成**复杂表达式最常用的方法就是使用运算符。**

## 原始表达式

原始表达式式表达式的最小单位-它们不再包含其他表达式。包含**常量、直接量、关键字和变量。**

```javascript
1.23//数字直接量
"hello"//字符串直接量
/pattern///正则表达式直接量
true//返回一个布尔值：真
false//返回一个布尔值：假
null//返回一个值：空
this//返回"当前"对象
i//返回变量i的值
sum//返回sum的值
undefined//undefined是全局变量，和null不同，它不是一个关键字
```

## 对象和数组的初始化表达式

实际上是一个新创建的对象和数组。有时称做“对象直接量”和“数组直接量”。然而和布尔直接量不同，它们不是原始表达式，因为它们所包含的成员或者元素都是子表达式。

数组直接量中的列表都好之间的元素可以省略，这是省略的空位会填充undefined。

数组直接量的元素列表结尾处可以留下单个逗号，但这时并不会创建一个新的值为undefined。

对象同数组非常类似。

## 函数定义表达式

是定义一个JavaScript函数。表达式的值是这个新定义的函数。函数定义表达式同样可以包含函数的名字。函数也可以通过函数语句来定义，而不是函数表达式。

```javascript
//这个函数返回传入参数值的平方
var square=function(x){return x*x;}
```

## 属性访问表达式

运算得到一个对象属性或一个数组元素的值。

JavaScript属性访问定义两种语法：

```javascript
expression.identifer
expression[expression]
```

第一种写法是表达式指定对象，标识符则指定需要访问属性的名称。

第二种使用方括号，方括号内是另外一个表达式（适用于对象和数组）。表达式指定要防伪的属性的名称或者代表访问数组元素的索引。

不管使用哪种形式的属性访问表达式，在“.”和“[”之前的表达式总是会首先计算。

- 如果计算结果是null和undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任意属性。
- 如果运算结果不是对象（或者数组），JavaScript会将其转换为对象，
- 如果对象表达式后跟随句点和标识符，则会查找由这个标识符所指定的属性的值，并将其作为整个表达式的值返回
- 如果对象表达式后跟随一对方括号，则会计算方括号内的表达式的值并将它转换为字符串

.identifier的写法只适用于要访问的属性名称是合法的标识符，并且需要知道要访问的属性名字。

使用方括号写法

- 如果属性名称是一个**保留字或者包含空、标点符号或者是一个数字**
- 当属性名是通过**计算得出的值而不是固定的值时候**

## 调用表达式

是一种调用（或者执行）函数或方法的语法表示。

当对调用表达式进行求值的时候，

1. 首先计算函数表达式，然后计算参数表达式，得到一组参数值。如果函数表达式的值不是一个可调用对象，则抛出一个类型错误异常。
2. 实参的值被依次赋值给形参，这些形参是定义函数时指定的
3. 接下来开始执行函数体
4. 如果函数使用return语句给出一个返回值，那么这个返回值就是整个调用表达式的值；否则调用表达式的值就是undefined

如果这个表达式是一个属性访问表达式，这个调用称做"方法调用"。在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this的指向。

并不是方法调用的调用表达式通常使用全局呀对象作为this关键字的值。通过严格模式定义的函数在调用时将使用undefined作为this的值，this不会指向全局对象。

## 对象创建表达式

创建一个对象并调用一个函数（这个函数称做构造函数）初始化新对象的属性。

当计算一个对象创建表达式的值是，和对象初始化表达式通过{}创建对象一样，

1. JavaScript首先创建一个新的空对象，
2. JavaScript通过传入指定的参数并将这个新对象当做this的值来调用一个指定的函数，这个函数可以使用thsi来初始化这个新创建对象的属性。那些被当成构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果构造函数确实返回了一个对象值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了。

# 运算符概述

运算符用于算术表达、比较表达式、逻辑表达式、赋值表达式

![image](https://github.com/NoahsDante/webNotes/blob/master/javascript/img/2.png)

按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级。

被水平分割线分隔开来的运算符具有不同的优先级。

标题为A的列表示运算符的结合性，L（从左至右）或R（从右至左），

标题为N的列表示操作数的个数。

标题为“类型”的列表示期望的操作数类型，以及运算符的结果类型（在“→”符号之后）

## 操作数个数

### 一元运算符

将一个表达式转换为另外一个稍复杂的表达式：-x中的“-x”运算符就是

### 二元运算符

将来将两个表达式合成一个稍复杂的表达式：“*”乘法运算法

### 三元运算符

条件判断运算符“?:”，它将三个表达式合并成一个表达式条件判断运算符“?:”，它将三个表达式合并成一个表达式

yi yu a



















