
# 词法结构

> 一套基础性规则，用来描述如何使用这门语言来编写程序

## 字符集

###   Unicode转义序列

> 为了支持那些使用老旧技术的程序员，JavaScript定义了一种特殊序列，**使用6个ASCII字符来代表任意16位Unicode内码。这些Unicode转义序列均以\u为前缀，其后跟随4个十六进制数（使用数字以及大写或小写的字母A～F表示）**

字符é的Unicode转义写法为\u00E9，如下两个JavaScript字符串是完全一样的：

```javascript
"café"==="caf\u00e9"//=＞true
```

##  注释

###  “//”

> 在行尾“//”之后的文本都会被JavaScript当做注释忽略掉的

### “/*”和“*/”

> “/*”和“*/”之间的文本也会当做注释，**这种注释可以跨行书写，但不能有嵌套的注释**

## 标识符和保留字

### 标识符

- 标识符用来对变量和函数进行命名，或者用做JavaScript代码中某些循环语句中的跳转位置的标记
- JavaScript标识符必须以**字母、下划线（_）或美元符（$）开始**。后续的字符可以是字母、数字、下划线或美元符（数字是不允许作为首字符出现的，以便JavaScript可以轻易区分 开标识符和数字）

## 可选的分号

> **使用分号（;）将语句分隔开**

- 如果语句句各自独占一行，通常可以省略语句之间的分号（程序结尾或右花括号“}”之前的分号也可以省略）
- 只有在缺少了分号就无法正确解析代码的时候，JavaScript才会填补分号
  - 通常来讲，如果一条语句以**“(”、“[”、“/”、“+”或“-”开始**，那么它极有可能和前一条语句合在一起解析。
- 如果当前语句和下一行语句无法合并解析，JavaScript则在第一行后填补分号
  - 有例外
    - 涉及return、break和continue语句的场景中 - 如果这三个关键字后紧跟着换行，JavaScript则会在换行处填补分号
    - 涉及“++”和“——”运算符的时候。如果将其用做后缀表达式，它和表达式应当在同一行。否则，行尾将填补分号，同时“++”或“——”将会作为下一行代码的前缀操作符并与之一起解析

# 类型、值和变量

## 数字

> JavaScript中的所有数字均用浮点数值表示。JavaScript采用IEEE 754标准定义的64位浮点格式表示数字，这意味着它能表示的最大值是**±1.7976931348623157×10308，最小值是±5×10-324**

### 整型直接量

> 除了了**十进制的整型直接量**，JavaScript同样能识别**十六进制（以16为基数）值**

**但JavaScript的某些实现可以允许采用八进制（基数为8）形式表示整数**

> 由于某些JavaScript的实现支持八进制直接量，而有些不支持，因此最好不要使用以0为前缀的整型直接量，毕竟我们也无法得知当前JavaScript的实现是否支持八进制的解析。在的严格模式下，八进制直接量是明令禁止的

### JavaScript中的算术运算

#### 溢出（overflow）

- 当数字运算结果超过了JavaScript所能表示的数字上限（溢出），结果为一个特殊的无穷大（infinity）值，在JavaScript中以Infinity表示。
- 当负数的值超过了JavaScript所能表示的负数范围，结果为负无穷大，在JavaScript中以-Infinity表示。
- 无穷大值的行为特性和我们所期望的是一致的：基于它们的加、减、乘和除运算结果还是无穷大值（当然还保留它们的正负号）

#### 下溢（underflow）

- 当运算结果无限接近于零并比JavaScript能表示的最小值还小的时候发生的这种情况下，JavaScript将会返回0。
- 当一个负数发生下溢时，JavaScript返回一个特殊的值“负零”。这个**值（负零）几乎和正常的零完全一样**，

#### 特殊

- 被零整除在JavaScript并不报错：它只是简单的返回无穷大（Infinity）或负无穷大（-Infinity）
- **NaN的情况**

  - **零除以零**是没有意义的，这种整除运算结果也是一个非数字（not-a-number）值
  - **无穷大除以无穷大、给任意负数作开方运算或者算术运算符与不是数字或无法转换为数字的操作**数一起使用时
- **负零值同样有些特殊，它和正零值是相等**的（甚至使用JavaScript的严格相等测试来判断）

### 二进制浮点数和四舍五入错误

> JavaScript采用了IEEE-754浮点数表示法（几乎所有现代编程语言所采用），这是一种二进制表示法，可以精确地表示分数，比如1/2、1/8和1/1024。遗憾的是，我们常用的分数（特别是在金融计算方面）都是十进制分数1/10、1/100等。二进制浮点数表示法并不能精确表示类似0.1这样简单的数字

## 文本

> 字符串（string）是一组由16位值组成的不可变的有序序列，每个字符通常来自于Unicode字符集;字符串的长度（length）**是其所含16位值的个数**

### 字符串直接量

> 由单引号定界的字符串中可以包含双引号，由双引号定界的字符串中也可以包含单引号

- 在JavaScript表达式中使用单引号表示字符串
- 在HTML事件处理程序属性中则使用双引号表示字符串

### 转义字符

> 反斜线符号后加一个字符，就不再表示它们的字面含义

### 字符串的使用

- 号(+)运算符用字符串；则表示字符串连接
- 要确定一个字符串的长度- 使用字符串的**length属性**
- **在JavaScript中字符串是固定不变的**，类似**replace()和toUpperCase()的方法都返回新字符串**，原字符串本身并没有发生改变

## 布尔值

> 指代真或假、开或关、是或否。这个类型只有两个值，保留字true和false

- 布尔值通常用于JavaScript中的控制结构中（if/else语句）
- 所有其他值，包括所有对象（数组）都会转换成true
  - 假值
    - **Undefined、null、0、0、NaN、""**
  - 真值
    - **除了假植以外**
- toString()方法，因此可以使用这个方法将字符串转换为**"true"或"false"**，但它并不包含其他有用的方法

## null和undefined

### null

> 它表示一个**特殊值，常用来描述“空值”**。对null执行typeof预算，结果返回字符串"object"，也就是说，可以将null认为是一个特殊的对象值，含义是“非对象”。 

### undefined

> 用未定义的值表示更深层次的“空值”;它是变量的一种取值，表明变量没有初始化

- 要**查询对象属性或数组元素的值**时返回undefined则说明这个属性或元素不存在
- **如果函数没有返回任何值**，则返回undefined
- 用**没有提供实参的函数形参的值**也只会得到undefined

### 注意

> 尽管null和undefined是不同的，但它们都表示“值的空缺”，两者往往可以互换

- 判断**相等运算符“==”认为两者是相等的（要使用严格相等运算符“===”来区分它们）**

## 包装对象

> JavaScript对象是一种复合值：它是**属性或已命名值的集合**。通过“.”符号来引用属性值。当属性值是一个函数的时候，称其为方法

- **存取字符串、数字或布尔值的属性时创建的临时对象称做包装对象**，它只是偶尔用来区分字符串值和字符串对象、数字和数值对象以及布尔值和布尔对象

## 不可变的原始值和可变的对象引用

### 原始值

> undefined、null、布尔值、数字和字符串

- 任何**方法都无法更改（或“突变”）一个原始值**
- 字符串看起来像由字符组成的数组;字符串中所有的方法看上去返回了一个**修改后的字符串**，实际上返回的是一个**新的字符串值**
- 原始值的比较是值的比较：
  - 只有在它们的**值相等时它们才相等**

### 对象

- 它们是可变的——它们的值是**可修改**
- 对象的**比较并非值**的比较
  - 即使**两个对象包含同样的属性及相同的值**，它们也是不相等的。
  - 各个索引元素完全相等的两个数组也不相等
  - **当且仅当它们引用同一个基对象时，它们才相等**

## 类型转换

![image](https://github.com/NoahsDante/webNotes/blob/master/javascript/img/1.png)

### 转换和相等

> **一个值转换为另一个值并不意味着两个值相等**

### 显式类型转换

- 最简单的方法就是使用Boolean()、Number()、String()或Object()函数
  - 当不通过new运算符调用这些函数时，它们会作为类型转换函数并按照上表所描述的规则做类型转换
  - 除了null或undefined之外的任何值都具有toString()方法

### 对象转换为原始值

#### 对象到布尔值

> 所有的对象（包括数组和函数）都转换为true

#### 对象到字符串和对象到数字

> 通过调用待转换对象的一个方法来完成

##### **toString()**:

> 返回一个反映这个对象的字符串

- 数组类（Array class）的toString()方法将每个数组元素转换为一个字符串,并在元素之间添加逗号后合并成结果字符串
- 函数类（Function class）的toString()方法返回这个函数的实现定义的表示方式
- 日期类（Date class）定义的toString()方法返回了一个可读的（可被JavaScript解析的[[9\]](#filepos207999)）日期和时间字符串
- RegExp类（RegExp class）定义的toString()方法将RegExp对象转换为表示正则表达式直接量的字符串

```javascript
[1,2,3].toString()//=＞"1,2,3"
(function(x){f(x);}).toString()//=＞"function(x){\n f(x);\n}"
/\d+/g.toString()
//=＞"/\\d+/g"
new Date(2010,0,1).toString()//=＞"Fri Jan 01 2010 00:00:00 GMT-0800(PST)"
```

##### JavaScript中对象到字符串的转换

1. 如果对象具有toString()方法，则调用这个方法如果它返回一个原始值，JavaScript将这个值转换为字符串(如果本身不是字符串的话)，并返回这个字符串结果
2. 如果对象没有toString()方法，或者这个方法并不返回一个原始值，那么JavaScript会调用valueOf()方法。
   1. 如果存在这个方法，则JavaScript调用它。
   2. 如果返回值是原始值，JavaScript将这个值转换为字符串（如果本身不是字符串的话），并返回这个字符串结果
3. JavaScript无法从toString()或valueOf()获得一个原始值，因此这时它将抛出一个类型错误异常

##### valueOf()

> 如果存在任意原始值，它就**默认将对象转换为表示它的原始值**。对象是复合值，而且大多数对象无法真正表示为一个原始值，因此**默认的valueOf()方法简单地返回对象本身**，而不是返回一个原始值

##### JavaScript中对象到数字的转换

1. 只是它会首先尝试使用valueOf()方法;后者返回一个原始值，则JavaScript将这个原始值转换为数字（如果需要的话）并返回这个数字
2. 如果对象具有toString()方法，后者返回一个原始值，则JavaScript将其转换并返回
3. JavaScript抛出一个类型错误异常

## 变量声明

使用一个变量之前应当先声明。**变量是使用关键字var来声明的，可以通过一个var关键字来声明多个变量**；还可以将变量的**初始赋值和变量合写在一起。如果未在var声明语句中给变量指定初始值**，那么虽然**声明了这个变量**，但在给它存入一个值之前，它的**初始值就是undefined。**

### 重复声明和遗漏声明

- 试图读取一个没有声明的变量的值，会报错（在严格模式下也一样）
- 在非严格模式下，如果给一个未声明的变量赋值，JavaScript实际上会给全局对象创建一个同名属性，并且它工作起来像，一个正确声明的全局变量

## 变量作用域

全局变量拥有全局作用域，在JavaScript代码中的任何地方都是有定义的。

函数内声明的变量只在函数体内有定义。它们是局部变量，作用域是局部性的。函数参数也是局部变量，只在函数体内有定义。

在函数体内，局部变量的优先级高于同名的全局变量。

### 函数作用域和声明提前

JavaScript中没有块级作用域。JavaScript取代地使用了函数作用域：变量子啊声明它们的函数体以及这个函数体嵌套的任意函数体内都是有定义的。

函数作用域是指在函数内声明的所有变量在函数体内始终是可见的。这意味着变量在声明之前甚至已经可用。JavaScript的这个特性被非正式地称为声明提前。即**函数里声明的所有变量（但不涉及赋值）都被“提前”至函数体的顶部**

```javascript
var scope="global";
function f(){
console.log(scope);//输出"undefined"，而不是"global"
var scope="local";//变量在这里赋初始值，但变量本身在函数体内任何地方均是有定义的
console.log(scope);//输出"local"
}
```

### 作为属性的变量

当声明一个JavaScript全局变量时，实际上时定义全局对象的一个属性。当使用var声明一个变量时，创建这个属性时不可配置的(不可被删除的)。如果没有使用严格模式并给一个未声明的变量赋值的话，JavaScript会自动创建一个全局变量。以这种方式创建的变量是全局对象的正常的可配值属性，并可以删除它们：

```javascript
var truevar=1;//声明一个不可删除的全局变量
fakevar=2;//创建全局对象的一个可删除的属性
this.fakevar2=3;//同上
delete truevar//=＞false:变量并没有被删除
delete fakevar//=＞true:变量被删除
delete this.fakevar2//=＞true:变量被删除
```

### 作用域链

如果将一个布局变量看做是自定义实现的对象的属性的话。没段JavaScript代码（全局代码或函数）都有一个与之关联的作用域链这个作用域链是一个对象列表或者链表，这组对象定义这段代码“作用域中的变量”。当需要查找变量X的值的时候（这个过程称做“变量解析”），它会从链中的第一个对象开始了查找，如果这个对象有一个名为X的属性，会直接使用这个属性值，如果第一个对象中不存在名为X的属性，则会继续查找链上的下一个对象，如果还没有，那么就会继续查找下一个对象，以此类推，如果作用域上没有任何一个对象含有属性X，那么就认为这段代码的作用域链上不存在X，并最终抛出一个引用错误异常。

# 表达式和运算符

表达式式JavaScript中的一个短语，JavaScript解释器会将其计算出一个结果。

将简单表达式组合成**复杂表达式最常用的方法就是使用运算符。**

## 原始表达式

原始表达式式表达式的最小单位-它们不再包含其他表达式。包含**常量、直接量、关键字和变量。**

```javascript
1.23//数字直接量
"hello"//字符串直接量
/pattern///正则表达式直接量
true//返回一个布尔值：真
false//返回一个布尔值：假
null//返回一个值：空
this//返回"当前"对象
i//返回变量i的值
sum//返回sum的值
undefined//undefined是全局变量，和null不同，它不是一个关键字
```

## 对象和数组的初始化表达式

实际上是一个新创建的对象和数组。有时称做“对象直接量”和“数组直接量”。然而和布尔直接量不同，它们不是原始表达式，因为它们所包含的成员或者元素都是子表达式。

数组直接量中的列表都好之间的元素可以省略，这是省略的空位会填充undefined。

数组直接量的元素列表结尾处可以留下单个逗号，但这时并不会创建一个新的值为undefined。

对象同数组非常类似。

## 函数定义表达式

是定义一个JavaScript函数。表达式的值是这个新定义的函数。函数定义表达式同样可以包含函数的名字。函数也可以通过函数语句来定义，而不是函数表达式。

```javascript
//这个函数返回传入参数值的平方
var square=function(x){return x*x;}
```

## 属性访问表达式

运算得到一个对象属性或一个数组元素的值。

JavaScript属性访问定义两种语法：

```javascript
expression.identifer
expression[expression]
```

第一种写法是表达式指定对象，标识符则指定需要访问属性的名称。

第二种使用方括号，方括号内是另外一个表达式（适用于对象和数组）。表达式指定要防伪的属性的名称或者代表访问数组元素的索引。

不管使用哪种形式的属性访问表达式，在“.”和“[”之前的表达式总是会首先计算。

- 如果计算结果是null和undefined，表达式会抛出一个类型错误异常，因为这两个值都不能包含任意属性。
- 如果运算结果不是对象（或者数组），JavaScript会将其转换为对象，
- 如果对象表达式后跟随句点和标识符，则会查找由这个标识符所指定的属性的值，并将其作为整个表达式的值返回
- 如果对象表达式后跟随一对方括号，则会计算方括号内的表达式的值并将它转换为字符串

.identifier的写法只适用于要访问的属性名称是合法的标识符，并且需要知道要访问的属性名字。

使用方括号写法

- 如果属性名称是一个**保留字或者包含空、标点符号或者是一个数字**
- 当属性名是通过**计算得出的值而不是固定的值时候**

## 调用表达式

是一种调用（或者执行）函数或方法的语法表示。

当对调用表达式进行求值的时候，

1. 首先计算函数表达式，然后计算参数表达式，得到一组参数值。如果函数表达式的值不是一个可调用对象，则抛出一个类型错误异常。
2. 实参的值被依次赋值给形参，这些形参是定义函数时指定的
3. 接下来开始执行函数体
4. 如果函数使用return语句给出一个返回值，那么这个返回值就是整个调用表达式的值；否则调用表达式的值就是undefined

如果这个表达式是一个属性访问表达式，这个调用称做"方法调用"。在方法调用中，执行函数体的时候，作为属性访问主题的对象和数组便是其调用方法内this的指向。

并不是方法调用的调用表达式通常使用全局呀对象作为this关键字的值。通过严格模式定义的函数在调用时将使用undefined作为this的值，this不会指向全局对象。

## 对象创建表达式

创建一个对象并调用一个函数（这个函数称做构造函数）初始化新对象的属性。

当计算一个对象创建表达式的值是，和对象初始化表达式通过{}创建对象一样，

1. JavaScript首先创建一个新的空对象，
2. JavaScript通过传入指定的参数并将这个新对象当做this的值来调用一个指定的函数，这个函数可以使用thsi来初始化这个新创建对象的属性。那些被当成构造函数的函数不会返回一个值，并且这个新创建并被初始化后的对象就是整个对象创建表达式的值。如果构造函数确实返回了一个对象值，那么这个对象就作为整个对象创建表达式的值，而新创建的对象就废弃了。

# 运算符概述

运算符用于算术表达、比较表达式、逻辑表达式、赋值表达式

![image](https://github.com/NoahsDante/webNotes/blob/master/javascript/img/2.png)

按照运算符的优先级排序的，前面的运算符优先级要高于后面的运算符优先级。

被水平分割线分隔开来的运算符具有不同的优先级。

标题为A的列表示运算符的结合性，L（从左至右）或R（从右至左），

标题为N的列表示操作数的个数。

标题为“类型”的列表示期望的操作数类型，以及运算符的结果类型（在“→”符号之后）

## 操作数个数

### 一元运算符

将一个表达式转换为另外一个稍复杂的表达式：-x中的“-x”运算符就是

### 二元运算符

将来将两个表达式合成一个稍复杂的表达式：“*”乘法运算法

### 三元运算符

条件判断运算符“?:”，它将三个表达式合并成一个表达式条件判断运算符“?:”，它将三个表达式合并成一个表达式

### 操作数类型和结果类型

一些运算符可以作用于任何数据类型，但是仍然希望它们的操作数是指定类型的数据，并且大多数运算符返回（或计算出一个特定类型的值）

### 左值

表达式只能出现在赋值运算符的左侧。在JavaScript中变量、对象属性和数组元素均是左值。

### 运算符的副作用

一些前后的表达式运算会相互影响。赋值运算符是最明显的一个例子：如果给一个变量或属性赋值，那么那些使用这个变量或属性的表达式的值都会改变。“++”和“—”递增和递减运算符与此类似，因为它们包含隐式的赋值。delete运算符同样有副作用：删除一个属性就像给这个属性赋值undefined。

### 运算符优先级

运算符优先级控制着运算符的执行顺序。**优先级高的运算符的执行总是先于优先级低的运算符。**

**运算符的优先级可以通过显式使用圆括号来重写。**

**属性访问表达式和调用表达式的优先级是最高的。**

### 运算符的结合性

指定了在**多个具有同样优先级的运算符表达式中的运算顺序。**

### 运算顺序

运算符的优先级和结合性规定了它们在复杂的表达式中的运算顺序，

但没有规定**子表达式的计算过程的运算顺序。**

例如，在表达式w=x+y*z中，将首先计算子表达式w，然后计算x、y和z，然后，y的值和z的值相乘，再加上x的值，最后将其赋值给表达式w所指代的变量或属性。给表达式添加圆括号将会改变乘法、加法和赋值运算的关系，但从左至右的顺序是不会改变的

## 算术表达式

### ”+“运算符

二元加法运算符“+”可以对两个数字做加法，也可以做字符串连接操作：

加号的转换规则**优先考虑字符串连接**，如果其中一个操作数是字符串或者转换为字符串的对象，另外一个操作数将会转换为字符串，加法将进行字符串连接操作。如果两个操作数多都不是类字符串，都将进行算术加法运算。

- 如果其中一个操作数是对象，则对象遵循对象到原始值的转换规则转换为原始类值：日期对象通过toString()方法执行转换，其他对象则通过valueOf方法执行转换。由于多数对象都不具备可用的valueOf方法，因此它们通过toString()方法来执行转换。
- 在进行对象到原始值的转换后，如果其中一个操作数是字符串，另一个操作数也会转换为字符串，然后进行字符串连接。
- 否则，两个操作数都将转换为数字（NaN），然后进行加法操作。

```javascript
1+2//=＞3:加法
"1"+"2"//=＞"12":字符串连接
"1"+2//=＞"12":数字转换为字符串后进行字符串连接
1+{}//=＞"1[object Object]":对象转换为字符串后进行字符串连接
true+true//=＞2:布尔值转换为数字后做加法
2+null//=＞2:null转换为0后做加法
2+undefined//=＞NaN:undefined转换为NaN后做加法
```

当加号运算符和字符串和数字一起使用时，需要考**虑加法的结合性对运算顺序的影响。运算结果是依赖于运算符的运算顺序。**

### 一元算术运算符

一元运算符作用于一个独立的操作数，并产生一个新值。在JavaScript中，**一元运算符具有很高的优先级，而且都是右结合。必要时，它们会将操作数转换为数字**。并且“+”和“-”既是一元看运算符，也是二元运算符。

#### 一元加法（+）

把操作数转换为数字（NaN），并返回这个转换后的数字。如果操作数本身就是数字，则直接返回这个数字。

#### 一元减法（-）

它会根据需要把操作数转换为数字，然后改变运算结果的符号。

#### 递增（++）

对操作数进行增量（加一）操作，操作数是一个左值（变量、数组或对象）。运算符将操作数转换为数字，然后给数字加一，并将加一后的数值重新赋值给变量、数组或对象。

递增“++”运算符的返回值依赖于它相对操作数的位置。

当运算符在操作数之前，称为“前增量”运算符，**它对操作数进行增量计算，并返回计算后的值。**

当运算符在操作数之后，称为“后增量”，**它对操作数进行增量计算，但返回未做增量计算。**

但是表达式++x并总和x=x+1完全一样，**“++”运算符从不进行字符串连接操作，它总是会将操作数转换为数字并增1。**如果x是字符串“1”，++x的结果就是数字2，而x+1是字符串“11”。

同样需要注意的是，由于JavaScript会自动进行分号补全，因此不能在后增量运算符和操作数之间插入换行符。如果插入了换行符，JavaScript将会把操作数当做一条单独的语句，并在其之前补上一个分号。

#### 递减（--）

递减“-”运算符的操作数也是一个左值。它把操作数转换为数字，然后减1，并将计算后的值重新赋值给操作数。和“++”运算符一样，递减“--”运算符的返回值依赖于它相对操作数的位置，**当递减运算符在操作数之前，操作数减1并返回减1之后的值。**当递减运算符在操作数之后，操作数减1并返回减1之前的值。当递减运算符在操作符的右侧时，运算符和操作数之间不能有换行符。

## 关系表达式

关系运算符**用于测试两个值之间的关系，根据关系是否存在而返回true或false。**关系表达式总是返回一个布尔值，通常在if、while或者for语句中使用关系表达式，用以控制程序的执行流程。

### 相等和不等运算符

#### "=="

称做“相等”，允许进行类型转换。

- 如果两个操作数的类型相同，则和严格相等的比较规则一样。如果严格相等，那么比较结果为相对。如果它们不严格相等，则比较结果为不相等。
- 如果两个操作数类型不同，“==”相等操作符也可能会认为它们相等。
  1. 如果一个值是null，另一个是undefined，则它们相等
  2. 如果一个值是数字，另一个是字符串，先将字符串转换为数字，然后使用转换后的值进行比较
  3. 如果其中一个值是true，则将其转换为1再进行比较。如果其中一个值是false，则将其转换为0再进行比较
  4. 如果一个值是对象，另一个值是数字或字符串，则使用将对象转换为原始值，然后再进行比较。对象通过toString()方法或者valueOf()方法转换为原始值。JavaScript语言核心的内置类首先尝试使用valueOf()，再尝试使用toString()，除了日期类，日期类只使用toString()转换。那些不是JavaScript语言核心中的对象则通过各自的实现中定义的方法转换为原始值
  5. 其他不同类型之间的比较均不相等

#### "==="

严格相等运算符“===”首先计算其操作数的值，然后比较这两个值，比较过程没有任何类型转换

- 如果两个值类型不相同，则它们不相等
- 如果两个值都是null或者都是undefined，则它们不相等
- 如果两个值都是布尔值true或都是布尔值false，则它们相等
- 如果其中一个值是NaN，或者两个值都是NaN，则它们不相等。NaN和其他任何值都是不相等的，包括它本身！通过x!==x来判断x是否为NaN，只有在x为NaN的时候，这个表达式的值才为true
- 如果两个值为数字且数值相等，则它们相等。如果一个值为0，另一个值为-0，则它们同样相等
- 如果两个值为字符串，且所含的对应位上的16位数完全相等，则它们相等。如果它们的长度或内容不同，则它们不等。两个字符串可能含义完全一样且所显示出的字符也一样，但具有不同编码的16位值。JavaScript并不对Unicode进行标准化的转换，因此像这样的字符串通过“===”和“==”运算符的比较结果也不相等
- 如果两个引用值指向同一个对象、数组或函数，则它们是相等的。如果指向不同的对象，则它们是不等的，尽管两个对象具有完全一样的属性

### 比较运算法

比较运算符用来检测两个操作数的大小关系；比较操作符的操作数可能是任意类型。然而只有数字和字符串才能真正执行比较操作。

不是数字和字符串的操作数都将进行类型转换：

- 如果操作数为对象，转换规则转换为原始值：如果valueOf()返回一个原始值，那么直接使用这个原始值。否则，使用toString()的转换结果进行比较操作。在对象转换为原始值之后，如果两个操作数都是字符串，那么将依照字母表的顺序对两个字符串进行比较，这里提到的“字母表顺序”是指组成这个字符串的16位Unicode字符的索引顺序
- 在对象转换为原始值之后，如果至少有一个操作数不是字符串，那么两个操作数都将转换为数字进行数值比较。0和-0是相等的。Infinity比其他任何数字都大（除了Infinity本身），-Infinity比其他任何数字都小（除了它自身）。如果其中一个操作数是（或转换后是）NaN，那么比较操作符总是返回false

JavaScript字符串是一个由16位整数值组成的序列，字符串的比较也只是两个字符串中的字符的数值比较。由Unicode定义的字符编码顺序和任何特定语言或者本地语言字符集中的传统字符编码顺序不尽相同。注意，字符串**比较是区分大小写的，所有的大写的ASCII字母都“小于”小写的ASCII字母**

**比较运算符则更偏爱数字，**只有在两个操作数都是字符串的时候，才会进行字符串的比较：

```javascript
1+2//加法.结果是3
"1"+"2"//字符串连接，结果是"12"
"1"+2//字符串链接，2转换为"2"，结果是"12"
11＜3//数字的比较，结果为false
"11"＜"3"//字符串比较，结果为true
"11"＜3//数字的比较，"11"转换为11，结果为false
```

### in 运算符

它的操作数是一个字符串或可以转换为字符串，它的右操作数是一个对象。如果右侧的对象拥有一个名为左操作数值的属性名，表达式返回true。

### instanceof运算符

instanceof运算符希望左操作数是一个对象，右操作数标识对象的类。如果左侧的对象是右侧类的实例，则表达式返回true；否则返回false。

## 逻辑表达式

逻辑运算符“＆＆”、“||”和“!”是对操作数进行布尔算术运算，经常和关系运算符一起配合使用，逻辑运算符将多个关系表达式组合起来组成一个更复杂的表达式

### 逻辑与（&&）

- 操作数都是布尔值的时候，“＆＆”对两个值执行布尔与（AND）操作，只有在第一个操作数和第二个操作数都是true的时候，它才返回true。如果其中一个操作数是false，它返回false。
- ＆＆”可以对真值和假值进行布尔与（AND）操作。如果两个操作数都是真值，那么返回一个真值；否则，至少一个操作数是假值的话，则返回一个假值
- 运算符首先计算左操作数的值，即首先计算“＆＆”左侧的表达式。**如果计算结果是假值，那么整个表达式的结果一定也是假值，因此“＆＆”这时简单地返回左操作数的值，而并不会对右操作数进行计算；**如果左操作数是真值，那么整个表达式的结果则依赖于右操作数的值。**如果右操作数是真值，那么整个表达式的值一定是真值；**如果右操作数是假值，那么整个表达式的值一定是假值。因此，当左操作数是真值时，“＆＆”运算符将计算右操作数的值并将其返回作为整个表达式的计算结果

### 逻辑或（||）

“||”运算符对两个操作数做布尔或（OR）运算。如果其中一个或者两个操作数是真值，**它返回一个真值。如果两个操作数都是假值，它返回一个假值；**它会首先计算第一个操作数的值，也就是说会首先计算左侧的表达式。如果计算结果为真值，那么返回这个真值。否则，再计算第二个操作数的值，即计算右侧的表达式，并返回这个表达式的计算结果；**这种惯用法通常用在函数体内，用来给参数提供默认值**

### 逻辑非（!）

!”运算符首先将其操作数转换为布尔值，然后再对布尔值求反。也就是说“!”总是返回true或者false，并且，可以通过使用两次逻辑非运算来得到一个值的等价布尔值：!!x

作为一个一元运算符，“!”具有很高的优先级，并且和操作数紧密绑定在一起。

## 赋值表达式

它的左操作数是一个左值：**一个变量或者对象属性（或数组元素）。它的右操作数可以是任意类型的任意值。赋值表达式的值就是右操作数的值。**

赋值操作符的结合性是**从右至左，**也就是说，如果一个表达式中出现了多个赋值运算符，运算顺序是从右到左。

## 表达式计算

JavaScript同样可以解释运行由JavaScript源代码组成的字符串，并产生一个值。JavaScript通过全局函数eval()来完成这个工作

### eval()

eval()只有一个参数。

1. 如果传入的参数不是字符串，它直接返回这个参数。

2. 如果参数是字符串，它会把字符串当成JavaScript代码进行编译（parse），

3. 如果编译失败则抛出一个语法错误（SyntaxError）异常。

4. 如果编译成功，则开始执行这段代码，并返回字符串中的最后一个表达式或语句的值，

5. 如果最后一个表达式或语句没有值，则最终返回undefined。

6. 如果字符串抛出一个异常，这个异常将把该调用传递给eval()。

它使用了调用它的变量作用域环境。也就是说，它查找变量的值和定义新变量和函数的操作和局部作用域中的代码完全一样。

不能通过eval()往函数中任意粘贴代码片段，比如，eval("return;")是没有意义的，因为return只有在函数中才起作用;

eval的字符串执行时的上下文环境和调用函数的上下文环境是一样的

在严格模式下，eval执行的代码段可以查询或更改局部变量，但不能在局部作用域中定义新的变量或函数。

严格模式将"eval"列为保留字，这让eval()更像一个运算符。不能用一个别名覆盖eval()函数。并且变量名、函数名、函数参数或者异常捕获的参数都不能取名为"eval"

## 其他运算符

### 条件运算符（?:）

条件运算符是JavaScript中唯一的一个三元运算符（三个操作数），有时直接称做“三元运算符”。通常这个运算符写成“?:”，当然在代码中往往不会这么简写，因为这个运算符拥有三个操作数，第一个操作数在“?”之前，第二个操作数在“?”和“:”之间，第三个操作数在“:”之后

### typeof运算符

typeof是一元运算符，放在其单个操作数的前面，操作数可以是任意类型。**返回值为表示操作数类型的一个字符串；**

当操作数是null的时候，typeof将返回"object"。如果想将null和对象区分开，则必须针对特殊值显式检测

### delete运算符

delete是一元操作符，它用来删除对象属性或者数组元素。就像赋值、递增、递减运算符一样；

除属性或者删除数组元素**不仅仅是设置了一个undefined的值。当删除一个属性时，这个属性将不再存在。读取一个不存在的属性将返回undefined；**

并不是所有的属性都可删除，一些内置核心和客户端属性是不能删除的，**用户通过var语句声明的变量不能删除。同样，通过function语句定义的函数和函数参数也不能删除。**

在严格模式下：只有操作数是一个属性访问表达式的时候它才会正常工作。

### void运算符

它出现在操作数之前，操作数可以是任意类型。**操作数会照常计算，但忽略计算结果并返回undefined**

这个运算符最常用在客户端的URL——javascript:URL中，在URL中可以写带有副作用的表达式，而void则让浏览器不必显示这个表达式的计算结果

### 逗号运算符

它的操作数可以是任意类型。它首先计算左操作数，然后计算右操作数，最后返回右操作数的值；

逗号运算符最常用的场景是在for循环中





















