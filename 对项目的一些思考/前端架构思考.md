前端架构原则

前端架构是一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效、可持续的工作流

## 体系设计

通过设计所有前端开发人员都要遵循的系统规范,**前端架构师清晰描绘出产品与代码的最终形态**;一旦前端架构师建立起来系统设计规范,项目拥有了可以衡量代码质量的标准;并做出适当的取舍,以保证系统中的代码有实质的价值,**而不是简单的堆砌**

## 工作规划

有了清晰的结构设计后,就需要制定开发工作流程了;**设计出能流畅运转饿系统,能发幅度减少由于重复操作而产生的认为错**误.

## 监督跟进

能够持续地优化工作流程;**前端开发人员面向终端用户写代码,而前端架构师面向的是团队里的开发人员**

# 前端架构核心

## 代码

专注于如何实现系统架构中的 HTML、CSS 和 JavaScript

## 流程

在重要的是思考怎么用工具和流程构建一个高效且避免出错的工作流;提高生产力、加快效率和保持代码一致性

## 测试

构建一个可扩展和可持续优化的系统，必须保证新代码与老代码能够很好地兼容。我们的代码不会独立存在

## 文档
需要编写的各种文档类型、发布文档的工具，以及阅读这些文档的用户角色

# 代码

## HTML

### 程序式标记:自动化程度100%，可控程度0%

html统一由后端生成,如CMS编辑

```html
<div id="header" class="clearfix">
       <div id="header-screen" class="clearfix">
         <div id="header-inner" class="container-12 clearfix">
           <div id="nav-header" role="navigation">
             <div class="region region-navigation">
               <div class="block block-system block-menu">
                 <div class="block-inner">
                   <div class="content">
                     <ul class="menu">
                       <li class="first leaf">
                         <a href="/start">Get Started</a>
```

"div乱锅杂炖";有助于我们把静态 Photoshop 图像做成标记化的页面;div嵌套层级太深;不利于语义话;

### 静态标记:自动化程度0%，可控程度100%

任务只是开发一个需要填充一大块主体区域的页面，那么编写静态标记更为方便; 种情况灵活性很大，但是也意味着我们必须负责维护所有的代码

```html
<header>
       <section>
<nav> 
    <div>
	<ul> 
   		 <li>
             <a href="/products">Products</a>
                <ul>
                  <li>
                    <a href="/socks">Socks</a>
                       
 header > section > nav > div > ul > li > a {
       color: white;
     }
     header > section > nav > div > ul > li > ul > li > a  {
       color: blue;
     }                      
```

为了保持简洁，“语义化”的标记是首选，应用样式所依靠的是 HTML5 元素名称和它们的层级关系，而非 CSS 类名;但所选择器过长,不利于样式编写与覆盖.

### 模块化标记:自动化程度100%，可控程度100%

模块化标记和程序化标记的区别在于，**对于使用什么标记输出既定内容，我们不会完全任由 CMS 决定**。这使得我们可为两个不同的导航实例使用一样的标记，虽然 CMS 生成的标记可能完全不一样。

模块化标记和静态化标记的区别在于，程序化地执行完之后，**我们还可以通过一套类名系统给标记动态添加 CSS 类名，并且不再通过元素标签和层级关系来决定视觉外观**

### 模块化CSS理论的多面性

例如使用新的命名空间、扩充数据属性，甚至是在JavaScript 里定义 CSS;

#### OOCSS方法

Object-Oriented CSS，面向对象的 CSS

```html
<div class="toggle simple">
       <div class="toggle-control open">
         <h1 class="toggle-title">Title 1</h1>
       </div>
       <div class="toggle-details open"> ... </div>

```

**有两个主要的原则:分离结构和外观，以及分离容器和内容**

- 分离结构和外观
  - 将视觉特性定义为可复用的单元
  - 例如，当前的“simple”皮肤使用直角，而“complex”皮肤可能使用圆角，还加了阴影
- 分离容器和内容
  - 不再将元素位置作为样式的限定词
  - 如 toggle-title，它应用于相应的文本处理上，而不管这个文本的元素是什么

#### SMACSS方法

Scalable and Modular Architecture for CSS，模块化 架构的可扩展 CSS;**把样式系统划分为五个具体类别**

```html
<div class="toggle toggle-simple">
       <div class="toggle-control is-active">
         <h2 class="toggle-title">Title 1</h2>
       </div>
       <div class="toggle-details is-active">
         ...
</div>
... </dl>
```

- 基础

  - 如果不添加 CSS 类名，标记会以什么外观呈现
- 布局

  - 把页面分成一些区域
- 模块

  - 设计中的模块化、可复用的单元
- 状态

  - 描述在特定的状态或情况下，模块或布局的显示方式
- 主题
  - 一个可选状态的视觉外层,可以更换不同主题

#### OOCSS方法与SMACSS方法联系与区别

于如何创建功能的小模块，OOCSS和 SMACSS 有许多相似之处。它们都把样式作用域限定到根节点的 CSS 类名上，然后通过皮肤(OOCSS)或者子模块(SMACSS)进行修改;

**两者之间最显著的差异是使用皮肤而不是子模块，以及带 is 前缀的状态类名**

#### BEM 方法

素名加在双
下划线后(例如 toggle__details)，修饰符加在双横杠后(如 toggle__details--active)。这里的 details 是元素，active 是修饰符，这个约定使得 CSS 类名非常清晰。使用双横杠是为了避免块名被混淆为修饰符

```html
<div class="toggle toggle--simple">
       <div class="toggle__control toggle__control--active">
         <h2 class="toggle__title">Title 1</h2>
         </div>
         <div class="toggle__details toggle__details--active">
           ...
</div>
... </dl>
```

- 块名 
  - 所属组件的名称。 

- 元素 
  - 元素在块里面的名称。 

- 修饰符 

  - 任何与块或元素相关联的修饰符

码中没有 open 或者 is-active 这样只在特定背景下才能理解的 CSS 类名。如果单独看 open 和 is-active 这两个名字，我们并不知道它们的含义是什么。虽然 BEM方法看起来很累赘、很冗余 ，但是当看到一个 toggle__details--active 的 CSS 类名，我们就知道它是表示:这个元素的名称是 details，位置在 toggle 组件里，状态为激活