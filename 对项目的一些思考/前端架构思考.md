# 前端架构原则

前端架构是一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效、可持续的工作流

## 体系设计

通过设计所有前端开发人员都要遵循的系统规范,**前端架构师清晰描绘出产品与代码的最终形态**;一旦前端架构师建立起来系统设计规范,项目拥有了可以衡量代码质量的标准;并做出适当的取舍,以保证系统中的代码有实质的价值,**而不是简单的堆砌**

## 工作规划

有了清晰的结构设计后,就需要制定开发工作流程了;**设计出能流畅运转饿系统,能发幅度减少由于重复操作而产生的认为错**误.

## 监督跟进

能够持续地优化工作流程;**前端开发人员面向终端用户写代码,而前端架构师面向的是团队里的开发人员**

# 前端架构核心

## 代码

专注于如何实现系统架构中的 HTML、CSS 和 JavaScript

## 流程

在重要的是思考怎么用工具和流程构建一个高效且避免出错的工作流;提高生产力、加快效率和保持代码一致性

## 测试

构建一个可扩展和可持续优化的系统，必须保证新代码与老代码能够很好地兼容。我们的代码不会独立存在

## 文档
需要编写的各种文档类型、发布文档的工具，以及阅读这些文档的用户角色

# 代码

## HTML

### 程序式标记:自动化程度100%，可控程度0%

html统一由后端生成,如CMS编辑

```html
<div id="header" class="clearfix">
       <div id="header-screen" class="clearfix">
         <div id="header-inner" class="container-12 clearfix">
           <div id="nav-header" role="navigation">
             <div class="region region-navigation">
               <div class="block block-system block-menu">
                 <div class="block-inner">
                   <div class="content">
                     <ul class="menu">
                       <li class="first leaf">
                         <a href="/start">Get Started</a>
```

"div乱锅杂炖";有助于我们把静态 Photoshop 图像做成标记化的页面;div嵌套层级太深;不利于语义话;

### 静态标记:自动化程度0%，可控程度100%

任务只是开发一个需要填充一大块主体区域的页面，那么编写静态标记更为方便; 种情况灵活性很大，但是也意味着我们必须负责维护所有的代码

```html
<header>
       <section>
<nav> 
    <div>
	<ul> 
   		 <li>
             <a href="/products">Products</a>
                <ul>
                  <li>
                    <a href="/socks">Socks</a>
                       
 header > section > nav > div > ul > li > a {
       color: white;
     }
     header > section > nav > div > ul > li > ul > li > a  {
       color: blue;
     }                      
```

为了保持简洁，“语义化”的标记是首选，应用样式所依靠的是 HTML5 元素名称和它们的层级关系，而非 CSS 类名;但所选择器过长,不利于样式编写与覆盖.

### 模块化标记:自动化程度100%，可控程度100%

模块化标记和程序化标记的区别在于，**对于使用什么标记输出既定内容，我们不会完全任由 CMS 决定**。这使得我们可为两个不同的导航实例使用一样的标记，虽然 CMS 生成的标记可能完全不一样。

模块化标记和静态化标记的区别在于，程序化地执行完之后，**我们还可以通过一套类名系统给标记动态添加 CSS 类名，并且不再通过元素标签和层级关系来决定视觉外观**

### 模块化CSS理论的多面性

例如使用新的命名空间、扩充数据属性，甚至是在JavaScript 里定义 CSS;

#### OOCSS方法

Object-Oriented CSS，面向对象的 CSS

```html
<div class="toggle simple">
       <div class="toggle-control open">
         <h1 class="toggle-title">Title 1</h1>
       </div>
       <div class="toggle-details open"> ... </div>

```

**有两个主要的原则:分离结构和外观，以及分离容器和内容**

- 分离结构和外观
  - 将视觉特性定义为可复用的单元
  - 例如，当前的“simple”皮肤使用直角，而“complex”皮肤可能使用圆角，还加了阴影
- 分离容器和内容
  - 不再将元素位置作为样式的限定词
  - 如 toggle-title，它应用于相应的文本处理上，而不管这个文本的元素是什么

#### SMACSS方法

Scalable and Modular Architecture for CSS，模块化 架构的可扩展 CSS;**把样式系统划分为五个具体类别**

```html
<div class="toggle toggle-simple">
       <div class="toggle-control is-active">
         <h2 class="toggle-title">Title 1</h2>
       </div>
       <div class="toggle-details is-active">
         ...
</div>
... </dl>
```

- 基础

  - 如果不添加 CSS 类名，标记会以什么外观呈现
- 布局

  - 把页面分成一些区域
- 模块

  - 设计中的模块化、可复用的单元
- 状态

  - 描述在特定的状态或情况下，模块或布局的显示方式
- 主题
  - 一个可选状态的视觉外层,可以更换不同主题

#### OOCSS方法与SMACSS方法联系与区别

于如何创建功能的小模块，OOCSS和 SMACSS 有许多相似之处。它们都把样式作用域限定到根节点的 CSS 类名上，然后通过皮肤(OOCSS)或者子模块(SMACSS)进行修改;

**两者之间最显著的差异是使用皮肤而不是子模块，以及带 is 前缀的状态类名**

#### BEM 方法

素名加在双
下划线后(例如 toggle__details)，修饰符加在双横杠后(如 toggle__details--active)。这里的 details 是元素，active 是修饰符，这个约定使得 CSS 类名非常清晰。使用双横杠是为了避免块名被混淆为修饰符

```html
<div class="toggle toggle--simple">
       <div class="toggle__control toggle__control--active">
         <h2 class="toggle__title">Title 1</h2>
         </div>
         <div class="toggle__details toggle__details--active">
           ...
</div>
... </dl>
```

- 块名 
  - 所属组件的名称。 

- 元素 
  - 元素在块里面的名称。 

- 修饰符 

  - 任何与块或元素相关联的修饰符

码中没有 open 或者 is-active 这样只在特定背景下才能理解的 CSS 类名。如果单独看 open 和 is-active 这两个名字，我们并不知道它们的含义是什么。虽然 BEM方法看起来很累赘、很冗余 ，但是当看到一个 toggle__details--active 的 CSS 类名，我们就知道它是表示:这个元素的名称是 details，位置在 toggle 组件里，状态为激活

## css

### 特性之争与继承之痛

在同一个样式,如果其他地方需要用到时,会使用继承覆盖

```css
<style> 
h2 {
	font-size: 24px;
	color: red; 
}
#sidebar h2 { 
    font-size: 20px; 
    background: red; 
    color: white;
} 
</style>
<style> 
h2 {
	font-size: 24px;
	color: red;
}
#sidebar h2 {
    font-size: 20px; 
    background: red; 
    color: white;
}
#sidebar .calendar h2 { 
    background: none;
    color: red;
} </style>
```

- **选择器优先级** 
  - 无论你处理带 ID 的标签还是长选择器，**重写一个选择器时，总是需要注意它的优先级**。 
- **颜色重置** 
  - 要恢复到原来的 H2 颜色，我们必须再次指定样式，并且要覆盖当前的背景颜色。
- **位置依赖** 
  - 移动其他位置样式会无效.

- **多重继承** 
  - 现在这个H2的样式来源多达三个，这意味着只要改变主体或侧边栏的样式都会影响 
- **深层嵌套** 
  - 同个标签样式来源较多

### 模块化的方法

#### OOCSS

分离容器和内容的思想;不再使用位置作为样式的限定词;边栏的样式不应该影响侧边栏的内容。#sidebar h2意味着，放在侧边栏的每一个H2元素，要么接受这个样式，要么就重写来避免使用这个样式。而 .my-sidebar-widget-heading 意味着样式只限定于这一个标题，完全不会影响其他标题

#### SMACSS

把布局和组件分离到不同文件夹的思想，进一步模块划分开。现在我们只是定义了侧边栏的角色是布局，甚至不允许元素样式在那部分Sass 语法的代码里出现。如果你要在侧边栏里放一些代码，**并且向它们添加样式，那么这些元素需要是某个组件的一部分，并且需要在组件的文件夹里定义**

#### BEM

**标记中每个 CSS 类名一个独一无二的标识是有价值**。这是因为这样会使每个BEM 风格的 CSS 类名都可以对应到某一组独属于该元素的 CSS 属性，而不会随着具体情境或选择器的使用而变化

- 选择器优先级 
  - 把 ID 选择器改成 CSS 类名选择器是一个很好的开始，这样可以停止 CSS 优先级之间 的冲突问题，**让每一个选择器的权重扁平化成“1”，我们就不再需要利用优先级较量出 “胜利者”来决定样式**。 

- 颜色重置 
  - 比降低权重更好的方法是对每一个元素使用唯一的选择器。**这样模块样式就不再会与侧边栏样式或者页面通用样式冲突了。**

- 位置依赖 
  - 去掉布局文件中的样式代码之后，**我们就不用再担心组件移出侧边栏而造成样式改变了。**

- 多重继承 
  - 每个标题都有了自己唯一的 CSS 类名之后，我们就可以任意修改其中的某个样式而不 会影响其他标题了。如果你想改变多个选择器对应的样式，可以使用预处理器变量、混 入(mixin)或继承来帮你做。 

### 其他原则

#### 单一职责原则

规定你创建的所有东西必须有单一的、高度聚焦的理由

```css
<style>
.primary-header {
   color: red;
   font-size: 2em;
}
.blog .primary-header {
   font-size: 2.4em;
}
// 改成
.calendar-header {
	color: red;
    font-size: 2em;
 }
.blog-header {
   	color: red;
    font-size: 2.4em;
}
</style>
```

虽然这种方法确实会导致一些代码重复(红色字体定义了两次)，但是它的可持续性带来的好处大大超过代码重复的任何坏处。这里多出来的代码对网页大小的增加而言微不足道 (gzip 喜欢重复的内容)，而且由于博客标题不一定一直保持红色，如果整个项目强制执行 单一责任原则，**就能够确保在进一步改变时，我们可以毫不费力地完成，并且也不需要回顾之前的代码** 

#### 单一样式来源

**将单一责任理论应用到更深层次，不仅每个 CSS 类名被创建为单一用途，而且每个标签的样式也只有单一的来源。在一个模块化设计中，任何组件的设计必须由组件本身决定，而不应该被它的父类名限制**

```css
<style>
/* calendar.css */
.calendar-header {
	color: red;
	font-size: 2em;
}
/* blog.css */
.blog-header {
    color: red;
	font-size: 2.4em;
}
.blog .calendar-header { 
    font-size: 1.6em;
}
// 改成
/* calendar.css */
.calendar-header {
	color: red;
	font-size: 2em; 
}
.blog .calendar-header { 
    font-size: 1.6em;
}
/* blog.css */
.blog-header {
	color: red;
	font-size: 2.4em; 
}
</style>
```

#### 组件修饰符

能够定义一个组件在多个不同情况下的多种变化。它的工作方式和单一样式的来源方法非常相似，但是修饰符类名的属性不再是父组件，而是组件本身的一部分

```css
<style>
/* calendar.css */
.calendar-header {
	color: red;
	font-size: 2em; 
}
.calendar--nested .calendar-header { 
    font-size: 1.6em;
}
/* blog.css */
.blog-header {
	color: red;
	font-size: 2.4em; 
}
</style>
```

这保证了所有组件的变动都在一个文件里，而且能用到任何需要的地方(或者不使用它们)，而不依赖于不确定的父节点 CSS 类名

## javascritp

根据项目情况,适合的选择框架或者是简洁的JavaScript;当遇到难以手动实现的需求，并且已经有开源项目或软件可以解决问题时，再开始评估第三方工具

### 维护整洁的JavaScript代码

#### 保持代码简洁

如果你在 JavaScript 代 码里添加了太多的逗号或者忘记闭合大括号，整个网站都有可能崩溃。 由于编写恰当的 JavaScript 非常关键，最好在项目中结合单元测试使用一些格式 / 错误提 示工具;

比如:

JS Hint(http://jshint.com/)是这些工具中一个很好的例子。它能够在你的文本编辑器里使
用，一旦你犯错，它就会即时标记出来。你甚至可以把它用在构建系统中，这样如果有任
何代码不符合规范，将无法通过测试

有几条可以使用 JS Hint 检查的规则

- 强制使用===和!==代替==和!= • 限制代码块嵌套深度、
- 限制函数的参数数量
- 如果函数重复定义，发出警告
-  如果变量创建后未被使用，发出警告 

#### 创造可复用的函数

把相同代码抽象出来,形成可复用的函数或者是方法,

优点

- 现在有了清晰地说明用途的函数 

- 如果需要创建新的 .green-alert 类名，只需要修改定义好的 add_background() 和 log_ 

  text_on_click 函数 

- 如 果 需 要 将 console.log($(this).html()); 改 成 console.log($(this).text());， 只 需 要在一个位置修改，而不是多个位

- 可以在项目里的很多地方复用这两个函数

# 项目代码

## 过度依赖

基础样式与核心样式加载繁琐、太多;

虽然一般来说，每块内容都有一个单独的关联文件，但这个文件绝不是这块内容的单一
样式来源。样式不仅来源位置多样，**并且常常基于位置和页面的类被覆盖重写**

## 严重位置依赖

一般**标记命名方法都是按照内容块的层级顺序自上而下添加;**

```css
.about-contact .hero1 .container >
section.features-quarter >
section.f-contact h3
```

这个样式**不仅被局限在一个页面里(about-contact)，而且我们还需要确认 features-quarter 部分是容器标签的直接后代，这样才不会不小心把样式添加到其他部分的元素的后代上**。这种自上而下的样式命名方法意味着，**每次修改我们都要写一个更长、更具体的选择器。同时，因为标记顺序极为严格，每块内容都很难重排或替**

当然，我们可以抽出一个单独的组件，并把它需要的所有样式合并到一个单独的文件里，但是这么做基本意味着完全重做这个组件里的 Sass 文件，而且这么做也并没有真的实现标记的模块化

## 设计分解

需要做到正真的模块化,需要是把设计分解成尽可能小的单位;我们知道，一旦有了建造设计系统的基本构件，就可以创造任何视觉语言所能传达的东西

## 组件分类

**组件只描述了一小块内容的视觉外观。组件很灵活，没有任何背景、宽度、内边距、外边距等设置;**

布局和组件之间的关系有着强大的威力，我们把三个组件放在一个三列布局中，不需要写代码就能让它们看起来浑然一体

当意识到这个强大的系统是基于一些简单也非常重要的规则和关系时，我们把它们整理成更加正式的形式

## 编写属于自己的规则

当规则数目达到了两位数，我发 现每写一条规则，我都会想出两条、三条甚至更多的规则;**意识到我根本不是在制定规则，而是在写整个系统的说明文档，然而问题是我已经写过文档了;**

需要的**是精简的、固定的规则列表，而不是一个完全展开的详细说明**;

### 规则时需遵循的规范

- 只包含不可变的规则，而不是笼统的说明
- 总是把规则提炼成最简单的表达
- 总是首先说明规则是什么，再说明“如果不这样，那么会如何”
- 每个规则必须包含以下词中的一个——**总是、永远不要、只有、每一个、不要、要**

使用这些规则可以帮助我们避免写了很多内容却始终说不到点子上;

### 设计系统的规则列表

- 永远不要给**布局的子内容强加内边距和元素样式**。**布局只关注垂直对齐、水平对齐和文字间距**。 
- **主题和别的数据属性值**永远**不要强制改变外观**;它们**必须保持布局、组件和元素可以应]用于其上**。 
- **组件总是贴着它的父容器的四个边，元素都没有上外边距和左外边距，所有的最后节点 (最右边和最下边的节点)的外边距都会被清除。** 
- **组件本身永远不要添加背景、宽度、浮动、内边距和外边距的样式，组件样式是组件内元素的样式**。 
- **每个元素都有且只有一个唯一的且作用域只在组件内的 CSS 类名。所有的样式都是直接应用到这个选择器上，并且只有上下文和主题能修改元素的样式。** 
- **永远不要在元素上使用上外边距，第一个元素总是贴着它所在组件的顶部**。 
- **JavaScript 永远不要绑定任何元素的 CSS 类名，选中元素通过数据属性实现** 

## 每个标签指定一个唯一的选择器

当我们花费较多时间去创造更多、通用的、万能的、可以应用到任意元素上的css类时,**这些 CSS 类具有通用性，改动了样式有可能会影响到很多地方**，所以创造新的 CSS 类往往比更新原有的 CSS 类更容易;因此，**给每一个元素创造单一的、唯一的、扁平的 CSS 类是我最想做的事情之一**

这个就是原则是我们履行“**每个元素都有且只有一个唯一的、作用域只在组件内的 CSS 类名**”规则

### 单一原则

意味着每个 CSS 类都有一个简单的、高度聚焦的责任，所以在某个场景下，**用一个 CSS 类来设置元素的盒模型的属性**，另一个设置排版，还有一个设置颜色和背景;我们创建的每一个 **CSS 类都用于单一的目的和单一的位置**

会确保每个 CSS 类只为一个目的而创建，也只会用于这一个目的，**因为我们不想滥用级联的选择器**

### 样式只有单一的来源

一旦页面的每个元素都只有唯一的 CSS 类,但是担心的是这个类也在其他地方使用;因此,最好保持每个组件和每个元素的样式保持单一来源;

这并不是说我们的标题不能被外力所改变，而是说，**修饰符与上下文对标签样式的任何改变都会和标签的原始样式定义在同一个地方，而不会分散在不同文件**

### 可选的修饰符

虽然BEM、SMACSS 和 OOCSS 都有关于修饰符、主题、皮肤的规定，但它们都需要添加变更的 CSS 类到内容块或者元素上;

尽量做到"**让一件东西只是它本身。我不想让任何人混淆**"

**所有的修饰符都用数据属性代替**

```html
<div class="foo" data-bar="baz">...</div>
```

除了能够区分角色和目的，这么做的另一个好处是，

**CSS 类的属性都是一维的:应用状态或非应用状态**。

而**数据属性是二维的，有数据属性本身和通过它传递的值**。

为了补偿 CSS类缺少的维度，你会经常发现 CSS 类会使用命名空间来定义该标签属于哪个分组。一个数据属性有明确的命名空间，因此我们可以给它传递任何必要的值。虽然传递的值可能只是几个字符，**但使用数据属性本身就能够强调组件拥有 data-align 属性，并且我们可以给它赋各种各样的值**

### 可选上下文

组件可以根据所在的**父级元素或者父级元素的某些数据属性来改变自身的表现**

这些可选的上下文允许我们给任何组件创建变动，而不影响组件的原始样式。这些变动都是可控的，作用域限制在组件的 CSS 类中 

如果**让同一个修饰符和上下文影响多个组件，这的确需要我们做一些重复的工作**。但随着系统规模日渐扩展，我从来没有后悔过。不仅因为通过混入(mixin)和扩展(extend)让复用修饰符和上下文变得更简单，**而且组件变动的数量有限，这帮助我们避免了找错难的问题，也帮助我们提高了创造更全面的视觉还原的能力**

## 语义化网格

模块数量比较少时，我们会给每个版块写样式，包括版块的布局。如果要做一个充满商标的版块，我们会给这个版块一个 CSS 类名称，然后明确地给这个版块应用一个布局。这个方案的问题是，**除了整个版块其他的都不可复用。所以如果有别的版块用到了相同的布局但不同的内容，我们就不得不创建一个全新的版块以及重写布局样式**

创造一组可以通过数据属性的值来应用的常用网格布局方式;**只要在父节点的标签上设置布局属性，所有的子标签都会应用相应的网格布局类型**。**这种方法让我们不仅可以将布局和组件分离开，同时还可以在标记上设置网格布局**

# 任务处理器

## 在任务处理器中完成一切

使用基于 Node.js 的任务处理器;这些模块为我的工作流提供了各种各样的功能,例如是:Grunt、Gulp、Webpack

- 安装需要的 Ruby 库和 Bower 安装包 
- 清理临时文件夹 
- 创建软连接 
- 编译 Sass 
- 合并 JavaScript 
- 加载第三方 JavaScript 库 
- 把 SVG 文件编译成图标字体 
- 对图片进行处理，减少文件体积，裁剪成各种尺寸 
- 同步文件到远程服务器 
- 创建 Git 标签 
- 运行可视化的回归测试 
- 生成代码的样式文档 
- 自动生成浏览器厂商的前缀 
- 编译组件库 
- 优化我的 Sass、CSS、JavaScript、JSON，等等 
- 基于 JSON 模式来验证数据 
- 启动 Node 和 PHP 服务器 
- 监听文件改动来刷新浏览器 

任务处理器只是一个工具。前端架构师的职责在于创建高效且抗差错的工作流。因此，如果你的工具能帮助开发人员快速地运作起来，让他们在健壮的环境中编写高质量的代码，然后把代码部署到测试、预发布和正式发布环境

# 单元测试

是将应用程序分解为尽可能小的函数,并创建可重复的、自动化的测试用例的过程.在同等条件下,这些测试用例应该一直产生相同的结果,他们是应用程序的灵魂,并为今后所有应用程序的代码提供构建的基础.

## 单元

**“一次只做一件事，并把它做好”是构建基于单元测试的应用程序的原则**;在写函数时经常想同时实现很多功能，结果最后不仅降低了效率，还增加了测试的难度，因为这样的函数无法复用

## 测试驱动开发

可能写过一些功能代码以满足业务需求(比如上文中的计算运费的例子)，然后也努力地将它重构为更小的、可重用的、可测试的代码，之后才去思考如何写测试用例。**测试驱动的开发(test-driven development，TDD)则颠倒了这一思路，它将单元测试放在第一位，之后才是编写功能代码**

## 测试覆盖率要多大才够

确定合适的测试覆盖率是很难权衡的一件事情;如果测试所有代码,开发进度可能停滞不前;而如果测试不够,就有遗漏新问题的风险.

### 解决分歧点

测试覆盖率的好处是,即使一个单一的测试也能够为系统建设作贡献;

在决定从哪开始编写单元测试时,**可以能够获取最大收益的地方开始**;有时,最大的收益就是为系统最简单的部分编写单元测试

### 从测试覆盖率开始

如果有全新启动的新项目;需要确保任何需要测试的需求都有额外的的时间来编写单元测试,并且确认所需的测试覆盖率.

如果一个新功能需要花费 8 个小时开发完成，我们要确保另外预留 2 个小时来编写用例并验证测试覆盖率。预留的时间通常很难争取，因此前端架构师通常需要扮演起外交人员和销售人员的角色。**尽管这样会多花费 25% 的时间，但我**
**们知道这其实会节省很多后续回头追查 bug 的时间;**

**并不是所有的功能都需要同样的测试覆盖率。但前提是，每一个用户故事都是以测试覆盖率的相关任务作为开始**



