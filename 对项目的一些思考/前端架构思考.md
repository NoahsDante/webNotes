前端架构原则

前端架构是一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效、可持续的工作流

## 体系设计

通过设计所有前端开发人员都要遵循的系统规范,**前端架构师清晰描绘出产品与代码的最终形态**;一旦前端架构师建立起来系统设计规范,项目拥有了可以衡量代码质量的标准;并做出适当的取舍,以保证系统中的代码有实质的价值,**而不是简单的堆砌**

## 工作规划

有了清晰的结构设计后,就需要制定开发工作流程了;**设计出能流畅运转饿系统,能发幅度减少由于重复操作而产生的认为错**误.

## 监督跟进

能够持续地优化工作流程;**前端开发人员面向终端用户写代码,而前端架构师面向的是团队里的开发人员**

# 前端架构核心

## 代码

专注于如何实现系统架构中的 HTML、CSS 和 JavaScript

## 流程

在重要的是思考怎么用工具和流程构建一个高效且避免出错的工作流;提高生产力、加快效率和保持代码一致性

## 测试

构建一个可扩展和可持续优化的系统，必须保证新代码与老代码能够很好地兼容。我们的代码不会独立存在

## 文档
需要编写的各种文档类型、发布文档的工具，以及阅读这些文档的用户角色

# 代码

## HTML

### 程序式标记:自动化程度100%，可控程度0%

html统一由后端生成,如CMS编辑

```html
<div id="header" class="clearfix">
       <div id="header-screen" class="clearfix">
         <div id="header-inner" class="container-12 clearfix">
           <div id="nav-header" role="navigation">
             <div class="region region-navigation">
               <div class="block block-system block-menu">
                 <div class="block-inner">
                   <div class="content">
                     <ul class="menu">
                       <li class="first leaf">
                         <a href="/start">Get Started</a>
```

"div乱锅杂炖";有助于我们把静态 Photoshop 图像做成标记化的页面;div嵌套层级太深;不利于语义话;

### 静态标记:自动化程度0%，可控程度100%

任务只是开发一个需要填充一大块主体区域的页面，那么编写静态标记更为方便; 种情况灵活性很大，但是也意味着我们必须负责维护所有的代码

```html
<header>
       <section>
<nav> 
    <div>
	<ul> 
   		 <li>
             <a href="/products">Products</a>
                <ul>
                  <li>
                    <a href="/socks">Socks</a>
                       
 header > section > nav > div > ul > li > a {
       color: white;
     }
     header > section > nav > div > ul > li > ul > li > a  {
       color: blue;
     }                      
```

为了保持简洁，“语义化”的标记是首选，应用样式所依靠的是 HTML5 元素名称和它们的层级关系，而非 CSS 类名;但所选择器过长,不利于样式编写与覆盖.

### 模块化标记:自动化程度100%，可控程度100%

模块化标记和程序化标记的区别在于，**对于使用什么标记输出既定内容，我们不会完全任由 CMS 决定**。这使得我们可为两个不同的导航实例使用一样的标记，虽然 CMS 生成的标记可能完全不一样。

模块化标记和静态化标记的区别在于，程序化地执行完之后，**我们还可以通过一套类名系统给标记动态添加 CSS 类名，并且不再通过元素标签和层级关系来决定视觉外观**

### 模块化CSS理论的多面性

例如使用新的命名空间、扩充数据属性，甚至是在JavaScript 里定义 CSS;

#### OOCSS方法

Object-Oriented CSS，面向对象的 CSS

```html
<div class="toggle simple">
       <div class="toggle-control open">
         <h1 class="toggle-title">Title 1</h1>
       </div>
       <div class="toggle-details open"> ... </div>

```

**有两个主要的原则:分离结构和外观，以及分离容器和内容**

- 分离结构和外观
  - 将视觉特性定义为可复用的单元
  - 例如，当前的“simple”皮肤使用直角，而“complex”皮肤可能使用圆角，还加了阴影
- 分离容器和内容
  - 不再将元素位置作为样式的限定词
  - 如 toggle-title，它应用于相应的文本处理上，而不管这个文本的元素是什么

#### SMACSS方法

Scalable and Modular Architecture for CSS，模块化 架构的可扩展 CSS;**把样式系统划分为五个具体类别**

```html
<div class="toggle toggle-simple">
       <div class="toggle-control is-active">
         <h2 class="toggle-title">Title 1</h2>
       </div>
       <div class="toggle-details is-active">
         ...
</div>
... </dl>
```

- 基础

  - 如果不添加 CSS 类名，标记会以什么外观呈现
- 布局

  - 把页面分成一些区域
- 模块

  - 设计中的模块化、可复用的单元
- 状态

  - 描述在特定的状态或情况下，模块或布局的显示方式
- 主题
  - 一个可选状态的视觉外层,可以更换不同主题

#### OOCSS方法与SMACSS方法联系与区别

于如何创建功能的小模块，OOCSS和 SMACSS 有许多相似之处。它们都把样式作用域限定到根节点的 CSS 类名上，然后通过皮肤(OOCSS)或者子模块(SMACSS)进行修改;

**两者之间最显著的差异是使用皮肤而不是子模块，以及带 is 前缀的状态类名**

#### BEM 方法

素名加在双
下划线后(例如 toggle__details)，修饰符加在双横杠后(如 toggle__details--active)。这里的 details 是元素，active 是修饰符，这个约定使得 CSS 类名非常清晰。使用双横杠是为了避免块名被混淆为修饰符

```html
<div class="toggle toggle--simple">
       <div class="toggle__control toggle__control--active">
         <h2 class="toggle__title">Title 1</h2>
         </div>
         <div class="toggle__details toggle__details--active">
           ...
</div>
... </dl>
```

- 块名 
  - 所属组件的名称。 

- 元素 
  - 元素在块里面的名称。 

- 修饰符 

  - 任何与块或元素相关联的修饰符

码中没有 open 或者 is-active 这样只在特定背景下才能理解的 CSS 类名。如果单独看 open 和 is-active 这两个名字，我们并不知道它们的含义是什么。虽然 BEM方法看起来很累赘、很冗余 ，但是当看到一个 toggle__details--active 的 CSS 类名，我们就知道它是表示:这个元素的名称是 details，位置在 toggle 组件里，状态为激活

## css

### 特性之争与继承之痛

在同一个样式,如果其他地方需要用到时,会使用继承覆盖

```css
<style> 
h2 {
	font-size: 24px;
	color: red; 
}
#sidebar h2 { 
    font-size: 20px; 
    background: red; 
    color: white;
} 
</style>
<style> 
h2 {
	font-size: 24px;
	color: red;
}
#sidebar h2 {
    font-size: 20px; 
    background: red; 
    color: white;
}
#sidebar .calendar h2 { 
    background: none;
    color: red;
} </style>
```

- **选择器优先级** 
  - 无论你处理带 ID 的标签还是长选择器，**重写一个选择器时，总是需要注意它的优先级**。 
- **颜色重置** 
  - 要恢复到原来的 H2 颜色，我们必须再次指定样式，并且要覆盖当前的背景颜色。
- **位置依赖** 
  - 移动其他位置样式会无效.

- **多重继承** 
  - 现在这个H2的样式来源多达三个，这意味着只要改变主体或侧边栏的样式都会影响 
- **深层嵌套** 
  - 同个标签样式来源较多

### 模块化的方法

#### OOCSS

分离容器和内容的思想;不再使用位置作为样式的限定词;边栏的样式不应该影响侧边栏的内容。#sidebar h2意味着，放在侧边栏的每一个H2元素，要么接受这个样式，要么就重写来避免使用这个样式。而 .my-sidebar-widget-heading 意味着样式只限定于这一个标题，完全不会影响其他标题

#### SMACSS

把布局和组件分离到不同文件夹的思想，进一步模块划分开。现在我们只是定义了侧边栏的角色是布局，甚至不允许元素样式在那部分Sass 语法的代码里出现。如果你要在侧边栏里放一些代码，**并且向它们添加样式，那么这些元素需要是某个组件的一部分，并且需要在组件的文件夹里定义**

#### BEM

**标记中每个 CSS 类名一个独一无二的标识是有价值**。这是因为这样会使每个BEM 风格的 CSS 类名都可以对应到某一组独属于该元素的 CSS 属性，而不会随着具体情境或选择器的使用而变化

- 选择器优先级 
  - 把 ID 选择器改成 CSS 类名选择器是一个很好的开始，这样可以停止 CSS 优先级之间 的冲突问题，**让每一个选择器的权重扁平化成“1”，我们就不再需要利用优先级较量出 “胜利者”来决定样式**。 

- 颜色重置 
  - 比降低权重更好的方法是对每一个元素使用唯一的选择器。**这样模块样式就不再会与侧边栏样式或者页面通用样式冲突了。**

- 位置依赖 
  - 去掉布局文件中的样式代码之后，**我们就不用再担心组件移出侧边栏而造成样式改变了。**

- 多重继承 
  - 每个标题都有了自己唯一的 CSS 类名之后，我们就可以任意修改其中的某个样式而不 会影响其他标题了。如果你想改变多个选择器对应的样式，可以使用预处理器变量、混 入(mixin)或继承来帮你做。 

### 其他原则

#### 单一职责原则

规定你创建的所有东西必须有单一的、高度聚焦的理由

```css
<style>
.primary-header {
   color: red;
   font-size: 2em;
}
.blog .primary-header {
   font-size: 2.4em;
}
// 改成
.calendar-header {
	color: red;
    font-size: 2em;
 }
.blog-header {
   	color: red;
    font-size: 2.4em;
}
</style>
```

虽然这种方法确实会导致一些代码重复(红色字体定义了两次)，但是它的可持续性带来的好处大大超过代码重复的任何坏处。这里多出来的代码对网页大小的增加而言微不足道 (gzip 喜欢重复的内容)，而且由于博客标题不一定一直保持红色，如果整个项目强制执行 单一责任原则，**就能够确保在进一步改变时，我们可以毫不费力地完成，并且也不需要回顾之前的代码** 

#### 单一样式来源

将单一责任理论应用到更深层次，不仅每个 CSS 类名被创建为单一用途，而且每个标签的样式也只有单一的来源。在一个模块化设计中，任何组件的设计必须由组件本身决定，而不应该被它的父类名限制

```css
<style>
/* calendar.css */
.calendar-header {
	color: red;
	font-size: 2em;
}
/* blog.css */
.blog-header {
    color: red;
	font-size: 2.4em;
}
.blog .calendar-header { 
    font-size: 1.6em;
}
// 改成
/* calendar.css */
.calendar-header {
	color: red;
	font-size: 2em; 
}
.blog .calendar-header { 
    font-size: 1.6em;
}
/* blog.css */
.blog-header {
	color: red;
	font-size: 2.4em; 
}
</style>
```

#### 组件修饰符

能够定义一个组件在多个不同情况下的多种变化。它的工作方式和单一样式的来源方法非常相似，但是修饰符类名的属性不再是父组件，而是组件本身的一部分

```css
<style>
/* calendar.css */
.calendar-header {
	color: red;
	font-size: 2em; 
}
.calendar--nested .calendar-header { 
    font-size: 1.6em;
}
/* blog.css */
.blog-header {
	color: red;
	font-size: 2.4em; 
}
</style>
```

这保证了所有组件的变动都在一个文件里，而且能用到任何需要的地方(或者不使用它们)，而不依赖于不确定的父节点 CSS 类名

## javascritp

根据项目情况,适合的选择框架或者是简洁的JavaScript;当遇到难以手动实现的需求，并且已经有开源项目或软件可以解决问题时，再开始评估第三方工具

### 维护整洁的JavaScript代码

#### 保持代码简洁

如果你在 JavaScript 代 码里添加了太多的逗号或者忘记闭合大括号，整个网站都有可能崩溃。 由于编写恰当的 JavaScript 非常关键，最好在项目中结合单元测试使用一些格式 / 错误提 示工具;

比如:

JS Hint(http://jshint.com/)是这些工具中一个很好的例子。它能够在你的文本编辑器里使
用，一旦你犯错，它就会即时标记出来。你甚至可以把它用在构建系统中，这样如果有任
何代码不符合规范，将无法通过测试

有几条可以使用 JS Hint 检查的规则

- 强制使用===和!==代替==和!= • 限制代码块嵌套深度、
- 限制函数的参数数量
- 如果函数重复定义，发出警告
-  如果变量创建后未被使用，发出警告 

#### 创造可复用的函数

把相同代码抽象出来,形成可复用的函数或者是方法,

优点

- 现在有了清晰地说明用途的函数 

- 如果需要创建新的 .green-alert 类名，只需要修改定义好的 add_background() 和 log_ 

  text_on_click 函数 

- 如 果 需 要 将 console.log($(this).html()); 改 成 console.log($(this).text());， 只 需 要在一个位置修改，而不是多个位

- 可以在项目里的很多地方复用这两个函数

# 代码



