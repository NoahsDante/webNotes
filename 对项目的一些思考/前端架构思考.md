# 前端架构原则

前端架构是一系列工具和流程的集合，旨在提升前端代码的质量，并实现高效、可持续的工作流

## 体系设计

通过设计所有前端开发人员都要遵循的系统规范,**前端架构师清晰描绘出产品与代码的最终形态**;一旦前端架构师建立起来系统设计规范,项目拥有了可以衡量代码质量的标准;并做出适当的取舍,以保证系统中的代码有实质的价值,**而不是简单的堆砌**

## 工作规划

有了清晰的结构设计后,就需要制定开发工作流程了;**设计出能流畅运转饿系统,能发幅度减少由于重复操作而产生的认为错**误.

## 监督跟进

能够持续地优化工作流程;**前端开发人员面向终端用户写代码,而前端架构师面向的是团队里的开发人员**

# 前端架构核心

## 代码

专注于如何实现系统架构中的 HTML、CSS 和 JavaScript

## 流程

在重要的是思考怎么用工具和流程构建一个高效且避免出错的工作流;提高生产力、加快效率和保持代码一致性

## 测试

构建一个可扩展和可持续优化的系统，必须保证新代码与老代码能够很好地兼容。我们的代码不会独立存在

## 文档
需要编写的各种文档类型、发布文档的工具，以及阅读这些文档的用户角色

# 代码

## HTML

### 程序式标记:自动化程度100%，可控程度0%

html统一由后端生成,如CMS编辑

```html
<div id="header" class="clearfix">
       <div id="header-screen" class="clearfix">
         <div id="header-inner" class="container-12 clearfix">
           <div id="nav-header" role="navigation">
             <div class="region region-navigation">
               <div class="block block-system block-menu">
                 <div class="block-inner">
                   <div class="content">
                     <ul class="menu">
                       <li class="first leaf">
                         <a href="/start">Get Started</a>
```

"div乱锅杂炖";有助于我们把静态 Photoshop 图像做成标记化的页面;div嵌套层级太深;不利于语义话;

### 静态标记:自动化程度0%，可控程度100%

任务只是开发一个需要填充一大块主体区域的页面，那么编写静态标记更为方便; 种情况灵活性很大，但是也意味着我们必须负责维护所有的代码

```html
<header>
       <section>
<nav> 
    <div>
	<ul> 
   		 <li>
             <a href="/products">Products</a>
                <ul>
                  <li>
                    <a href="/socks">Socks</a>
                       
 header > section > nav > div > ul > li > a {
       color: white;
     }
     header > section > nav > div > ul > li > ul > li > a  {
       color: blue;
     }                      
```

为了保持简洁，“语义化”的标记是首选，应用样式所依靠的是 HTML5 元素名称和它们的层级关系，而非 CSS 类名;但所选择器过长,不利于样式编写与覆盖.

### 模块化标记:自动化程度100%，可控程度100%

模块化标记和程序化标记的区别在于，**对于使用什么标记输出既定内容，我们不会完全任由 CMS 决定**。这使得我们可为两个不同的导航实例使用一样的标记，虽然 CMS 生成的标记可能完全不一样。

模块化标记和静态化标记的区别在于，程序化地执行完之后，**我们还可以通过一套类名系统给标记动态添加 CSS 类名，并且不再通过元素标签和层级关系来决定视觉外观**

### 模块化CSS理论的多面性

例如使用新的命名空间、扩充数据属性，甚至是在JavaScript 里定义 CSS;

#### OOCSS方法

Object-Oriented CSS，面向对象的 CSS

```html
<div class="toggle simple">
       <div class="toggle-control open">
         <h1 class="toggle-title">Title 1</h1>
       </div>
       <div class="toggle-details open"> ... </div>

```

**有两个主要的原则:分离结构和外观，以及分离容器和内容**

- 分离结构和外观
  - 将视觉特性定义为可复用的单元
  - 例如，当前的“simple”皮肤使用直角，而“complex”皮肤可能使用圆角，还加了阴影
- 分离容器和内容
  - 不再将元素位置作为样式的限定词
  - 如 toggle-title，它应用于相应的文本处理上，而不管这个文本的元素是什么

#### SMACSS方法

Scalable and Modular Architecture for CSS，模块化 架构的可扩展 CSS;**把样式系统划分为五个具体类别**

```html
<div class="toggle toggle-simple">
       <div class="toggle-control is-active">
         <h2 class="toggle-title">Title 1</h2>
       </div>
       <div class="toggle-details is-active">
         ...
</div>
... </dl>
```

- 基础

  - 如果不添加 CSS 类名，标记会以什么外观呈现
- 布局

  - 把页面分成一些区域
- 模块

  - 设计中的模块化、可复用的单元
- 状态

  - 描述在特定的状态或情况下，模块或布局的显示方式
- 主题
  - 一个可选状态的视觉外层,可以更换不同主题

#### OOCSS方法与SMACSS方法联系与区别

于如何创建功能的小模块，OOCSS和 SMACSS 有许多相似之处。它们都把样式作用域限定到根节点的 CSS 类名上，然后通过皮肤(OOCSS)或者子模块(SMACSS)进行修改;

**两者之间最显著的差异是使用皮肤而不是子模块，以及带 is 前缀的状态类名**

#### BEM 方法

素名加在双
下划线后(例如 toggle__details)，修饰符加在双横杠后(如 toggle__details--active)。这里的 details 是元素，active 是修饰符，这个约定使得 CSS 类名非常清晰。使用双横杠是为了避免块名被混淆为修饰符

```html
<div class="toggle toggle--simple">
       <div class="toggle__control toggle__control--active">
         <h2 class="toggle__title">Title 1</h2>
         </div>
         <div class="toggle__details toggle__details--active">
           ...
</div>
... </dl>
```

- 块名 
  - 所属组件的名称。 

- 元素 
  - 元素在块里面的名称。 

- 修饰符 

  - 任何与块或元素相关联的修饰符

码中没有 open 或者 is-active 这样只在特定背景下才能理解的 CSS 类名。如果单独看 open 和 is-active 这两个名字，我们并不知道它们的含义是什么。虽然 BEM方法看起来很累赘、很冗余 ，但是当看到一个 toggle__details--active 的 CSS 类名，我们就知道它是表示:这个元素的名称是 details，位置在 toggle 组件里，状态为激活

## css

### 特性之争与继承之痛

在同一个样式,如果其他地方需要用到时,会使用继承覆盖

```css
<style> 
h2 {
	font-size: 24px;
	color: red; 
}
#sidebar h2 { 
    font-size: 20px; 
    background: red; 
    color: white;
} 
</style>
<style> 
h2 {
	font-size: 24px;
	color: red;
}
#sidebar h2 {
    font-size: 20px; 
    background: red; 
    color: white;
}
#sidebar .calendar h2 { 
    background: none;
    color: red;
} </style>
```

- **选择器优先级** 
  - 无论你处理带 ID 的标签还是长选择器，**重写一个选择器时，总是需要注意它的优先级**。 
- **颜色重置** 
  - 要恢复到原来的 H2 颜色，我们必须再次指定样式，并且要覆盖当前的背景颜色。
- **位置依赖** 
  - 移动其他位置样式会无效.

- **多重继承** 
  - 现在这个H2的样式来源多达三个，这意味着只要改变主体或侧边栏的样式都会影响 
- **深层嵌套** 
  - 同个标签样式来源较多

### 模块化的方法

#### OOCSS

分离容器和内容的思想;不再使用位置作为样式的限定词;边栏的样式不应该影响侧边栏的内容。#sidebar h2意味着，放在侧边栏的每一个H2元素，要么接受这个样式，要么就重写来避免使用这个样式。而 .my-sidebar-widget-heading 意味着样式只限定于这一个标题，完全不会影响其他标题

#### SMACSS

把布局和组件分离到不同文件夹的思想，进一步模块划分开。现在我们只是定义了侧边栏的角色是布局，甚至不允许元素样式在那部分Sass 语法的代码里出现。如果你要在侧边栏里放一些代码，**并且向它们添加样式，那么这些元素需要是某个组件的一部分，并且需要在组件的文件夹里定义**

#### BEM

**标记中每个 CSS 类名一个独一无二的标识是有价值**。这是因为这样会使每个BEM 风格的 CSS 类名都可以对应到某一组独属于该元素的 CSS 属性，而不会随着具体情境或选择器的使用而变化

- 选择器优先级 
  - 把 ID 选择器改成 CSS 类名选择器是一个很好的开始，这样可以停止 CSS 优先级之间 的冲突问题，**让每一个选择器的权重扁平化成“1”，我们就不再需要利用优先级较量出 “胜利者”来决定样式**。 

- 颜色重置 
  - 比降低权重更好的方法是对每一个元素使用唯一的选择器。**这样模块样式就不再会与侧边栏样式或者页面通用样式冲突了。**

- 位置依赖 
  - 去掉布局文件中的样式代码之后，**我们就不用再担心组件移出侧边栏而造成样式改变了。**

- 多重继承 
  - 每个标题都有了自己唯一的 CSS 类名之后，我们就可以任意修改其中的某个样式而不 会影响其他标题了。如果你想改变多个选择器对应的样式，可以使用预处理器变量、混 入(mixin)或继承来帮你做。 

### 其他原则

#### 单一职责原则

规定你创建的所有东西必须有单一的、高度聚焦的理由

```css
<style>
.primary-header {
   color: red;
   font-size: 2em;
}
.blog .primary-header {
   font-size: 2.4em;
}
// 改成
.calendar-header {
	color: red;
    font-size: 2em;
 }
.blog-header {
   	color: red;
    font-size: 2.4em;
}
</style>
```

虽然这种方法确实会导致一些代码重复(红色字体定义了两次)，但是它的可持续性带来的好处大大超过代码重复的任何坏处。这里多出来的代码对网页大小的增加而言微不足道 (gzip 喜欢重复的内容)，而且由于博客标题不一定一直保持红色，如果整个项目强制执行 单一责任原则，**就能够确保在进一步改变时，我们可以毫不费力地完成，并且也不需要回顾之前的代码** 

#### 单一样式来源

**将单一责任理论应用到更深层次，不仅每个 CSS 类名被创建为单一用途，而且每个标签的样式也只有单一的来源。在一个模块化设计中，任何组件的设计必须由组件本身决定，而不应该被它的父类名限制**

```css
<style>
/* calendar.css */
.calendar-header {
	color: red;
	font-size: 2em;
}
/* blog.css */
.blog-header {
    color: red;
	font-size: 2.4em;
}
.blog .calendar-header { 
    font-size: 1.6em;
}
// 改成
/* calendar.css */
.calendar-header {
	color: red;
	font-size: 2em; 
}
.blog .calendar-header { 
    font-size: 1.6em;
}
/* blog.css */
.blog-header {
	color: red;
	font-size: 2.4em; 
}
</style>
```

#### 组件修饰符

能够定义一个组件在多个不同情况下的多种变化。它的工作方式和单一样式的来源方法非常相似，但是修饰符类名的属性不再是父组件，而是组件本身的一部分

```css
<style>
/* calendar.css */
.calendar-header {
	color: red;
	font-size: 2em; 
}
.calendar--nested .calendar-header { 
    font-size: 1.6em;
}
/* blog.css */
.blog-header {
	color: red;
	font-size: 2.4em; 
}
</style>
```

这保证了所有组件的变动都在一个文件里，而且能用到任何需要的地方(或者不使用它们)，而不依赖于不确定的父节点 CSS 类名

## javascritp

根据项目情况,适合的选择框架或者是简洁的JavaScript;当遇到难以手动实现的需求，并且已经有开源项目或软件可以解决问题时，再开始评估第三方工具

### 维护整洁的JavaScript代码

#### 保持代码简洁

如果你在 JavaScript 代 码里添加了太多的逗号或者忘记闭合大括号，整个网站都有可能崩溃。 由于编写恰当的 JavaScript 非常关键，最好在项目中结合单元测试使用一些格式 / 错误提 示工具;

比如:

JS Hint(http://jshint.com/)是这些工具中一个很好的例子。它能够在你的文本编辑器里使
用，一旦你犯错，它就会即时标记出来。你甚至可以把它用在构建系统中，这样如果有任
何代码不符合规范，将无法通过测试

有几条可以使用 JS Hint 检查的规则

- 强制使用===和!==代替==和!= • 限制代码块嵌套深度、
- 限制函数的参数数量
- 如果函数重复定义，发出警告
-  如果变量创建后未被使用，发出警告 

#### 创造可复用的函数

把相同代码抽象出来,形成可复用的函数或者是方法,

优点

- 现在有了清晰地说明用途的函数 

- 如果需要创建新的 .green-alert 类名，只需要修改定义好的 add_background() 和 log_ 

  text_on_click 函数 

- 如 果 需 要 将 console.log($(this).html()); 改 成 console.log($(this).text());， 只 需 要在一个位置修改，而不是多个位

- 可以在项目里的很多地方复用这两个函数

# 项目代码

## 过度依赖

基础样式与核心样式加载繁琐、太多;

虽然一般来说，每块内容都有一个单独的关联文件，但这个文件绝不是这块内容的单一
样式来源。样式不仅来源位置多样，**并且常常基于位置和页面的类被覆盖重写**

## 严重位置依赖

一般**标记命名方法都是按照内容块的层级顺序自上而下添加;**

```css
.about-contact .hero1 .container >
section.features-quarter >
section.f-contact h3
```

这个样式**不仅被局限在一个页面里(about-contact)，而且我们还需要确认 features-quarter 部分是容器标签的直接后代，这样才不会不小心把样式添加到其他部分的元素的后代上**。这种自上而下的样式命名方法意味着，**每次修改我们都要写一个更长、更具体的选择器。同时，因为标记顺序极为严格，每块内容都很难重排或替**

当然，我们可以抽出一个单独的组件，并把它需要的所有样式合并到一个单独的文件里，但是这么做基本意味着完全重做这个组件里的 Sass 文件，而且这么做也并没有真的实现标记的模块化

## 设计分解

需要做到正真的模块化,需要是把设计分解成尽可能小的单位;我们知道，一旦有了建造设计系统的基本构件，就可以创造任何视觉语言所能传达的东西

## 组件分类

**组件只描述了一小块内容的视觉外观。组件很灵活，没有任何背景、宽度、内边距、外边距等设置;**

布局和组件之间的关系有着强大的威力，我们把三个组件放在一个三列布局中，不需要写代码就能让它们看起来浑然一体

当意识到这个强大的系统是基于一些简单也非常重要的规则和关系时，我们把它们整理成更加正式的形式

## 编写属于自己的规则

当规则数目达到了两位数，我发 现每写一条规则，我都会想出两条、三条甚至更多的规则;**意识到我根本不是在制定规则，而是在写整个系统的说明文档，然而问题是我已经写过文档了;**

需要的**是精简的、固定的规则列表，而不是一个完全展开的详细说明**;

### 规则时需遵循的规范

- 只包含不可变的规则，而不是笼统的说明
- 总是把规则提炼成最简单的表达
- 总是首先说明规则是什么，再说明“如果不这样，那么会如何”
- 每个规则必须包含以下词中的一个——**总是、永远不要、只有、每一个、不要、要**

使用这些规则可以帮助我们避免写了很多内容却始终说不到点子上;

### 设计系统的规则列表

- 永远不要给**布局的子内容强加内边距和元素样式**。**布局只关注垂直对齐、水平对齐和文字间距**。 
- **主题和别的数据属性值**永远**不要强制改变外观**;它们**必须保持布局、组件和元素可以应]用于其上**。 
- **组件总是贴着它的父容器的四个边，元素都没有上外边距和左外边距，所有的最后节点 (最右边和最下边的节点)的外边距都会被清除。** 
- **组件本身永远不要添加背景、宽度、浮动、内边距和外边距的样式，组件样式是组件内元素的样式**。 
- **每个元素都有且只有一个唯一的且作用域只在组件内的 CSS 类名。所有的样式都是直接应用到这个选择器上，并且只有上下文和主题能修改元素的样式。** 
- **永远不要在元素上使用上外边距，第一个元素总是贴着它所在组件的顶部**。 
- **JavaScript 永远不要绑定任何元素的 CSS 类名，选中元素通过数据属性实现** 

## 每个标签指定一个唯一的选择器

当我们花费较多时间去创造更多、通用的、万能的、可以应用到任意元素上的css类时,**这些 CSS 类具有通用性，改动了样式有可能会影响到很多地方**，所以创造新的 CSS 类往往比更新原有的 CSS 类更容易;因此，**给每一个元素创造单一的、唯一的、扁平的 CSS 类是我最想做的事情之一**

这个就是原则是我们履行“**每个元素都有且只有一个唯一的、作用域只在组件内的 CSS 类名**”规则

### 单一原则

意味着每个 CSS 类都有一个简单的、高度聚焦的责任，所以在某个场景下，**用一个 CSS 类来设置元素的盒模型的属性**，另一个设置排版，还有一个设置颜色和背景;我们创建的每一个 **CSS 类都用于单一的目的和单一的位置**

会确保每个 CSS 类只为一个目的而创建，也只会用于这一个目的，**因为我们不想滥用级联的选择器**

### 样式只有单一的来源

一旦页面的每个元素都只有唯一的 CSS 类,但是担心的是这个类也在其他地方使用;因此,最好保持每个组件和每个元素的样式保持单一来源;

这并不是说我们的标题不能被外力所改变，而是说，**修饰符与上下文对标签样式的任何改变都会和标签的原始样式定义在同一个地方，而不会分散在不同文件**

### 可选的修饰符

虽然BEM、SMACSS 和 OOCSS 都有关于修饰符、主题、皮肤的规定，但它们都需要添加变更的 CSS 类到内容块或者元素上;

尽量做到"**让一件东西只是它本身。我不想让任何人混淆**"

**所有的修饰符都用数据属性代替**

```html
<div class="foo" data-bar="baz">...</div>
```

除了能够区分角色和目的，这么做的另一个好处是，

**CSS 类的属性都是一维的:应用状态或非应用状态**。

而**数据属性是二维的，有数据属性本身和通过它传递的值**。

为了补偿 CSS类缺少的维度，你会经常发现 CSS 类会使用命名空间来定义该标签属于哪个分组。一个数据属性有明确的命名空间，因此我们可以给它传递任何必要的值。虽然传递的值可能只是几个字符，**但使用数据属性本身就能够强调组件拥有 data-align 属性，并且我们可以给它赋各种各样的值**

### 可选上下文

组件可以根据所在的**父级元素或者父级元素的某些数据属性来改变自身的表现**

这些可选的上下文允许我们给任何组件创建变动，而不影响组件的原始样式。这些变动都是可控的，作用域限制在组件的 CSS 类中 

如果**让同一个修饰符和上下文影响多个组件，这的确需要我们做一些重复的工作**。但随着系统规模日渐扩展，我从来没有后悔过。不仅因为通过混入(mixin)和扩展(extend)让复用修饰符和上下文变得更简单，**而且组件变动的数量有限，这帮助我们避免了找错难的问题，也帮助我们提高了创造更全面的视觉还原的能力**

## 语义化网格

模块数量比较少时，我们会给每个版块写样式，包括版块的布局。如果要做一个充满商标的版块，我们会给这个版块一个 CSS 类名称，然后明确地给这个版块应用一个布局。这个方案的问题是，**除了整个版块其他的都不可复用。所以如果有别的版块用到了相同的布局但不同的内容，我们就不得不创建一个全新的版块以及重写布局样式**

创造一组可以通过数据属性的值来应用的常用网格布局方式;**只要在父节点的标签上设置布局属性，所有的子标签都会应用相应的网格布局类型**。**这种方法让我们不仅可以将布局和组件分离开，同时还可以在标记上设置网格布局**

# 任务处理器

## 在任务处理器中完成一切

使用基于 Node.js 的任务处理器;这些模块为我的工作流提供了各种各样的功能,例如是:Grunt、Gulp、Webpack

- 安装需要的 Ruby 库和 Bower 安装包 
- 清理临时文件夹 
- 创建软连接 
- 编译 Sass 
- 合并 JavaScript 
- 加载第三方 JavaScript 库 
- 把 SVG 文件编译成图标字体 
- 对图片进行处理，减少文件体积，裁剪成各种尺寸 
- 同步文件到远程服务器 
- 创建 Git 标签 
- 运行可视化的回归测试 
- 生成代码的样式文档 
- 自动生成浏览器厂商的前缀 
- 编译组件库 
- 优化我的 Sass、CSS、JavaScript、JSON，等等 
- 基于 JSON 模式来验证数据 
- 启动 Node 和 PHP 服务器 
- 监听文件改动来刷新浏览器 

任务处理器只是一个工具。前端架构师的职责在于创建高效且抗差错的工作流。因此，如果你的工具能帮助开发人员快速地运作起来，让他们在健壮的环境中编写高质量的代码，然后把代码部署到测试、预发布和正式发布环境

# 单元测试

是将应用程序分解为尽可能小的函数,并创建可重复的、自动化的测试用例的过程.在同等条件下,这些测试用例应该一直产生相同的结果,他们是应用程序的灵魂,并为今后所有应用程序的代码提供构建的基础.

## 单元

**“一次只做一件事，并把它做好”是构建基于单元测试的应用程序的原则**;在写函数时经常想同时实现很多功能，结果最后不仅降低了效率，还增加了测试的难度，因为这样的函数无法复用

## 测试驱动开发

可能写过一些功能代码以满足业务需求(比如上文中的计算运费的例子)，然后也努力地将它重构为更小的、可重用的、可测试的代码，之后才去思考如何写测试用例。**测试驱动的开发(test-driven development，TDD)则颠倒了这一思路，它将单元测试放在第一位，之后才是编写功能代码**

## 测试覆盖率要多大才够

确定合适的测试覆盖率是很难权衡的一件事情;如果测试所有代码,开发进度可能停滞不前;而如果测试不够,就有遗漏新问题的风险.

### 解决分歧点

测试覆盖率的好处是,即使一个单一的测试也能够为系统建设作贡献;

在决定从哪开始编写单元测试时,**可以能够获取最大收益的地方开始**;有时,最大的收益就是为系统最简单的部分编写单元测试

### 从测试覆盖率开始

如果有全新启动的新项目;需要确保任何需要测试的需求都有额外的的时间来编写单元测试,并且确认所需的测试覆盖率.

如果一个新功能需要花费 8 个小时开发完成，我们要确保另外预留 2 个小时来编写用例并验证测试覆盖率。预留的时间通常很难争取，因此前端架构师通常需要扮演起外交人员和销售人员的角色。**尽管这样会多花费 25% 的时间，但我**
**们知道这其实会节省很多后续回头追查 bug 的时间;**

**并不是所有的功能都需要同样的测试覆盖率。但前提是，每一个用户故事都是以测试覆盖率的相关任务作为开始**

# 性能测试

任何测试的目的都是为避免不流畅的用户体验,**性能测试衡量的是影响用户使用网站的流畅程度的关键指标,包括页面大小、请求数量、首字节时间、加载时间和滚动性能.**

## 制定性能预算

**为每个关键指标设定目标值,然后在所有代码合并或部署之前持续测试这些指标**.若有任何一项指标没有通过,则需要调整新的功能,或删除一些其他功能.

### 竞争基线

**参考竞争对手**;虽然“至少我比某某更好”不能作为网站性能;不佳的借口，但是这种方法确实可以保证你有一定的竞争优势

你的目标不是达到竞争对手的水平，**而是要保证领先竞争对手 20% 甚至更多。因此，如果竞争对手的产品列表页在 3 秒内加载完成，那么你就要确保自己网站的产品列表页在 2.4 秒内加载完成，**甚至更快。这些超越竞争对手 20% 的优势，是用户将你和竞争对手区分开来所需要的

### 平均基准

HTTPArchive(http://httparchive.org/)

- **页面大小:2061kb**
- **总请求次数:99**
- **可缓存资源占比例:46%**

## 原始指标

网站性能最基本的测试是看渲染页面所需要的资源，包括这些资源的大小和总数

### 页面大小

当你希望缩减页面的大小时，可以从以下几个显而易见的地方开始

- 图片占据页面平均大小的 61%。 

  -  优化 PNG 图片，并降低 JPEG 图片的质量。 
  - 利用新的响应式的 <picture> 标记和 srcset 属性来下载大小合适的图片。
  -  制定一个预算，如果没有移除任何图片，就不增加图片大小 

- 太多自定义字体很快会使网页变得臃肿。 

- -  制定一个字体预算，不考虑增加第二种或第三种字体。 
  - 考虑必要的字体粗细，因为每增加一种粗细变化，都会使字体文件增加几千个字节。 
  -  虽然图标字体很不错，但要注意文件大小，因为图标字体会使字体文件迅速变大。 
  - 如果一个网站只使用字体文件的一部分，其他网站使用另外的部分，那就拆分字体 文件。也可以考虑使用内联 SVG 代替图标字体，只加载需要的 SVG 就可以得到很 多图标字体了 

- JavaScript 框架、jQuery 插件和 CSS 框架常常使页面大小增加很多，却收效甚微。 
  -  很多网站都已远离 jQuery，因为 vanilla JS 就可以满足其需求，尤其是网站只针对现 代浏览器时。 
  -  jQuery 插件虽然可能会提供一些很厉害的功能，却常常使页面大小显著增加。考虑 在现代浏览器上使用 CSS 能否达到同样的效果，并在低版本浏览器上合理地回退。 
  - 像 Angular 或者 Ember 这样的大型 JavaScript 框架也许能完成你的工作，但生成的网 页大小会超出实际工作的需要。如果只需要使用 Angular 的视图层，那么最好使用 React 或 Mustache 来替换 
  - CSS 框架往往是乱七八糟的。它包含可能会用到的所有想象得到的样式。虽然这对于网页快速成型很有帮助，但从现有的几千字节的 CSS 和 JavaScript 出发来构建网站，会让你在开始写第一行代码之前就陷入困境。

- 使用压缩
  - JavaScript 可以在构建流程中以编程的方式进行压缩，而且可以在服务器将文件发送到浏览器之前使用 gzip 压缩。这些都是缩减网页大小的关键步骤 

### HTTP请求次数

每个浏览器对 HTTP 请求的次数有单域名并发限制，所以大量单独的文件意味着浏览器必须进行多轮并发请求。在速
度较慢的网络环境中，这么多并发请求会造成很复杂的影响。因此，减少获取所需文件的并发请求次数，效果会很显著减少 HTTP 请求的次数。 

- 不要提供数十个单独的 CSS 文件和 JavaScript 文件，而是把它们合并到一个文件中。 
- 把多个单独的图像文件合并成一个图像映射或者图标字体。有很多不错的工具(例 如 Compass 和 Grunt/Gulp 插件)可以帮你自动化地完成这些任务。 
- 延迟加载页面最初加载所不需要的资源。这可能是直到用户与页面交互才需要的 JavaScript 文件，也可能是初始加载窗口之下距离较远的图片。 
- 增加浏览器每次并发请求的资源个数。 
  - 分拆你的资源到不同的服务器(或者 CDN)，可以使得浏览器单次并发下载更多的资源，因为浏览器的并发请求数量限制是针对单个服务器的

## 计时度量

### 首字节时间

从浏览器请求网站页面开始，到浏览器接收到第一个字节之间的毫秒数。这个数值用来测量浏览器和服务器之间的连通路径，包括 DNS 查询、初始连接和数据接收。它并不是判断站点性能的最佳标准，却是一个值得关注的指标

### 开始渲染时间

指用户开始在页面上看到内容的时间。这意味着所有阻塞渲染的文件都已经加载完成，浏览器已经开始渲染文档模型了。可以通过以下方式优化开始渲染时间:延迟加载阻塞渲染的 JavaScript 和 CSS 文件、将关键的 CSS 代码内联到页面头部、用数据 URI 代替图片资源，以及延迟加载所、有在文档模型渲染完成后才下载的资源

### 文档完成时间

只要最初请求的资源已经加载成功，就可以认为文档“完成”了。文档完成时间不包括JavaScript 中拉取资源消耗的时间，因此延迟加载的资源不会影响这个指标

## 混合度量标准

**根据多个性能指标综合打分**

### PageSpeed分数

用来分析站点的性能和网站的可用性

- 是否存在阻塞渲染的 JavaScript 或者 CSS 
- 重定向至登陆页 
- 图片优化 
- 文件压缩 
- 服务器响应时间 
- 服务器端压缩 
- 浏览器端缓存 
- 点击目标的大小 
- 窗口可见区域的配置 
- 清晰的字体大小

###  Speed Index指标 

页面可见部分展示完成的平均时间， 该指标通过用毫秒表示，并取决于视图端口的大小 

# 视觉还原测试

## 视觉还原测试的多面性

### 基于页面的比较

Wraith(https://github.com/BBC-News/wraith) 是 一 个 基于页面的比较的例子。它使 用YAML 作为设置文件，因此可以很轻松地比较来自两个不同来源的一大串页面列表。当你不期望两个不同来源的页面有任何差异时，比如需要比较线上页面和在工作中即将部署的页面时，这个方法会很合适

### 基于组件比较

基于组件或基于选择器的比较方面，BackstopJS(https://github.com/garris/BackstopJS)是一个绝佳的选择。基于组件的比较工具使你可以抓取独立的页面片段进行对比，这样可以写出更有针对性的测试，并防止误报。举例来说，如果页面顶部的组件把所有其他组件都挤了下去，那么所有其他的组件就都被误报了

### CSS单位测试 

Quixote(https://github.com/jamesshore/quixote)是一类独特的比较工具，用于比较 CSS 单位的差异而不是视觉上的差异。Quixote 可以设置 TDD 模式的测试用例，这些用例会 设置好预期的 CSS 数值(比如字体大小为 1em，侧边栏的内边距是 2.5%)，然后检测 页面是否满足这些条件。它还可以诊断页面是否遵守品牌的视觉规范，比如 logo 的尺 寸是否正确，以及 logo 与其他内容是否保持恰当的距离。 

### 基于无头浏览器的测试 

Gemini(https://github.com/gemini-testing/gemini) 是 一 款 可 以 使 用 无 头 浏 览 器 PhantomJS(http://phantomjs.org/)的比较工具，它可以在抓取截图之前加载 Web 页面。 PhantomJS 是 JavaScript 实现的 WebKit 内核的浏览器，这意味着它速度非常快，并且 具有跨平台的一致性。 

### 基于桌面浏览器的测试 

Gemini 非常独特，它支持在传统的桌面浏览器上运行测试用例。为了达到这个目的， Gemini 使用 Selenium 服务器(http://docs.seleniumhq.org/download/)打开并操作系统中 安装的浏览器。这种方式没有基于无头浏览器的方式快，而且也受到系统安装的浏览器 版本的影响;但是它更接近真实情况，并且可以发现某个特定浏览器引入的 bug。 

### 包含脚步库文件 

CasperJS(http://casperjs.org/)是一个导航脚步库，可以和 PhantomJS 等无头浏览器协 同工作。该工具可以和在浏览器中打开的页面进行交互。使用它，你可以点击按钮，等 待模态窗口，填充并提交表单，最终对结果进行截图。CasperJS 还可以在 PhantomJS 打 开的页面中执行 JavaScript，你可以隐藏元素、关掉动画，甚至可以用静态模拟内容替 代动态真实内容，以避免由于“最新博文”的发布导致测试不通过。 

### 基于图形用户界面的比较工具，支持更改确认

Diffux 项目(https://github.com/diffux/diffux)存储了测试历史数据，并可以在基于 Web 的用户界面中提供测试结果的反馈。基准图像存储在数据库中，任何对它的改动都必须 在该应用界面中标记为接受或拒绝。当不懂技术的股票持有人需要确认每一个变动是否 正确时，这些工具就显得很重要了。 

### 基于命令行的比较工具，支持更改确认

PhantomCSS(https://github.com/Huddle/PhantomCSS)是一款基于组件的比较工具，借 助于 PhantomJS 和 CasperJS，它可以仅通过命令行来运行。测试是通过命令行终端运行 的，无论测试是否通过，其结果都会输出到命令行终端里。这种类型的工具尤其适合通 过 Grunt 或者 Gulp 运行，而其输出也很适合 Jenkins 或者 Travis CI 等自动化工具 



