# 设计模式概述

## 面向对象

面向对象OO = 面向对象的分析OOA + 面向对象的设计OOD + 面向对象的编程OOP； 通俗的解释就是万物皆对象，把所有的事物都看作一个个可以独立的对象(单元)，它们可以自己完成自己的功能，而不是像C那样分成一个个函数；现在纯正的OO语言主要是Java和C#，C++也支持OO，C是面向过程

## 面向对象的特征

### 封装

**即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体**，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员

### 多态

多态”一词源于希腊文 polymorphism，拆开来看是 poly(复数)+ morph(形态)+ ism，从字面上我们可以理解为复数形态;

**同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果**

### 继承

**继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码。**

在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。

另外，为子类追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类的行为在编译期就已经决定，无法在运行期扩展。

## 面向对象的优势

1. 要符合人们习惯的思维方法，便于分解大型的复杂多变的问题。由于对象对应于现实世界中的实体，因而可以很自然地按照现实世界中处理实体的方法来处理对象，软件开发者可以很方便地与问题提出者进行沟通和交流。 
2. 易于软件的维护和功能的增减。对象的封装性及对象之间的松散组合，都给软件的修改和维护带来了方便。 
3. 可重用性好。重复使用一个类（类是对象的定义，对象是类的实例化），可以比较方便地构造出软件系统，加上继承的方式，极大地提高了软件开发的效率。
4. 与可视化技术相结合，改善了工作界面。随着基于图形界面操作系统的流行，面向对象的程序设计方法也将深入人心。它与可视化技术相结合，使人机界面进入GUI时代

# 设计模式原则

## 单一指责

### 定义

应该有且仅有一个原因引起类的变更;**也就是一个接口或类只有一个职责，它就负责一件事情**;

适用于接口、类、方法

### 优点

- 类的复杂性降低，实现什么职责都有清晰明确的定义
- 可读性提高,复杂性降低
- 可维护性高
- 变更引起的风险降低

### 缺点

过分细分类的职责也会人为地增加系统的复杂性

### 实践

纯理论地来讲，这个原则是非常优秀的，但是现实有现实的难处;

你必须去考虑项目工期、成本、人员技术水平、硬件情况、网络情况甚至有时候还要考虑政府政策、垄断协议等因素

### 建议

**接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化**

## 里氏替换

通常使用**继承**来实现.

**子类可以扩展父类的功能，但不能改变父类原有的功能**

### 优点

- **代码共享，减少创建类的工作量**，每个子类都拥有父类的方法和属性；
- 提高代码的**重用性**
- 子类可以形似父类，但又异于父类
- 提高代码的**可扩展性**，实现父类的方法就可以个性化
- 提高产品或项目的**开放性**

### 缺点

- 继承是**侵入性**的。只要继承，就必须拥有父类的所有属性和方法
- 降低代码的**灵活性**。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
- 增强了**耦合性**。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构

### 实践

尽量考虑到

如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，

并且父类修改后，所有涉及到子类的功能都有可能会产生故障;

## 依赖倒置

- 高层模块不应该依赖低层模块,两者都应该依赖其抽象
- 抽象不依赖细节
- 细节应该依赖抽象

### 优点

可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性;

### 实践

- 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
- 变量的表面类型尽量是接口或者是抽象类
- 任何类都不应该从具体类派生
- 结合里氏替换原则使用

## 接口隔离

建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用;通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性

客户端不应该被迫依赖它们不使用的方法

类间的依赖关系应该建立在最小的接口上;接口尽量细化，同时接口中的方法尽量少。看到这里大家有可能要疑惑了，这与单一职责原则不是相同的吗？错，接口隔离原则与单一职责的审视角度是不相同的，**单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分**，**而接口隔离原则要求接口的方法尽量少**.

### 保证接口的纯洁性

- 接口尽量小
- 接口要高内聚
  - 模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高
- 定制服务
  - 单独为一个个体提供优良的服务
- 接口设计是有限度的
  - 接口的设计粒度越小，系统越灵活;灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低

## 迪米特法则

**一个对象应该对其他对象有最少的了解;**

如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用

### 朋友确定

1. 当前对象本身（this）
2. 以参量形式传入到当前对象方法中的对象
3. 当前对象的实例变量直接引用的对象
4. 当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友
5. 当前对象所创建的对象

任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”

### 缺点

- 系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度
- 在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的商务逻辑无关

## 开闭原则

一个软件**实体如类、模块和函数应该对扩展开放，对修改关闭**
开闭原则是最基础的一个原则，前五章节介绍的原则都是开闭原则的具体形态，也就是说前五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖

# 单例模式

## 定义

保证一个类仅有一个实例,并提供一个访问它的全局访问点(命名空间)

## 优点

- 减少内存开支、减少性能系统的性能开销
- 避免对资源的多重用占用
- 在系统设置全局的访问点,优化和共享资源访问

## 缺点

- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
- 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失

## 惰性单例

```javascript
var getSingle = function() {
    var result;
    return function(){
        	return result || ( result = fn .apply(this, arguments ) );
        }	 
}
```

# 抽象工厂模式

## 定义

提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类

## 抽象类

**强调子类继承父类时,必须子类覆盖父类定义的方法,否则提示报错**

因为在一些大型应用中，总会有一些子类去继承另一些父类;那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现，那么实例化对象便会调用父类中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助.


抽象工厂其实是一个实现**子类继承父类的方法**，

继承父类过程中有一个地方需要注意，通过 **new 关键字复制的父类的一个实例**

## 优点

- 封装性,抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建

## 缺点

- 难以扩展抽象工厂来生产新种类的产品，**这是因为在抽象工厂角色中规定了所有可能被创建的产品集合**，要支持新种**类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改**，显然会带来较大的不便

## 实践

- 在很多软件系统中需要更换界面主题，

- 涉及不同操作系统的时候

# 建造者模式

## 定义

可以将一个**复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示**;它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节

通常将创建对象的类模块化，这样使被创建的类的**每一个模块都可以得到灵活的运用与高质量的复用**。当然我们最终的需求是要得到一个完整的个体，因此在拆分创建的整个过程，我们将得到一个统一的结果

## 优点

- 封装性
- 建造则独立,容易扩展
- 便于控制细节风险

## 实践

- 相同的方法,不同的执行顺序,**产生不同的事件结果**
- 过个部件或零件,都可以装配到一个对象中,但是**产生的运行结果又不同**
- 产品类非常复杂,或者产品类中的**调用顺序不同产生了不同的效能**

# 原型模式

## 定义

用**原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法**

## 优点

将属性和方法都写在基类的**构造函数里会有一些问题**，比如每次子类继承都要创建一次父类，假如说父类的构造函数中创建时存在很多耗时较长的逻辑，或者说每次初始化都做一些重复性的东西，**这样的性能消耗大**

为了提高性能，这样每当创建基类时，对于**每次创建的一些简单而又差异化的属性我们可以放在构造函数中，而我们将一些消耗资源比较大的方法放在基类的原型中**，这样就会避免很多不必要的消耗

## 缺点

由于原型对象是一个共享对象，既然被共享，那么对原型对象的拓展，不论是子类或者父类的实例对象都会继承下来;所以不要随意去做，否则如果修改类的其他属性或者方法很有可能会影响到他人

## 实践

当然不同的子类之间可能存在不同的结构样式;应该抽象出一个基类，让不同特效类去继承这个基类，然后对于差异化的需求通过重写这些继承下来的属性或者方法来解决

# 外观模式

## 定义

为**一组复杂的子系统接口提供一个更高级的统一接口,通过这个接口是的对子系统接口的访问更容易**

## 优点

- 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易
- 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可

## 缺点

- 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性
- 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码

## 实践

- 要为一个复杂子系统提供一个简单接口；
- 客户程序与多个子系统之间存在很大的依赖性；
- 在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。
- **不要试图通过外观类为子系统增加新行为**
  - 观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现

```javascript
// 外观模式实现
    function addEvent(dom, type, fn){
        // 对于支持DoM2级事件处理程序addEventListener方法的浏览器
        if(dom.addEventListener){
          dom.addEventListener(type, fn, false)；
        // 对于不支持addEventListener方法但支持attachEvent方法的浏览器
        }else if(dom.attachEvent){
          dom.attachEvent('on' + type, fn)；
        // 对于不支持addEventListener方法也不支持attachEvent方法，但支持on+'事件名'的
    浏览器
        }else{
          dom['on' + type] = fn；
        }
    }
var myInput = document.getElementById('myinput')；
    addEvent(myInput, 'click', function(){
        console.log("绑定第—个事件")
    })
    addEvent(myInput, 'click', function(){
        console.log("绑定第二个事件")
    })
```

# 适配器模式

## 定义

将**一个类（对象）的接口（方法或者属性）转化成另外一个接口，以满足用户需求，使类（对象）之间接口的不兼容问题通过适配器得以解决****

## 优点

- 将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，而无须修改原有代码。
- 增加了类的透明性和复用性，将具体的实现封装在适配者类中，对于客户端类来说是透明的，而且提高了适配者的复用性。
- 灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类

## 实践

- 系统需要使用现有的类，而这些类的接口不符合系统的需要；
- 想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作
- 参数适配、数据适配

```javascript
function arrToobjAdapter(arr){
        return {
          name ： arr[0],
          type ： arr[1],
          title ： arr[2],
          data ： arr[3]
        }
    }
    var adapterData = arrToobjAdapter(arr)；
    console.log(adapterData)    // {name： "Javascript", type： "book", title： "前段编程语言", data"8月1日"}

function dosomeThing(obj){
        var _adapter = {
          name ： '雨夜清荷',
          title ： '设计模式',
          age ： 24,
          color ： 'pink',
          size ： 100,
          prize ： 50
        }；
        for(var i in _adapter){
          _adapter[i] = obj[i] || _adapter[i]；
        }
        // 或者 extend(_adapter, obj) 注：此时可能会多添加属性
        // do things
    }
```

# 代理模式

## 定义

**一个客户端不想或者不能直接引用一个对象时**,此时可以通过一个称之为“代理”的第三者来实现 间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，**并且可以通过代理对象去掉客户不能看到的内容和服务或者添加客户需要的额外服务**

## 优点

- 代理模式能够协调调用者和被调用者，在一定程度上降低了系 统的耦合度。
- 代理和本体接口的一致性
  - 用户可以放心地请求代理，他只关心是否能得到想要的结果
  - 在任何使用本体的地方都可以替换成使用代理

## 缺点

- 由于在客户端和真实主题之间增加了代理对象，因此 有些类型的代理模式可能会造成请求的处理速度变慢。
- 实现代理模式需要额外的工作，有些代理模式的实现 非常复杂

## 实践

1. **远程代理**，也就是为了一个对象在不同的地址空间提供局部代表，这样可以隐藏一个对象存在于不同地址空间的事实，就像web service里的代理类一样。
2. **虚拟代理**，根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象，比如浏览器的渲染的时候先显示问题，而图片可以慢慢显示（就是通过虚拟代理代替了真实的图片，此时虚拟代理保存了真实图片的路径和尺寸。
3. **安全代理**，用来控制真实对象访问时的权限，一般用于对象应该有不同的访问权限。
4. **智能指引**，只当调用真实的对象时，代理处理另外一些事情

```javascript
var myImage = (function(){
var imgNode = document.createElement( 'img' ); document.body.appendChild( imgNode );
    return {
        setSrc: function( src ){
        imgNode.src = src; 
    }
} })();
var proxyImage = (function(){ var img = new Image; img.onload = function(){
    myImage.setSrc( this.src ); }
    return {
        setSrc: function( src ){
        myImage.setSrc( 'file:// /C:/Users/svenzeng/Desktop/loading.gif' );
   		img.src = src; 
    }
} })();
proxyImage.setSrc( 'http:// imgcache.qq.com/music/photo/k/000GGDys0yA0Nk.jpg' );

```

# 装饰者模式

## 定义

**在不改变原对象的基础上,通过对其进行包装拓展(添加属性或者方法)使原有对象可以满足用户更复杂的需求,程序运行期间给对像动态的添加职责;用用于包装同接口的对象，不仅允许你向方法添加行为**

## 优点

- 动态地将责任附加到对象上.若要扩展功能,装饰者提供了比继承更有弹性的替代方案
- 装饰类和被装饰类可以独立发展，而不会相互耦合
- 可以动态地扩展一个实现类的功能

## 缺点

- 多层的装饰是比较复杂,排查问题时有可能,到了最后才发现是最里层的装饰出现了问题
- 增加了系统的复杂性

## 实践

- 需要扩展一个类的功能，或给一个类增加附加功能
- 需要动态地给一个对象增加功能，这些功能可以再动态地撤销
-  需要为一批的兄弟类进行改装或加装功能

# 桥接模式

## 定义

**抽象部分与它的实现部分分离，使它们都可以独立地变化**;又称为柄体(Handle and Body)模式或接口(Interface)模式

## 优点

- 分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节

## 缺点

- 增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情

## 实践

- 一个适用场景是组件开发。我们平时开发组件为了适应不同场合，组件相应的会有许多不同维度的变化
- 一个类存在两个独立变化的维度，且这两个维度都需要进行扩展
- 设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统

```javascript
var each = function (arr, fn) {
    for (var i = 0; i < arr.length; i++) {
        var val = arr[i];
        if (fn.call(val, i, val, arr)) {
            return false;
        }
    }
}
var arr = [1, 2, 3, 4];
each(arr, function (i, v) {
    arr[i] = v * 2;
})
```

# 组合模式

## 定义

**同时处理简单对象和由简单对象组成的复杂对象，这些简单对象和复杂对象会组合成树形结构**，**在客户端对其处理的时候要保持一致性**。比如电商网站中的产品订单，每一张产品订单可能有多个子订单组合，比如操作系统的文件夹，每个文件夹有多个子文件夹或文件，我们作为用户对其进行复制，删除等操作时，不管是文件夹还是文件，对我们操作者来说是一样

## 优点

- 高层模块调用简单。局部和整体对调用者来说没有任何区别，也就是说，高层模块不必关心自己处理的是单个对象还是整个组合结构，简化了高层模块的代码
- 节点自由增加。使用了组合模式后，我们可以看看，如果想增加一个树枝节点、树叶节点十分简单，只要找到它的父节点就成，非常容易扩展，符合开闭原则，对以后的维护非常有利

## 缺点

- 系统中的每个对象看起来都 与其他对象差不多。它们的区别只有在运行的时候会才会显现出来，这会使代码难以理解。
-  如果通过组合模式创建了太多的对象，那么这些对象可能会让系统负担不起 

## 实践

- 表示对象的部分整体层次结构 
- 客户希望统一对待树中的所有对象 

```javascript
function FlightOrder() { }
FlightOrder.prototyp.create = function () {
    console.log("flight order created");
}
function HotelOrder() { }
HotelOrder.prototype.create = function () {
    console.log("hotel order created");
}
function TotalOrders() {
    this.orderList = [];
}
TotalOrders.prototype.addOrder = function (order) {
    this.orderList.push(order);
}
TotalOrders.prototype.create = function (order) {
    for (var i = 0, length = this.orderList.length; i < length; i++) {
        this.orderList[i].create();
    }
}
var flight = new FlightOrder();
flight.create();

var orders = new TotalOrders();
orders.addOrder(new FlightOrder());
orders.addOrder(new HotelOrder());
orders.create();
```

# 享元模式

## 定义

运用**共享技术有效地支持大量的细粒度的对象，避免对象间拥有相同内容造成多余的开销**

## 优点

- 它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份。
- 外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享

## 缺点

- 使得系统更加复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。
- 为了使对象可以共享，享元模式需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。

## 实践

- 一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费。
- 对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。
- 使用享元模式需要维护一个存储享元对象的享元池，而这需要耗费资源，因此，应当在多次重复使用享元对象时才值得使用享元模式
- 在中央事件管理器上用来避免给父容器里的每个子元素都附加事件句柄

```javascript
const Model = function(gender) {
  this.gender = gender
}
Model.prototype.takephoto = function() {
  console.log(`${this.gender}穿着${this.underwear}`)
}
const modelFactory = (function() { // 优化第一点
  const modelGender = {}
  return {
    createModel: function(gender) {
      if (modelGender[gender]) {
        return modelGender[gender]
      }
      return modelGender[gender] = new Model(gender)
    }
  }
}())
const modelManager = (function() {
  const modelObj = {}
  return {
    add: function(gender, i) {
      modelObj[i] = {
        underwear: `第${i}款衣服`
      }
      return modelFactory.createModel(gender)
    },
    copy: function(model, i) { // 优化第二点\
      model.underwear = modelObj[i].underwear
    }
  }
}())
for (let i = 1; i < 51; i++) {
  const maleModel = modelManager.add('male', i)
  modelManager.copy(maleModel, i)
  maleModel.takephoto()
}
for (let i = 1; i < 51; i++) {
  const femaleModel = modelManager.add('female', i)
  modelManager.copy(femaleModel, i)
  femaleModel.takephoto()
}
```

# 模版方法模式

## 定义

**父类定义一组可操作算饭骨架,而将一些实现步骤延迟到子类中**,使得在子类中可以改变父类的算法结构同时可以重新定义算法中某些实现的步骤;

核心在于**对方法的重用，它将核心方法封装在基类中，让子类继承基类的方法，实现基类方法的共享，达到方法共用**

## 优点

- 封装不变部分,扩展变的部分
- 提取公共代码,便于维护
- 行为由父类控制,子类实现

## 缺点

- 每个不同的实现都需要子类完成,导致类数量的增加,增加系统复杂度

## 实践

```javascript
// 格式化字符串方法
    function formatestring(str, data){
        return  str.replace(/\{#(\w+)#\}/g,  function(match,  key){return  typeof
            data[key] === undefined ? '' ： data[key]})；
    }
    // 基础导航
    var Nav = function(data){
        // 基础导航样式模板
        this.item = '＜a href="{#href#}" title="{#title#}"＞{#name#}＜/a＞'；
        // 创建字符串
        this.html = ''；
        // 格式化数据
        for(var i = 0, len = data.length； i ＜ len； i++){
          this.html += formatestring(this.item, data[i])；
        }
        // 返回字符串数据
        return this.html；
    }
    // 带有消息提醒信息导航
    var NumNav = function(data){
        // 消息提醒信息组件模板
        var tpl = '＜b＞{#num#}＜/b＞'；
        // 装饰数据
        for(var i = data.length - 1； i ＞= 0； i--){
          data[i].name += data[i].name + formatestring(tpl, data[i])；
        }
        // 继承基础导航类，并返回字符串
        return Nav.call(this, data)；
    }
    
    // 获取导航容器
    var nav = document.getElementById('content')；
    // 添加内容
    nav.innerHTML = NumNav([
        {
          href ： 'http：//www.baidu.com/',
          title ： '百度—下，你就知道',
          name ： '百度',
          num ： '10'
        },
        {
          href ： 'http：//www.taobao.com/',
          title ： '淘宝商城',
          name ： '淘宝',
          num ： '2'
        },
        {
          href ： 'http：//www.qq.com/',
          title ： '腾讯首页',
          name ： '腾讯',
          num ： '3'
        }
    ])
```



# 观察者模式

## 定义

称作是发布-订阅模式或消息机制,定义一**种依赖关系,解决了主体对象与观察者之间功能的耦合性**;

**一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应;发生改变的对象称为观察目标，**而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展

**模块间通信问题**

## 优点

- 观察者和被观察者是抽象耦合
- 建立一套触发机制

## 缺点

- 如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。
- 如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃
- 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化

## 实践

```javascript
// 将观察者放在闭包中，当页面加载就立即执行
    var observer = (function(){
        // 防止消息队列暴漏而被篡改故将消息容器作为静态私有变量保存
        var __messages = {}；
        return {
          // 注册信息接口
          regist ： function(type, fn){// 如果此消息不存在则应该创建—个该消息类型
            if(typeof __messages[type] === 'undefined'){
              // 将动作推入到该消息对应的动作执行队列中
              __messages[type] = [fn]；
            // 如果此消息存在
            }else{
              // 将动作方法推入该消息对应的动作执行序列中
              __messages[type].push(fn)；
            }
        },
          fire ： function(type, args){
            // 如果该消息设有被注册，则返回
            if(!__messages[type])
              return；
            // 定义消息信息
            var events = {
              type ： type,                   // 消息类型
              args ： args || {}              // 消息携带数据
            },
            i = 0,                             // 消息动作循环变量
            len = __messages[type].length；    // 消息动作长度
            // 遍历消息动作
            for(； i ＜ len； i++){
              // 依次执行注册的消息对应的动作序列
              __messages[type][i].call(this, events)；
            }
        },
          remove ： function(type, fn){// 如果消息动作队列存在
            if(__messages[type] instanceof Array){
              // 从最后—个消息动作遍历
              var i = __messages[type].length - 1；
              for(； i ＞= 0； i--){
                  // 如果存在该动作则在消息动作序列中移除相应动作
                  __messages[type][i] === fn && __messages[type].splice(i, 1)；
              }
            }
        }
        }
    })()；
```



# 状态模式

## 定义

**当对象内部状态发生改变时,会导致其行为发生改变;**

一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态

将各个状态所对应的操作分离开来，即对于不同的状态，由不同的子类实现具体操作，不同状态的切换由子类实现

状态模式中类有状态，状态的修改会改变整个类行为

关注的焦点在于内部状态的改变而引起的行为的变化

## 优点

- 封装了转换状态规则
- 枚举了可能出现的状态,在枚举状态之前需要确定状态种类
- 将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为。
- 允许状态转换逻辑与状态对象合成一体，而不是某一个巨大的条件语句块。
- 可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数

## 缺点

- 状态模式的使用必然会增加系统类和对象的个数。
- 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱。
- 状态模式对“开闭原则”的支持并不太好，对于可以切换状态的状态模式，增加新的状态类需要修改那些负责状态转换的源代码，否则无法切换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码

## 实践

```javascript
// 投票结果状态对象
    var Resutlstate = function(){
        // 判断结果保存在内部状态中
        var states = {
              // 每种状态作为—种独立方法保存
              state0 ： function(){
                  // 处理结果0
                  console.log('这是第—种情况')
              },
              state1 ： function(){
                  // 处理结果1
                  console.log('这是第二种情况')
              },
              state2 ： function(){
                  // 处理结果2
                  console.log('这是第三种情况')
              },
              state3 ： function(){
                  // 处理结果3
                  console.log('这是第四种情况')
              }
          }
        // 获取某—种状态并执行其对应的方法
        function show(result){
          states['state' + result] && states['state' + result]()；
        }
        return {
          // 返回调用状态方法接口
          show ： show
        }
    }()；
```



# 策略模式

## 定义

将定义一组算法封装起来,使其相互之间可以替换;封装的算法具有一定的独立性,不会随客户端变化而变化

一般用于单个算法，而状态模式的每个状态子类中需要包含所有原来的语境类（Context）中的所有方法的具体实现

策略模式没有状态，策略的选择由客户端决定

关注的焦点在于具体的某一个行为，准确的说是某一行为的具体执行过程

## 优点

- 策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基础上选择算法或行为，也可以灵活地增加新的算法或行为。
- 策略模式提供了管理相关的算法族的办法。
- 策略模式提供了可以替换继承关系的办法。

## 缺点

- 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。
- 策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。

## 实践

```javascript
// 表单正则验证策略对象
    var Inputstrategy = function(){
        var strategy = {
          // 是否为空
          notNull ： function(value){
              return /\s+/.test(value) ? '请输入内容' ： ''；
          },
          // 是否是—个数字
          number ： function(value){
              return /^[0-9]+(\.[0-9]+)?$/.test(value) ? '' ： '请输入数字'；
          },
          // 是否是本地电话
          phone ： function(value){
              return /^\d{3}\-\d{8}$|^\d{4}\-\d{7}$/.test(value) ? '' ： '请输入正
              确的电话号码格式，如：010-12345678 或 0418-1234567'；
          }
      }
      return {
          // 验证接口 type 算法 value 表单值
          check ： function(type, value){
              // 去除收尾空白符
              value = value.replace(/^\s+|\s+$/g, '')；
              return strategy[type] ? strategy[type](value) ： '设有该类型的检测方法'
          },
          // 添加策略
          addstrategy ： function(type, fn){
              strategy[type] = fn；
          }
      }
    }()；
```

# 命令模式

## 定义

**将请求与实现解耦并封装成一个独立对象,从而使不同请求对客户端实现参数化**

## 优点

- 降低了系统耦合度。 
- 新的命令可以很容易添加到系统中去。

## 缺点

- 使用命令模式可能会导致某些系统有过多的具体命令类

## 实践

```javascript
// 模块实现模块
    var viewcommand = (function(){
    // 方法集合
    var Action = {
          // 创建方法
          create ： function(){},
          // 展示方法
          display ： function(){}
        }
        // 命令接口
       return function excute(msg){
        	// 解析命令，如果msg.param不是数组则将其转化为数组（apply方法要求第二个参数为数组）
        msg.param=object.prototype.tostring.call(msg.param)==="[object Array]"? msg.param ： [msg.param]；
        // Action内部调用的方法引用this，所以此处为保证作用域this执行传入Action
        Action[msg.command].apply(Action, msg.param)
    	}
    })()；
    viewcommand({
        // 参数说明 方法 display
        command ： 'display',
        // 参数说明 param1 元素容器 param2 标题数据 param3 元素模板 详见display方法
        param ： ['title', titleData, 'title']
    })；
```

# 访问者模式

## 定义

**是表示一个作用于某个对象结构中的各元素的操作。它使可以在不改变各元素的类的前提下定义作用于这些元素的新操作;**

我们可以将每一个类中的相关操作提取出来，包装成一个独立的对象，这个对象我们就称为访问者（Visitor）。利用访问者，对访问的元素进行某些操作时，只需将此对象作为参数传递给当前访问者，然后，访问者会依据被访问者的具体信息，进行相关的操作

访问者模式先把一些可复用的行为抽象到一个函数(对象)里，这个函数我们就称为访问者（Visitor）。如果另外一些对象要调用这个函数，只需要把那些对象当作参数传给这个函数，在js里我们经常通过call或者apply的方式传递this对象给一个Visitor函数.

## 优点

- 降低了系统耦合度。 
- 符合单一职责原则。
- 优秀的扩展性。 
- 灵活性。

## 缺点

- 具体元素对访问者公布细节，违反了迪米特原则。
- 具体元素变更比较困难。
- 违反了依赖倒置原则，依赖了具体类，没有依赖抽象。

## 实践

```javascript
var Visitor = {}
Visitor .push  =  function(){
    return Array.prototype.push.apply( this, arguments );
}
var obj = {};
obj.push = Visitor .push;
obj.push( '"first" );
alert ( obj[0] )  //"first"
alert ( obj.length );  //1
```

# 中介模式

## 定义

通过中介者对象封装一系列对象之间的交互，使对象之间不再相互引用，降低他们之间的耦合;

中介者模式中，订阅者是单向的，只能是消息的订阅者。而消息统一由中介者对象发布，所有的订阅者对象间接地被中介者管理;

中介者模式中消息的发送方只有一个，就是中介者对象，而且中介者对象不能订阅消息，只有那些活跃对象（订阅者）才可订阅中介者的消息;

## 优点

- 降低了类的复杂度，将一对多转化成了一对一。
- 各个类之间的解耦。
- 符合迪米特原则。

## 缺点

- 中介者会庞大，变得复杂难以维护

## 实践

```javascript
//中介者对象
    var Mediator = function(){
        // 消息对象
        var _msg = {}；
        return {
          /＊＊＊＊
            ＊ 订阅消息方法
            ＊ 参数 type      消息名称
            ＊ 参数 action    消息回调函数
            ＊＊＊＊/
          register ： function(type, action){
              // 如果该消息存在
              if(_msg[type])
                  // 存入回调函数
                  _msg[type].push(action)；
              else{
                  // 不存在 则建立该消息容器
                  _msg[type] = []；
                  // 存入新消息回调函数
                  _msg[type].push(action)；
              }
          },
          /＊＊＊
            ＊ 发布消息方法
            ＊ 参数 type 消息名称
            ＊＊＊＊/
          send ： function(type){
              // 如果该消息己经被订阅
              if(_msg[type]){
                  // 遍历己存储的消息回调函数
                  for(var i = 0, len = _msg[type].length； i ＜ len； i++){
                  // 执行该回调函数
                  _msg[type][i] && _msg[type][i]()；
              }
            }
        }
      }
    }()；
```





# 备忘录模式

## 定义

## 优点

## 缺点

## 实践

# 迭代器模式

## 定义

## 优点

## 缺点

## 实践

# 解释器模式

## 定义

## 优点

## 缺点

## 实践