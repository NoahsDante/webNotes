# 设计模式概述

## 面向对象

面向对象OO = 面向对象的分析OOA + 面向对象的设计OOD + 面向对象的编程OOP； 通俗的解释就是万物皆对象，把所有的事物都看作一个个可以独立的对象(单元)，它们可以自己完成自己的功能，而不是像C那样分成一个个函数；现在纯正的OO语言主要是Java和C#，C++也支持OO，C是面向过程

## 面向对象的特征

### 封装

**即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体**，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员

### 多态

多态”一词源于希腊文 polymorphism，拆开来看是 poly(复数)+ morph(形态)+ ism，从字面上我们可以理解为复数形态;

**同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果**

### 继承

**继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码。**

在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。

另外，为子类追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类的行为在编译期就已经决定，无法在运行期扩展。

## 面向对象的优势

1. 要符合人们习惯的思维方法，便于分解大型的复杂多变的问题。由于对象对应于现实世界中的实体，因而可以很自然地按照现实世界中处理实体的方法来处理对象，软件开发者可以很方便地与问题提出者进行沟通和交流。 
2. 易于软件的维护和功能的增减。对象的封装性及对象之间的松散组合，都给软件的修改和维护带来了方便。 
3. 可重用性好。重复使用一个类（类是对象的定义，对象是类的实例化），可以比较方便地构造出软件系统，加上继承的方式，极大地提高了软件开发的效率。
4. 与可视化技术相结合，改善了工作界面。随着基于图形界面操作系统的流行，面向对象的程序设计方法也将深入人心。它与可视化技术相结合，使人机界面进入GUI时代

# 设计模式原则

## 单一指责

### 定义

应该有且仅有一个原因引起类的变更;**也就是一个接口或类只有一个职责，它就负责一件事情**;

适用于接口、类、方法

### 优点

- 类的复杂性降低，实现什么职责都有清晰明确的定义
- 可读性提高,复杂性降低
- 可维护性高
- 变更引起的风险降低

### 缺点

过分细分类的职责也会人为地增加系统的复杂性

### 实践

纯理论地来讲，这个原则是非常优秀的，但是现实有现实的难处;

你必须去考虑项目工期、成本、人员技术水平、硬件情况、网络情况甚至有时候还要考虑政府政策、垄断协议等因素

### 建议

**接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化**

## 里氏替换

通常使用继承来实现.

**子类可以扩展父类的功能，但不能改变父类原有的功能**

### 优点

- **代码共享，减少创建类的工作量**，每个子类都拥有父类的方法和属性；
- 提高代码的**重用性**
- 子类可以形似父类，但又异于父类
- 提高代码的**可扩展性**，实现父类的方法就可以个性化
- 提高产品或项目的**开放性**

### 缺点

- 继承是**侵入性**的。只要继承，就必须拥有父类的所有属性和方法
- 降低代码的**灵活性**。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
- 增强了**耦合性**。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构

### 实践

尽量考虑到

如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，

并且父类修改后，所有涉及到子类的功能都有可能会产生故障;

## 依赖倒置

- 高层模块不应该依赖低层模块,两者都应该依赖其抽象
- 抽象不依赖细节
- 细节应该依赖抽象

### 优点

可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性;

### 实践

- 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
- 变量的表面类型尽量是接口或者是抽象类
- 任何类都不应该从具体类派生
- 结合里氏替换原则使用

## 接口隔离

建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用;通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性

客户端不应该被迫依赖它们不使用的方法

类间的依赖关系应该建立在最小的接口上;接口尽量细化，同时接口中的方法尽量少。看到这里大家有可能要疑惑了，这与单一职责原则不是相同的吗？错，接口隔离原则与单一职责的审视角度是不相同的，**单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分**，**而接口隔离原则要求接口的方法尽量少**.

### 保证接口的纯洁性

- 接口尽量小
- 接口要高内聚
  - 模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高
- 定制服务
  - 单独为一个个体提供优良的服务
- 接口设计是有限度的
  - 接口的设计粒度越小，系统越灵活;灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低

## 迪米特法则

**一个对象应该对其他对象有最少的了解;**

如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用

### 朋友确定

1. 当前对象本身（this）
2. 以参量形式传入到当前对象方法中的对象
3. 当前对象的实例变量直接引用的对象
4. 当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友
5. 当前对象所创建的对象

任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”

### 缺点

- 系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度
- 在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的商务逻辑无关

## 开闭原则

一个软件**实体如类、模块和函数应该对扩展开放，对修改关闭**
开闭原则是最基础的一个原则，前五章节介绍的原则都是开闭原则的具体形态，也就是说前五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖

# 单例模式

## 定义

保证一个类仅有一个实例,并提供一个访问它的全局访问点

## 优点

- 减少内存开支、减少性能系统的性能开销
- 避免对资源的多重用占用
- 在系统设置全局的访问点,优化和共享资源访问

## 缺点

- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
- 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如Java、C#)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失

## 惰性单例

```javascript
var getSingle = function() {
    var result;
    return function(){
        	return result || ( result = fn .apply(this, arguments ) );
        }	 
}
```

