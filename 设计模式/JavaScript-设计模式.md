# 设计模式概述

## 面向对象

面向对象OO = 面向对象的分析OOA + 面向对象的设计OOD + 面向对象的编程OOP； 通俗的解释就是万物皆对象，把所有的事物都看作一个个可以独立的对象(单元)，它们可以自己完成自己的功能，而不是像C那样分成一个个函数；现在纯正的OO语言主要是Java和C#，C++也支持OO，C是面向过程

## 面向对象的特征

### 封装

**即隐藏对象的属性和实现细节，仅对外公开接口，控制在程序中属性的读和修改的访问级别；将抽象得到的数据和行为（或功能）相结合，形成一个有机的整体**，也就是将数据与操作数据的源代码进行有机的结合，形成“类”，其中数据和函数都是类的成员

### 多态

多态”一词源于希腊文 polymorphism，拆开来看是 poly(复数)+ morph(形态)+ ism，从字面上我们可以理解为复数形态;

**同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果**

### 继承

**继承可以使得子类具有父类别的各种属性和方法，而不需要再次编写相同的代码。**

在令子类别继承父类别的同时，可以重新定义某些属性，并重写某些方法，即覆盖父类别的原有属性和方法，使其获得与父类别不同的功能。

另外，为子类追加新的属性和方法也是常见的做法。 一般静态的面向对象编程语言，继承属于静态的，意即在子类的行为在编译期就已经决定，无法在运行期扩展。

## 面向对象的优势

1. 要符合人们习惯的思维方法，便于分解大型的复杂多变的问题。由于对象对应于现实世界中的实体，因而可以很自然地按照现实世界中处理实体的方法来处理对象，软件开发者可以很方便地与问题提出者进行沟通和交流。 
2. 易于软件的维护和功能的增减。对象的封装性及对象之间的松散组合，都给软件的修改和维护带来了方便。 
3. 可重用性好。重复使用一个类（类是对象的定义，对象是类的实例化），可以比较方便地构造出软件系统，加上继承的方式，极大地提高了软件开发的效率。
4. 与可视化技术相结合，改善了工作界面。随着基于图形界面操作系统的流行，面向对象的程序设计方法也将深入人心。它与可视化技术相结合，使人机界面进入GUI时代

# 设计模式原则

## 单一指责

### 定义

应该有且仅有一个原因引起类的变更;**也就是一个接口或类只有一个职责，它就负责一件事情**;

适用于接口、类、方法

### 优点

- 类的复杂性降低，实现什么职责都有清晰明确的定义
- 可读性提高,复杂性降低
- 可维护性高
- 变更引起的风险降低

### 缺点

过分细分类的职责也会人为地增加系统的复杂性

### 实践

纯理论地来讲，这个原则是非常优秀的，但是现实有现实的难处;

你必须去考虑项目工期、成本、人员技术水平、硬件情况、网络情况甚至有时候还要考虑政府政策、垄断协议等因素

### 建议

**接口一定要做到单一职责，类的设计尽量做到只有一个原因引起变化**

## 里氏替换

通常使用继承来实现.

**子类可以扩展父类的功能，但不能改变父类原有的功能**

### 优点

- **代码共享，减少创建类的工作量**，每个子类都拥有父类的方法和属性；
- 提高代码的**重用性**
- 子类可以形似父类，但又异于父类
- 提高代码的**可扩展性**，实现父类的方法就可以个性化
- 提高产品或项目的**开放性**

### 缺点

- 继承是**侵入性**的。只要继承，就必须拥有父类的所有属性和方法
- 降低代码的**灵活性**。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约束；
- 增强了**耦合性**。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构

### 实践

尽量考虑到

如果一个类被其他的类所继承，则当这个类需要修改时，必须考虑到所有的子类，

并且父类修改后，所有涉及到子类的功能都有可能会产生故障;

## 依赖倒置

- 高层模块不应该依赖低层模块,两者都应该依赖其抽象
- 抽象不依赖细节
- 细节应该依赖抽象

### 优点

可以减少类间的耦合性，提高系统的稳定性，降低并行开发引起的风险，提高代码的可读性和可维护性;

### 实践

- 每个类尽量都有接口或抽象类，或者抽象类和接口两者都具备
- 变量的表面类型尽量是接口或者是抽象类
- 任何类都不应该从具体类派生
- 结合里氏替换原则使用

## 接口隔离

建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用;通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性

客户端不应该被迫依赖它们不使用的方法

类间的依赖关系应该建立在最小的接口上;接口尽量细化，同时接口中的方法尽量少。看到这里大家有可能要疑惑了，这与单一职责原则不是相同的吗？错，接口隔离原则与单一职责的审视角度是不相同的，**单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分**，**而接口隔离原则要求接口的方法尽量少**.

### 保证接口的纯洁性

- 接口尽量小
- 接口要高内聚
  - 模块的功能强度的度量，即一个模块内部各个元素彼此结合的紧密程度的度量。若一个模块内各元素（语名之间、程序段之间）联系的越紧密，则它的内聚性就越高
- 定制服务
  - 单独为一个个体提供优良的服务
- 接口设计是有限度的
  - 接口的设计粒度越小，系统越灵活;灵活的同时也带来了结构的复杂化，开发难度增加，可维护性降低

## 迪米特法则

**一个对象应该对其他对象有最少的了解;**

如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中的一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用

### 朋友确定

1. 当前对象本身（this）
2. 以参量形式传入到当前对象方法中的对象
3. 当前对象的实例变量直接引用的对象
4. 当前对象的实例变量如果是一个聚集，那么聚集中的元素也都是朋友
5. 当前对象所创建的对象

任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”；否则就是“陌生人”

### 缺点

- 系统中存在大量的中介类，这些类之所以存在完全是为了传递类之间的相互调用关系——这在一定程度上增加了系统的复杂度
- 在系统里造出大量的小方法，这些方法仅仅是传递间接的调用，与系统的商务逻辑无关

## 开闭原则

一个软件**实体如类、模块和函数应该对扩展开放，对修改关闭**
开闭原则是最基础的一个原则，前五章节介绍的原则都是开闭原则的具体形态，也就是说前五个原则就是指导设计的工具和方法，而开闭原则才是其精神领袖

# 单例模式

## 定义

保证一个类仅有一个实例,并提供一个访问它的全局访问点(命名空间)

## 优点

- 减少内存开支、减少性能系统的性能开销
- 避免对资源的多重用占用
- 在系统设置全局的访问点,优化和共享资源访问

## 缺点

- 由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。
- 单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。
- 滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失

## 惰性单例

```javascript
var getSingle = function() {
    var result;
    return function(){
        	return result || ( result = fn .apply(this, arguments ) );
        }	 
}
```

# 抽象工厂模式

## 定义

提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类

## 抽象类

**强调子类继承父类时,必须子类覆盖父类定义的方法,否则提示报错**

因为在一些大型应用中，总会有一些子类去继承另一些父类;那么一旦用子类创建了一个对象，该对象总是应该具备一些必要的方法，但如果这些必要的方法从父类中继承过来而没有具体去重写实现，那么实例化对象便会调用父类中的这些方法，如果父类能有一个友好提示，那么对于忘记重写子类的这些错误遗漏的避免是很有帮助.


抽象工厂其实是一个实现**子类继承父类的方法**，

继承父类过程中有一个地方需要注意，通过 **new 关键字复制的父类的一个实例**

## 优点

- 封装性,抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建

## 缺点

- 难以扩展抽象工厂来生产新种类的产品，**这是因为在抽象工厂角色中规定了所有可能被创建的产品集合**，要支持新种**类的产品就意味着要对该接口进行扩展，而这将涉及到对抽象工厂角色及其所有子类的修改**，显然会带来较大的不便

## 实践

- 在很多软件系统中需要更换界面主题，

- 涉及不同操作系统的时候

# 建造者模式

## 定义

可以将一个**复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示**;它更多关心的是创建这个对象的整个过程，甚至于创建对象的每一个细节

通常将创建对象的类模块化，这样使被创建的类的**每一个模块都可以得到灵活的运用与高质量的复用**。当然我们最终的需求是要得到一个完整的个体，因此在拆分创建的整个过程，我们将得到一个统一的结果

## 优点

- 封装性
- 建造则独立,容易扩展
- 便于控制细节风险

## 实践

- 相同的方法,不同的执行顺序,**产生不同的事件结果**
- 过个部件或零件,都可以装配到一个对象中,但是**产生的运行结果又不同**
- 产品类非常复杂,或者产品类中的**调用顺序不同产生了不同的效能**

# 原型模式

## 定义

用**原型实例指向创建对象的类，使用于创建新的对象的类共享原型对象的属性以及方法**

## 优点

将属性和方法都写在基类的**构造函数里会有一些问题**，比如每次子类继承都要创建一次父类，假如说父类的构造函数中创建时存在很多耗时较长的逻辑，或者说每次初始化都做一些重复性的东西，**这样的性能消耗大**

为了提高性能，这样每当创建基类时，对于**每次创建的一些简单而又差异化的属性我们可以放在构造函数中，而我们将一些消耗资源比较大的方法放在基类的原型中**，这样就会避免很多不必要的消耗

## 缺点

由于原型对象是一个共享对象，既然被共享，那么对原型对象的拓展，不论是子类或者父类的实例对象都会继承下来;所以不要随意去做，否则如果修改类的其他属性或者方法很有可能会影响到他人

## 实践

当然不同的子类之间可能存在不同的结构样式;应该抽象出一个基类，让不同特效类去继承这个基类，然后对于差异化的需求通过重写这些继承下来的属性或者方法来解决

# 外观模式

## 定义

为一组复杂的子系统接口提供一个更高级的统一接口,通过这个接口是的对子系统接口的访问更容易

## 优点

- 对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易
- 实现了子系统与客户之间的松耦合关系，这使得子系统的组件变化不会影响到调用它的客户类，只需要调整外观类即可

## 缺点

- 不能很好地限制客户使用子系统类，如果对客户访问子系统类做太多的限制则减少了可变性和灵活性
- 在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码

## 实践

- 要为一个复杂子系统提供一个简单接口；
- 客户程序与多个子系统之间存在很大的依赖性；
- 在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。
- **不要试图通过外观类为子系统增加新行为**
  - 观模式的用意是为子系统提供一个集中化和简化的沟通渠道，而不是向子系统加入新的行为，新的行为的增加应该通过修改原有子系统类或增加新的子系统类来实现，不能通过外观类来实现

```javascript
// 外观模式实现
    function addEvent(dom, type, fn){
        // 对于支持DoM2级事件处理程序addEventListener方法的浏览器
        if(dom.addEventListener){
          dom.addEventListener(type, fn, false)；
        // 对于不支持addEventListener方法但支持attachEvent方法的浏览器
        }else if(dom.attachEvent){
          dom.attachEvent('on' + type, fn)；
        // 对于不支持addEventListener方法也不支持attachEvent方法，但支持on+'事件名'的
    浏览器
        }else{
          dom['on' + type] = fn；
        }
    }
var myInput = document.getElementById('myinput')；
    addEvent(myInput, 'click', function(){
        console.log("绑定第—个事件")
    })
    addEvent(myInput, 'click', function(){
        console.log("绑定第二个事件")
    })
```

