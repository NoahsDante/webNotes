# 了解级联

## 什么是级联

级联是浏览器**确定如何将样式应用于元素的方法。因为可以将多个样式应用于同一个元素**，所以在未按预期方式应用样式的情况下

## 选择器的特异

特异性是基于所使用的CSS选择器精确识别元素的度量。通过分析组合以选择元素的不同类型的选择器（通用选择器，*除外）来计算特异性。通过将数字插入**（a，b，c，d）**来确定特异性

1. **如果通过style属性应用样式，则a = 1;否则，a = 0**
2. b等于存在的**ID选择器的数量**
3. c等于存在的**类选择器，属性选择器和伪类的数量**
4. d等于存在的**类型（元素）选择器和伪元素的数量**

```css
#nav-global > ul > li > a.nav-link { color: #000000;
}
```

我们可以确定此选择器的特异性为（0,1,1,3)

1. 样式不是通过style属性应用的，因此a = 0
2. 有1个ID选择器（＃nav-global），所以b = 1
3. 有1个类选择器（.nav-link），所以c = 1
4. 这里有3种类型（元素）选择器（ul，li和a），所以d = 3

当比较选择器的特异性时，具有**最左边最大数量的选择器具有最高的特异性**。如果比较的两个最左边的数字是相等的，则使用左边的下一个数字，依此类推。例如，（1,0,0,0）的特异性高于（0,1,1,3），同样地（0,2,1,3）高于（0,1,1） ，3）。然而，（0,1,1,3）的特异性低于（0,1,1,4）或（0,1,2,0）的特异性

## 规则集顺序

当具有**相同特异性选择器的两个声明块尝试在同一元素上设置属性样式时**，**样式表中稍后出现的声明块中的属性具有优先权**

## 用重要声明覆盖级联 !important

!important  > （a，b，c，d）;

当选择相同元素的**多个声明块使用！important时，将应用最后出现的**

请注意**！important不能用于使用style属性的样式**

# 写出更好的css样式

## 使用注释

注释提供了将来查看文件时有用的文档

1. 文件内容
2. 选择者的依赖关系，用法等
3. 为什么使用某些声明（这对于浏览器怪癖特别有帮助）
4. 已弃用的样式正在重构，不应再使用

CSS只有块级注释（注释可以跨越多行），它们以/* *开头，以* */结尾。如果注释只需要一行，则可以完成，但它必须以*/ *开头并以* */结尾

```css
/*
*  Styles for main navigation links.
*
*  @see templates/_navigation.html
*/
```

## 一致的结构规则集

规则集可以全部**写在一行上，也可以格式化为使用多行。**

## 保持选择器简单

通过将许多不同的选择器和组合器串在一起，可以使选择器变得非常复杂;

使用的选择器高**度依赖于页面上的HTML结构。如果HTML结构中发生了某些变化，将不再应用所需的样式**

向HTML元素**添加一个类并为该类设置样式**

## 高性能的选择器

简单的选择器应该是首选，因为它们更易于重复使用且易于理解

### 从右到左匹配选择器

可以消除前面不匹配的元素，而不是浪费时间检查可能匹配的元素

```html
<!doctype html>
<html>
  <head>
		<title>Another Example</title> 
  </head>
<body> 
    <div>
		<nav> 
            <ul>
                <li>
                    <strong>Not a Link</strong> 
                </li>
            </ul> 
      </nav>
  </div> 
  <div>
      <nav> 
          <ul>
              <li>
                  <a href="#" class="nav-link">Link</a>
              </li>
          </ul>
     </nav>
 </div>
</body>
</html>
```

如果使用选择器div> nav> ul> li> a选择锚标记并且浏览器尝试**从左到右匹配元素**

1. 遍历每个元素以查看它是否是<div>元素
2. 检查在步骤1中匹配<div>的每个，看它是否有<nav>一个元素子元素
3. 检查在步骤2中匹配<nav>的每个元素，以查看它是否具有<ul>元素作为子元素
4. 检查在步骤3中匹配<ul>的每个元素，看它是否有<li>元素作为子元素
5. 检查在步骤4中匹配<li>的每个元素，看它是否有<a>元素作为子元素
6. 将样式应用于找到的一个元素

如果是相反的匹配**从右到左匹配元素**

1. 遍历每个元素以查看它是否是<a>元素。
2. 检查在步骤1中匹配的每个<a>元素是否具有<li>元素作为父元素。
3. 检查在步骤2中匹配的每个<li>元素是否具有<ul>元素作为父元素。
4. 检查在步骤3中匹配的每个<ul>元素是否具有<nav>元素作为父元素。
5. 检查在步骤4中匹配的每个<nav>元素是否具有<div>元素作为父元素。
6. 将样式应用于<a>与选择器匹配的元素

虽然步数相同，但最大的区别在于，

**当从左到右匹配选择器时，需要遍历两个<div>元素**

通过从**右到左匹配选择器**，浏览器可**为了尽早过滤掉一些无关的样式规则和元素**。为了使性能更高效，可以通过其类.nav-link选择锚标记，因此浏览器所要做的就是通过每个元素进行检查并检查它是否具有该类

### 通用选择器

```css
body * { 
	font-size: 12px;
}
```

浏览器将从右到左匹配元素，因此它可以更快地消除与选择器不匹配的元素。选择器的最右边部分称为键选择器，因此在这使得通用选择器*成为键选择器。
当通用选择器本身用于将样式应用于所有元素（* {}）时，浏览器可以相当快地完成，因为它只需匹配页面上的每个元素。但是，**当通用选择器与另一个选择器和组合器（示例3-9中的祖先组合器）结合使用时**，浏**览器将需要做更多的工作来匹配相应的元素**。这可以通过**仅使用通用选择器而不是组合器和其他选择器来避免**

## 解耦CSS和JavaScript

为了区分CSS和JavaScript的关注点，**用于在JavaScript中选择元素的类和ID不应该用于样式元素**。类似地，**当需要通过JavaScript修改元素样式时，应该通过添加和删除类来完成**

## JavaScript中使用的前缀类和ID

发现**包含不仅用于使用CSS设置元素样式的类**，而且还**使用JavaScript作为选择器的类**;
一个简单的解决方法是在**js-之前添加仅用于JavaScript的类和ID的名称**。

## 使用类修改元素样式

在**JavaScript中更改样式通常意味着通过其样式属性向元素添加内联样式**，这使得这些样式**成为最具体的样式**。

**如果需要更改元素的样式，则不仅需要搜索CSS文件以查找现有样式，而且还需要在该搜索中包含JavaScript文件**。

**不是通过使用JavaScript将HTML元素添加到其样式属性来修改HTML元素的样式**，而是应该在**元素中添加或删除类**。

## 使用类

**类可以在页面上根据需要重复使用多次，并且它们具有相当低的特异性**，因此可以轻松地重写它们。

ID几乎正好相反;它们具有**非常高的特异性**，**因此它们不能轻易被覆盖，并且每页最多应使用一次**。在为不断变化的网站编写CSS时，应该使用类来设置元素的样式

## 分配类有意义的名称

有意义的类名称**通过表达正在设计的内容来提供上下文**，而不会给出的细节，但也没有给出如此多的细节以至于它阻碍了代码的重用

## 避免过度模块化的类

有意义的类名称描述**被设计样式的元素**，而**不是描述应用于元素的样式**

```html
<h1 class="font-bold uppercase blue-text margin-bottom-large no-padding"> 
    Too Many CSS Classes
</h1>
```

这些类描述了元素的样式。另外，据说这些类受到过度模块化的影响 - 因为**每个类只应用一种风格，它们总是需要一起使用。应该避免过度模块化的类，因为它们并不比使用内联样式好多少**

```css
.section-title { 
    color: #1200FF; 
    font-weight: bold;
    margin-bottom: 20px;
    padding: 0;
    text-transform: uppercase; 
}

```

## 打造更好的盒子

### content-box or border-box 

**border-box 因为它描述了从边界到边界的元素的总高度和宽度，而不仅仅是内容的尺寸**。可以在任何元素上设置box-sizing

