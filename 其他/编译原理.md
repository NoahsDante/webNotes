## 编译器概述

编译器的实质是一个 **程序**。其核心功能是将 **源代码** 翻译成 **目标**

**解释器** 和编译器相同都是一种程序，源代码输入**通过编译器输出得到的是可执行程序**。输入通过解释器得到的输出得到的直接就是一个结果。

相对来说，编译器是一种离线的模式，解释器是一种在线的模式

## 编译器结构

编译器具有非常模块化的高层结构

由于编译器实现的是将源代码转化为目标代码的功能。所以对于编译器的结构可以大致分为前端和后端两部分，前段处理输入源程序，后端处理输出目标代码

## 词法分析

如图所示：

![https://raw.githubusercontent.com/NoahsDante/webNotes/master/%E5%85%B6%E4%BB%96/img/6.png](https://raw.githubusercontent.com/NoahsDante/webNotes/master/其他/img/6.png)

词法分析器通常还要和符号表进行交互，当词法分析器发现一个标识符的词素时，将这个词素添加到符号表中。

### 词法分析

##### 词法单元、模式、词素

词法单元：有一个词法单元名和一个可选的属性值组成。

模式：描述了一个词法单元的词素可能具有的形式；

词素：是源程序中的一个字符序列；

词法分析器读入组成源程序的字符流，将它们组成有意义的词素序列。对于每个词素，词法分析器**词法单元（token）作为输出

````js
<token-name,attribute-value>
````

例如：

```js
position = initial + rate * 60;
```

经词法分析变成

```js
<id,1> <=> <id,2> <+> <id,3> <*> <60>
```



字符流 => 词法分析 => 记号流

```js
if ( x > 5)
  y = "hello";
else 
  z = 1;
```

将字符经过词法分析成一个个单词

```js
IF LPAREN IDENT(X) GT INT(5) RPAREN
		IDENT(Y) ASSIGN STRING("hell0") SEMICOLON
ELSE
		IDENT(Z) ASSIGN INT(1) SEMICOLON EOF
```

词法分析器的任务

> 将字符流到记号流

- 字符流：和被编译器的语言密切相关
- 记号流：编译器内部定义的数据结构，编码所识别出的词法单元

### 词法分析器的实现方法

#### 手工编码

- 相对复杂、且容易出错

#### 词法分析器的生成器

- 快速原型、代码量较少
- 较难控制细节

### 有限状态自动机

有限自动机是更一般化的状态转化图。分为确定有限自动机（DFA）和不确定有限自动机（NFA）

#### 非确定状态机（NFA）

对任意的字符，有多个状态可以转移

#### 确定状态机（DFA）

对任意的字符，最多有一个状态可以转移

#### 区别

接口字符；如果是NFA是需要遍历多个状态转移；DFA直接是一个情况 

### 正则表达式到非确定状态机（RE -> NFA）

#### Thompson算法

基于对RE的结构做归纳

- 对基本的RE直接构造
- 对复合的RE递归构造

递归算法，容易实现



