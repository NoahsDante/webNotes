# 构造过程抽象

## 程序设计的基本元素

### 表达式

一种基本的表达式就是数；有数字组成的表达式；

用基本过程的表达式形式（例如+或者*）；将表示数的表达式组合起来；形成复合表达式，以表示要把有关过程应用于这些数；其称为**组合表达**

### 命名和环境

提供一种通过名字去使用计算对象的方式。将名字标识符称为变量，它的值就是他所对应的那个对象；

每次需要使用它们时，不需要重复地写出它们的细节，这样是极为方便的事。

### 组合式的求值

1. 求值该组合式的各个子表达式
2. 将作为最左表达式的值的那个过程应用于相应的实际参数

处理这些基础情况的方式规定：

1. 数的值就是它们所表示的数值
2. 内部运算符的值就是能完成相应操作的机器指令序列
3. 其他名字的值就是在环境中关联这一名字的那个对象

环境**所扮演的角色就是用于确定表达式中各个符号的意义**；它为求值过程的进行提供了一种上下文

### 复合过程

通过**复合操作提供名字，就可以将这样的操作作为一个单元使用**

### 过程应用的代换模型

将复合过程应用于实际参数，就是在将过程中的每个形参用相应的实参取代之后，对这一过程体求值。 - 代换模式

代**换的作用只是为了帮助领会过程调用中的情况，而不是对解释器实际工作方式的具体描述**

#### 应用序与正则序

应用序：**先求值参数而后应用**（避免部分表达式的重复计算）

正则序：**完全展开而后归约**

### 条件表达式和谓词

依据检测的结果去确定做不同的操作；

```
cond (<p><e>)
```

**每个对偶中的第一个表达式就是谓词**

构建复合谓词

1. and
2. or
3. not

### 过程作为黑箱抽象

这样做，我们根本无须关注这个过程是如何计算出它的结果，只需要考虑它能干什么的事实 - **过程的抽象**

在任何做相同的的过程都可以用。

#### 局部名

就是在有关的过程里面形式参数的名字；由实现者所选用

在这里，形式参数的具体名字是什么，其实完全没有关系，这样的名字称为约束变量，一个过程的定义约束了它的所有形式参数。如果在一个完整的过程定义里将某个约束变量统一换名，一个过程将不会有任何改变。

如果一个变量不是被约束，就称为自由的；

一个名字的定义被约束于的那一集表达式称为这个名字的作用域，在这个过程定义里，被声明为这个过程的形式参数的那些约束变量，就以这个过程体作为它们的**作用域**

#### 内部定义和块结构

允许一个过程带有一些内部定义，使它们是局部于这一过程；这种嵌套的定义称为**块作用域**

在自己定义的内部块定义的约束变量称为**词法作用域**

## 过程与它们所产生的计算

一个过程就是一种模式，它描述一个计算过程的局部演化方式，描述了这一计算过程中的每个步骤是怎样基于前面的步骤建立起来的。

### 线性的递归和迭代

递归：代换模型揭示出一种先逐步展开而后收缩的形状；在展开阶段里，这一计算过程构造起一个推迟进行的操作所形成的链条，收缩阶段表现为这些运算的实际执行。要执行这种计算过程有，解释器就需要维护好那些以后将要执行的操作的轨迹。**还存在着其他的"隐含"信息，它们并未保存在程序变量中，而是由解释器维持着，指明了在推迟的运算所形成的链条里；这个链条越长，需要保存的信息也就越多。**

迭代：需要保存轨迹里，所有东西就是变量的当前值，就是那种其状态可以用固定数目的状态变量描述的计算过程；而与此同时，有存在一套固定的规则，描述了计算过程在从一个状态到下一状态转换时，这些变量的更新方式；还有一个结束检测，它描述这一计算过程应该终止的条件。**那几个程序变量都提供了有关计算状态的一个完整描述；如果我们令计算在某个步骤停下来，想要重新唤起计算，只需要为解释器提供有关这些变量的值。**

## 用高阶函数做抽象

如果将过程限制为只能以数作为参数，将会严重限制抽象的能力；经常有同样的程序设计模式能用于若干不同的过程；为了把这个模式描述为相应的概念，就需要构造出这样的过程，让它们以过程作为参数，或以过程作为返回值。

### 过程作为参数

将相同的部分抽象出来，以过程作为参数传入到过程体内；使其它地方复用；

### 用lambda构造过程

匿名构造，直接使用输入与输入的返回过程；这种过程没有与环境中的任何名字相关联

#### 用let创建局部变量

let 表达式的第一部分是个名字 - 表达式对偶的表，当let被求值时，这里的每个名字将被关联于对应表达式的值；

- let使人能尽可能接近其使用的地方建立局部变量约束
- 变量的值是在let之外计算的。在为局部变量提供值的表达式依赖于某些与局部变量同名的变量时，这一规定就起作用了·

### 过程作为返回值

能得到进一步表达能力；知道如何选择过程的形式，使其特别地清晰且易理解使该计算过程中有用的元素能表现为一些相互分离的个体，并使它们还可能重新用于其他的应用。

#### 抽象和第一级过程

设法从识别出程序里的基本抽象，基于它们去进一步构造，并推广它们以创建威力更大的抽象。

带有最少限制的元素被称为具有第一级的状态。

- 可以用于变量命名
- 可以提供过程作为参数
- 可以由过程作为结果返回
- 可以包含在数据结构中

# 构造数据抽象

将数据对象组合起来，形成复合数据的方式；提升在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。

## 数据抽象引导

它使我们能将一个复合数据对象的**使用**，与该数据对象怎样由更基本的数据对象构造起来的**细节隔离**

### 抽象屏蔽

对于数据的操作方式与抽象过程；隔离了系统中不同的层次，这种屏障都把**使用数据抽象的程序与实现数据抽象的程序分开来**。

#### 优点

1. 很容易维护和修改，任何一种比较复杂的数据结构，都可以以多种不同方式用程序设计语言所提供的基本数据结构表示。（如果后来表示方式改变了，所有受影响的程序也都需要随之改变）
2. 当无法确定究竟是在创建时执行，还是将它推迟到选择的时候，数据抽象方法能推迟决策的时间，而又不会阻碍系统其他部分的工作进展

### 数据意味着什么

- 一组适当的选择函数和构造函数，以及使这些过程成为一套合法表示，它们就必须满足的一组特定条件。

## 层次性数据和闭包性质

可以建立元素本身是序对的序对，称为闭包性质；通过它组合数据对象得到的结果本身还可以通过同样的操作再进行组合。它使我们能够建立起层次性的结构。

### 序列的表示

利用序对可以构造出一类有用结构序列 - 数据对象的有序汇集；通过嵌套的cons形成的序对的序列称为一个表。

### 层次性结构

元素本身是序列，可以把他们看成树结构；

递归是处理树结构的一种很自然的工具；对于树的操作归结为对它们的分支操作，再将这种操作归结为分支的操作；

### 序列作为一种约定

将程序表示一些针对序列的操作，可以能帮助我们得到模块化的程序设计，由一些比较独立的片段的组合构成的设计；有着一些以各种灵活的方式相互连接的约定界面，将能进一步推动人们去做模块化设计。

模块化结构是控制复杂性的一种威力强大的策略。

通过修改这些操作，可以在序列的不同表示之间转换，并保存程序的整个设计不变

## 符号数据

引进将任意符号作为数据的功能

### 引号

为了能够操作这些符号，为数据对象加引号

## 抽象数据的多重表示

将程序的设计与实现工作相互分离，关键思想就是构建抽象屏障；通过对数据对象基础表示的屏蔽，可以设计一个大程序的任务；

需要有抽象屏障相互不同的设计选择，以便允许不同的设计选择在同一程序里共存。

需要构建通用型过程，而采用的主要技术是带有类型标志的数据工作

### 带标志数据

带有通用标志性有所缺陷：

- 如果需要增加新的类型，需要所有重新添加一遍
- 同时必须保证在整个系统里不存在两个名字相同

### 数据导向的程序设计

利用表格工作的程序设计技术

- 消除类型判断

- 容易添加新的类型

  

## 带有通用型操作的系统

### 不同类型数据的组合

处理跨类型操作的一种方式，就是为每一种类型组合的合法算法设计一个特定过程

#### 强制

把一种类型的对象看作另一种类型的对象；能把一个类型的对象转换到另一类型的等价对象

#### 类型的层次结构

将不同的两个类型，转换成同一层类型，使其进行操作；当系统遇到需要对两个不同类型的运算时，它就可以逐步提升较低的类型，直到所有对象都达到了同一层次；

同时每个类型能够"继承"其他超类型中定义的操作；使我们有一种简单的方式"下降"一个数据对象，使之达到最简单的表示形式；

# 模块化、对象和状态

为了帮助构造起模块化的大型系统；需要是基于被模拟系统的结构去设计程序的结构；

需要针对系统中的新对象或者新活动扩充对应的计算模型时，我们能够不必对程序做全面的修改，只需要加入这些对象或者动作相对应的新的符号和对象；

- 将大型系统看成一大批对象，它们的行为可能随着时间的进展而不断变化
- 在流过系统的信息，进行处理

## 赋值和局部状态

每个对象都可能通过交互作用；交互就是建立起一个对象的状态变量与其他对象的状态变量之间的联系；此时将这个系统看作是由一些独立对象组成的观点

要使一个模型成为模块化，就要求它能分解为一批计算对象，使他们能够模拟系统里的实际对象。每一个计算对象必须有自己的一些局部状态变量，用于描述实际对象的状态。

### 局部状态变量

保护对象的实际状态，外部访问必须通过间接方式；

### 引进赋值带来的利益

能有效减低使用程序所需要记住的部分；

从一个复杂计算过程中一部分观点来看，其他部分都像是在随着时间不断变化，它们隐藏起自己的随时间变化的内部状态。

用局部变量去模拟系统的状态，用这些变量的赋值去模拟状态的变化；

### 引进赋值的代价

一个变量就不再是一个简单的名字了；现在的一个变量索引着一个可以保存值的位置；而存储在东方的值也是可以改变的；

带有赋值的程序将强迫人们去考虑赋值的相对顺序，以保证每个语句所用的是被修改变量的正确版本；

## 求值的环境模型

由于赋值的存在，变量已经不再看作仅仅是某个值的名字。此时的一个变量必须以某种方式指定了一个“位置”；相应的值可以存储在那里，这种位置将维持在称为“环境”的结构中

环境求值对于求值过程是至关重要的，因为它确定了表达式的上下文；

### 求值规则

在将一个过程应用于一组实际参数时，将会建立起一个新的环境，其中包含了将所有形式参数约束于对应的实际参数框架；该框架的外围环境就是所用的之前定义的过程的环境

## 用变动数据做模拟

### 变动的表结构

### 队列的表示

队列就是数据项的序列；为了插入一个数据项，就必须扫描整个表，直至到达表尾；这是非常低效的；

采用表的形式，将列表示为一个表，并带有一个指向表的最后序对的指针；

如果我们需要插入入一个数据时，就只需考察这个尾指针，因此就可以避免对表的扫描

### 约束的传播

## 并发：时间是一个本质问题

### 并发系统中时间的性质

并发这一复杂的根源，就在于这里出现了对不同进程之间共享的变量的赋值，

对于并发一种可能限制方式时规定；修改任意共享状态变量的两个操作都不允许同时发生；

### 控制并发的机制

#### 对共享变量的串行访问

使进程可以并发地执行，但是其中有一些过程不能并发地执行；

串行化就是创建一些不同的过程集合，并且保证在每个时刻。在任何一个串行化集合里至多只有一个过程的一个执行。

如果某个集合里有过程正在执行，而另一个进程企图执行这个集合里的任何过程时，就必须等待到前一过程的执行结束。

#### 互斥元

是一种对象，假定提供了两个操作，一个互斥元可以被获取或者被释放；一旦某个互斥元被获取，对于这个互斥元的任何其他获取操作都必须等到该互斥元被释放之后。

## 流

### 流作为延时的表

### 无穷流

### 流计算模式的使用

### 流和延时求值

### 函数式程序的模块化和对象的

### 模块化

# 元语言抽象

## 元循环求值器

### 求值器的表示

### 表达式的表示

### 求值器数据结构

### 作为程序运行这个求值器

### 将数据作为程序

### 内部定义

### 将语法分析与执行分离

## scheme的变形 - 惰性求值

### 正则序和应用序

### 一个采用惰性求值的解释器

### 将流作为惰性的表

## scheme的变形 - 非确定性计算

### amb和搜索

### 非确定性程序的实力

### 实现amb求值器

## 逻辑程序设计

### 演绎信息检索

### 查询系统如何工作

### 逻辑程序设计是数理逻辑吗

### 查询系统的实现

# 寄存器机器的设计

## 寄存器机器的设计

### 一种描述寄存器机器的语言

### 机器设计的抽象

### 子程序

### 采用堆栈实现递归

### 指令总结

## 一个寄存器机器模拟器

### 机器模型

### 汇编程序

### 为指令生成执行过程

### 监视机器执行

## 存储分配和废料收集

### 将存储看作向量

### 维持一种无穷存储的假象

## 显式控制的求值器

### 显式控制求值器的内核

### 序列的求值和尾递归

### 条件、赋值和定义

### 求值器的运行

## 编译

### 编译器的结构

### 表达式的编译

### 组合式编译

### 编译代码的实例

### 词法地址

### 编译代码与求值器的互连

