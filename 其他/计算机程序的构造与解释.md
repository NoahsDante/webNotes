# 构造过程抽象

## 程序设计的基本元素

### 表达式

一种基本的表达式就是数；有数字组成的表达式；

用基本过程的表达式形式（例如+或者*）；将表示数的表达式组合起来；形成复合表达式，以表示要把有关过程应用于这些数；其称为**组合表达**

### 命名和环境

提供一种通过名字去使用计算对象的方式。将名字标识符称为变量，它的值就是他所对应的那个对象；

每次需要使用它们时，不需要重复地写出它们的细节，这样是极为方便的事。

### 组合式的求值

1. 求值该组合式的各个子表达式
2. 将作为最左表达式的值的那个过程应用于相应的实际参数

处理这些基础情况的方式规定：

1. 数的值就是它们所表示的数值
2. 内部运算符的值就是能完成相应操作的机器指令序列
3. 其他名字的值就是在环境中关联这一名字的那个对象

环境**所扮演的角色就是用于确定表达式中各个符号的意义**；它为求值过程的进行提供了一种上下文

### 复合过程

通过**复合操作提供名字，就可以将这样的操作作为一个单元使用**

### 过程应用的代换模型

将复合过程应用于实际参数，就是在将过程中的每个形参用相应的实参取代之后，对这一过程体求值。 - 代换模式

代**换的作用只是为了帮助领会过程调用中的情况，而不是对解释器实际工作方式的具体描述**

#### 应用序与正则序

应用序：**先求值参数而后应用**（避免部分表达式的重复计算）

正则序：**完全展开而后归约**

### 条件表达式和谓词

依据检测的结果去确定做不同的操作；

```
cond (<p><e>)
```

**每个对偶中的第一个表达式就是谓词**

构建复合谓词

1. and
2. or
3. not

### 过程作为黑箱抽象

这样做，我们根本无须关注这个过程是如何计算出它的结果，只需要考虑它能干什么的事实 - **过程的抽象**

在任何做相同的的过程都可以用。

#### 局部名

就是在有关的过程里面形式参数的名字；由实现者所选用

在这里，形式参数的具体名字是什么，其实完全没有关系，这样的名字称为约束变量，一个过程的定义约束了它的所有形式参数。如果在一个完整的过程定义里将某个约束变量统一换名，一个过程将不会有任何改变。

如果一个变量不是被约束，就称为自由的；

一个名字的定义被约束于的那一集表达式称为这个名字的作用域，在这个过程定义里，被声明为这个过程的形式参数的那些约束变量，就以这个过程体作为它们的**作用域**

#### 内部定义和块结构

允许一个过程带有一些内部定义，使它们是局部于这一过程；这种嵌套的定义称为**块作用域**

在自己定义的内部块定义的约束变量称为**词法作用域**

## 过程与它们所产生的计算

一个过程就是一种模式，它描述一个计算过程的局部演化方式，描述了这一计算过程中的每个步骤是怎样基于前面的步骤建立起来的。

### 线性的递归和迭代

递归：代换模型揭示出一种先逐步展开而后收缩的形状；在展开阶段里，这一计算过程构造起一个推迟进行的操作所形成的链条，收缩阶段表现为这些运算的实际执行。要执行这种计算过程有，解释器就需要维护好那些以后将要执行的操作的轨迹。**还存在着其他的"隐含"信息，它们并未保存在程序变量中，而是由解释器维持着，指明了在推迟的运算所形成的链条里；这个链条越长，需要保存的信息也就越多。**

迭代：需要保存轨迹里，所有东西就是变量的当前值，就是那种其状态可以用固定数目的状态变量描述的计算过程；而与此同时，有存在一套固定的规则，描述了计算过程在从一个状态到下一状态转换时，这些变量的更新方式；还有一个结束检测，它描述这一计算过程应该终止的条件。**那几个程序变量都提供了有关计算状态的一个完整描述；如果我们令计算在某个步骤停下来，想要重新唤起计算，只需要为解释器提供有关这些变量的值。**

## 用高阶函数做抽象

如果将过程限制为只能以数作为参数，将会严重限制抽象的能力；经常有同样的程序设计模式能用于若干不同的过程；为了把这个模式描述为相应的概念，就需要构造出这样的过程，让它们以过程作为参数，或以过程作为返回值。

### 过程作为参数

将相同的部分抽象出来，以过程作为参数传入到过程体内；使其它地方复用；

### 用lambda构造过程

匿名构造，直接使用输入与输入的返回过程；这种过程没有与环境中的任何名字相关联

#### 用let创建局部变量

let 表达式的第一部分是个名字 - 表达式对偶的表，当let被求值时，这里的每个名字将被关联于对应表达式的值；

- let使人能尽可能接近其使用的地方建立局部变量约束
- 变量的值是在let之外计算的。在为局部变量提供值的表达式依赖于某些与局部变量同名的变量时，这一规定就起作用了·

### 过程作为返回值

能得到进一步表达能力；知道如何选择过程的形式，使其特别地清晰且易理解使该计算过程中有用的元素能表现为一些相互分离的个体，并使它们还可能重新用于其他的应用。

#### 抽象和第一级过程

设法从识别出程序里的基本抽象，基于它们去进一步构造，并推广它们以创建威力更大的抽象。

带有最少限制的元素被称为具有第一级的状态。

- 可以用于变量命名
- 可以提供过程作为参数
- 可以由过程作为结果返回
- 可以包含在数据结构中

# 构造数据抽象

将数据对象组合起来，形成复合数据的方式；提升在设计程序时所位于的概念层次，提高设计的模块性，增强语言的表达能力。

## 数据抽象引导

它使我们能将一个复合数据对象的**使用**，与该数据对象怎样由更基本的数据对象构造起来的**细节隔离**

### 抽象屏蔽

对于数据的操作方式与抽象过程；隔离了系统中不同的层次，这种屏障都把**使用数据抽象的程序与实现数据抽象的程序分开来**。

#### 优点

1. 很容易维护和修改，任何一种比较复杂的数据结构，都可以以多种不同方式用程序设计语言所提供的基本数据结构表示。（如果后来表示方式改变了，所有受影响的程序也都需要随之改变）
2. 当无法确定究竟是在创建时执行，还是将它推迟到选择的时候，数据抽象方法能推迟决策的时间，而又不会阻碍系统其他部分的工作进展

### 数据意味着什么

- 一组适当的选择函数和构造函数，以及使这些过程成为一套合法表示，它们就必须满足的一组特定条件。

## 层次性数据和闭包性质

可以建立元素本身是序对的序对，称为闭包性质；通过它组合数据对象得到的结果本身还可以通过同样的操作再进行组合。它使我们能够建立起层次性的结构。

### 序列的表示

利用序对可以构造出一类有用结构序列 - 数据对象的有序汇集；通过嵌套的cons形成的序对的序列称为一个表。

### 层次性结构

元素本身是序列，可以把他们看成树结构；

递归是处理树结构的一种很自然的工具；对于树的操作归结为对它们的分支操作，再将这种操作归结为分支的操作；

### 序列作为一种约定

将程序表示一些针对序列的操作，可以能帮助我们得到模块化的程序设计，由一些比较独立的片段的组合构成的设计；有着一些以各种灵活的方式相互连接的约定界面，将能进一步推动人们去做模块化设计。

模块化结构是控制复杂性的一种威力强大的策略。

通过修改这些操作，可以在序列的不同表示之间转换，并保存程序的整个设计不变

## 符号数据

引进将任意符号作为数据的功能

### 引号

为了能够操作这些符号，为数据对象加引号

## 抽象数据的多重表示

### 复数的表示

### 带标志数据

### 数据导向的程序设计

## 带有通用型操作的系统

### 通用型算术运算

### 不同类型数据的组合

# 模块化、对象和状态

## 赋值和局部状态

### 局部状态变量

### 引进赋值带来的利益

### 引进赋值的代价

## 求值的环境模型

### 求值规则

### 简单过程的应用

### 将架构看作局部状态的展台

### 内部定义

## 用变动数据做模拟

### 变动的表结构

### 队列的表示

### 表格的表示

### 数字电路的模拟器

### 约束的传播

## 并发：时间是一个本质问题

### 并发系统中时间的性质

### 控制并发的机制

## 流

### 流作为延时的表

### 无穷流

### 流计算模式的使用

### 流和延时求值

### 函数式程序的模块化和对象的

### 模块化

# 元语言抽象

## 元循环求值器

### 求值器的表示

### 表达式的表示

### 求值器数据结构

### 作为程序运行这个求值器

### 将数据作为程序

### 内部定义

### 将语法分析与执行分离

## scheme的变形 - 惰性求值

### 正则序和应用序

### 一个采用惰性求值的解释器

### 将流作为惰性的表

## scheme的变形 - 非确定性计算

### amb和搜索

### 非确定性程序的实力

### 实现amb求值器

## 逻辑程序设计

### 演绎信息检索

### 查询系统如何工作

### 逻辑程序设计是数理逻辑吗

### 查询系统的实现

# 寄存器机器的设计

## 寄存器机器的设计

### 一种描述寄存器机器的语言

### 机器设计的抽象

### 子程序

### 采用堆栈实现递归

### 指令总结

## 一个寄存器机器模拟器

### 机器模型

### 汇编程序

### 为指令生成执行过程

### 监视机器执行

## 存储分配和废料收集

### 将存储看作向量

### 维持一种无穷存储的假象

## 显式控制的求值器

### 显式控制求值器的内核

### 序列的求值和尾递归

### 条件、赋值和定义

### 求值器的运行

## 编译

### 编译器的结构

### 表达式的编译

### 组合式编译

### 编译代码的实例

### 词法地址

### 编译代码与求值器的互连

