# http概述

Web 浏览器、服务器和相关的 Web 应用程序都是通过 HTTP 相互通信

## 资源

源不一定非得是静态文件。资源还可以是根据需要生成内容的软件程序

### URI

每个 Web 服务器资源都有一个名字，这样客户端就可以说明它们感兴趣的资源是什么了。**服务器资源名被称为统一资源标识符（Uniform Resource Identi?er，URI）**。URI 就像因特网上的邮政地址一样，在世界范围内唯一标识并定位信息资源

### URL

**统一资源定位符（URL）**是资源标识符最常见的形式； 描述了一台特定服务器上某资源的特定位置；明确说明如何从一个精确、固定的位置获取资源

大部分 URL 都遵循一种标准格式，这种格式包含三个部分

1. 第一部分被称为方案（scheme），说明了访问资源所使用的协议类型。这部分通常就是 HTTP 协议（http://）
2. 第二部分给出了服务器的因特网地址（比如，[www.joes-hardware.com](http://www.joes-hardware.com)）
3. 其余部分指定了Web 服务器上的某个资源

### URN

**统一资源名（URN）**。URN 是作为特定内容的唯一名称使用的，**与目前的资源所在地无关。使用这些与位置无关的 URN，就可以将资源四处搬移。**通过 URN，还可以用同一个名字通过多种网络访问协议来访问资源

urn:ietf:rfc:2141

## 事务

一个 HTTP 事务由一条（从客户端发往服务器的）请求命令和一个（从服务器发回客户端的）响应结果组成

### 方法

- GET
- PUT
- DELETE
- POST
- HEAD

### 状态码

每条 HTTP 响应报文返回时都会携带一个状态码。**状态码是一个三位数字的代码，告知客户端请求是否成功，或者是否需要采取其他动作**

### Web页面中可以包含多个对象

应用程序完成一项任务时通常会发布多个 HTTP 事务。

## 报文

HTTP 报文是由一行一行的简单字符串组成的。HTTP 报文都是纯文本，不是二进制代码，所以人们可以很方便地对其进行读写

**从 Web 客户端发往 Web 服务器的 HTTP 报文称为请求报文（request message）**。**从服务器发往客户端的报文称为响应报文（response message）**

HTTP 报文包括以下三个部分

- 起始行

  报文的第一行就是起始行，**在请求报文中用来说明要做些什么，**在**响应报文中说明出现了什么情况**

- 首部字段

  起始行后面有零个或多个首部字段。**每个首部字段都包含一个名字和一个值，为了便于解析，两者之间用冒号（:）来分隔。**首部以一个空行结束。添加一个首部字段和添加新行一样简单

- 主体

  空行之后就是可选的报文主体了，其中包含了所有类型的数据。请求主体中包括了要发送给 Web 服务器的数据；响应主体中装载了要返回给客户端的数据。起始行和首部都是文本形式且都是结构化；

  体中可以包含任意的二进制数据（比如图片、视频、音轨、软件程序）。当然，主体中也可以包含文本

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/1.png)

## 连接

讨论一下报文是如何通过传输控制协议（Transmission Control Protocol，TCP）连接从一个地方搬移到另一个地方去

### TCP/IP

- 无差错的数据传输
- 按序传输（数据总是会按照发送的顺序到达）
- 未分段的数据流（可以在任意时刻以任意尺寸将数据发送出去）

TCP/IP 隐藏了各种网络和硬件的特点及弱点，使各种类型的计算机和网络都能够进行可靠地通信；只要建立了 TCP 连接，客户端和服务器之间的报文交换就不会丢失、不会被破坏，也不会在接收时出现错序了

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/2.png)

### 连接、IP地址及端口号

**在 HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP）地址和端口号在客户端和服务器之间建立一条 TCP/IP 连接**

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/3.png)

#### 步骤

1. 浏览器从 URL 中**解析出服务器的主机名**；
2. 浏览器将服务器的**主机名转换成服务器的 IP 地址**；
3. 浏览器将端口号（如果有的话）从 URL 中解析出来；
4. 浏览器**建立一条与 Web 服务器的 TCP 连接；**
5. 浏览器**向服务器发送一条 HTTP 请求报文；**
6. 服务器**向浏览器回送一条 HTTP 响应报文；**
7. **关闭连接，浏览器显示文档。**

## Web 的结构组件

### 代理

**代理位于客户端和服务器之间，接收所有客户端的 HTTP 请求，并将这些请求转发给服务器（可能会对请求进行修改之后转发）**

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/4.png)

### 缓存

Web 缓存（Web cache）或代理缓存（proxy cache）是一种特殊的 HTTP 代理服务器，**可以将经过代理传送的常用文档复制保存起来。下一个请求同一文档的客户端就可以享受缓存的私有副本所提供的服务**

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/5.png)

### 网关

网关（gateway）是一种特殊的服务器，**作为其他服务器的中间实体使用。通常用于将 HTTP 流量转换成其他的协议。网关接受请求时就好像自己是资源的源端服务器一样**。**客户端可能并不知道自己正在与一个网关进行通信**

### 隧道

隧道（tunnel）是建立起来之后，就会在两条连接之间对原始数据进行盲转发的 HTTP 应用程序。**HTTP 隧道通常用来在一条或多条 HTTP 连接上转发非 HTTP 数据，转发时不会窥探数据。**

HTTP 隧道的一种常见用途是**通过 HTTP 连接承载加密的安全套接字层（SSL， Secure Sockets Layer）流量，这样 SSL 流量就可以穿过只允许 Web 流量通过的防火墙**

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/6.png)

### Agent代理

用户 Agent 代理（或者简称为 Agent 代理）是代表用户发起 HTTP 请求的客户端程序。所有发布 Web 请求的应用程序都是 HTTP Agent 代理。到目前为止，我们只提到过一种 HTTP Agent 代理：Web 浏览器，但用户 Agent 代理还有很多其他类型。

比如，有些自己会在 Web 上闲逛的自动用户 Agent 代理，可以在无人监视的情况下发布 HTTP 事务并获取内容。这些自动代理的名字通常都很生动，比如“网络蜘蛛”（spiders）或者“Web 机器人”（Web robots）。网络蜘蛛会在 Web 上闲逛，搜集信息以构建有效的 Web 内容档案

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/7.png)

# URL与资源

就是**因特网资源的标准化名称**。URL 指向一条条电子信息片段，告诉你**它们位于何处，以及如何与之进行交互**

## 浏览因特网资源

URL 是浏览器寻找信息时所需的资源位置。通过 URL，人类和应用程序才能找到、使用并共享因特网上大量的数据资源

**URI 是一类更通用的资源标识符，** **URL 实际上是它的一个子集。URI 是一个通用的概念，**由两个主要的子集 URL 和 URN 构成，**URL 是通过描述资源的位置来标识资源**；**URN则是通过名字来识别资源的，与它们当前所处位置无**

### URL 分以下三部分

1. 第一部分被称为方案（scheme），**说明了访问资源所使用的协议类型。告知 Web 客户端怎样访问资源；**这部分通常就是 HTTP 协议（http://）
2. 第二部分给出了**服务器的因特网地址（比如，[www.joes-hardware.com](http://www.joes-hardware.com)）；服务器的位置**
3. 第三部分**资源路径。路径说明了请求的是服务器上哪个特定的本地资源**

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/8.png)

**URL可以通过HTTP之外的其他协议来访问资**

URL 提供了一种统一的资源命名方式。大多数 URL 都有同样的：**“方案 :// 服务器位置 / 路径”结构**

URL 为应用程序**提供了一种访问资源的手段；**

为**用户及他们的浏览器提供了找到信息所需的所有条件；**

定义了用户所需的特定资源，它位于何处以及如何获取它

## URL 的语法

### 方案——使用什么协议

方案实际上是规定如何访问指定资源的主要标识符，它会**告诉负责解析 URL 的应用程序应该使用什么协议；**方案组件必须以**一个字母符号开始，由第一个“:”符号将其与 URL 的其余部分分隔开来**。方案名是大小写无关

### 主机与端口

主机组件标识了因特网上能够访问资源的宿主机器。可以用上述主机名（[www.joeshardware.com](http://www.joeshardware.com)），或者 IP 地址来表示主机名

### 用户名和密码

FTP 服务器就是这样一个常见的实例

```
ftp://anonymous@ftp.prep.ai.mit.edu/pub/gnu
ftp://anonymous:my_passwd@ftp.prep.ai.mit.edu/pub/gnu
```

### 路径

路径组件说明了资源位于服务器的什么地方。路径通常很像一个分级的文件系统路径。

### 参数

为了向应用程序提供它们所需的输入参数，以便正确地与服务器进行交互。

这个组件就是 URL 中的名值对列表，由字符“;”将其与 URL 的其余部分（以及各名值对）分隔开来

```
ftp://prep.ai.mit.edu/pub/gnu;type=d
http://www.joes-hardware.com/hammers;sale=false/index.html;graphics=true
```

### 查询字符串

可以通过提问题或进行查询来缩小所请求资源类型范围。只有问号（?）右边的内容；URL 的查询组件和标识网关资源的 URL 路径组件一起被发送给网关资源；值对之间用字符“&”分隔

### 片段

除了资源级之外，还可以做进一步的划分；能够指定资源中的那些章节。URL 支持使用片段（frag）组件来表示一个资源内部的片段；最前面有一个字符“#”

## URL 快捷方式

相对 URL 是在某资源内部**指定一个资源的便捷缩略方式。**

很多浏览器还**支持 URL 的“自动扩展”，也就是用户输入 URL 的一个关键（可记忆的）部分，然后由浏览器将其余部分填充起来。**

### 相对URL

URL 有两种方：绝对的和相对。

### 自动扩展URL

有些浏览器会在用户提交 URL 之后，或者在用户输入的时候尝试着自动扩展 URL。这就为用户提供了一条捷径：用户不需要输入完整的 URL，因为浏览器会自动扩展。

## 各种字符

### URL字符集

通过转义序列，就可以用 US-ASCII 字符集的有限子集对任意字符值或数据进行编码

### 编码机制

用来在 URL 中表示各种不安全的字符

### 字符限制

在 URL 中，有几个字符被保留起来，有着特殊的含义。有些字符不在定义的US-ASCII 可打印字符集中。还有些字符会与某些因特网网关和协议产生混淆

保留及受限字符

% / . .. # ? ; : $ + @ & = {} | \ ^ ~ [] '' <> ""   0x00-0x1F, 0x7F  >0x7F 

## 方案的世界

http 、https、mailto、ftp、rtsp、rtspu、file、news、telnet、

# HTTP报文

如果说 HTTP 是因特网的信使，那么 HTTP 报文就是它用来搬东西的包裹

## 报文流

HTTP **报文是在 HTTP 应用程序之间发送的数据块**。这些数据块**以一些文本形式的元信息（meta-information）开头，这些信息描述了报文的内容及含义，后面跟着可选的数据部分**。这些报文在客户端、服务器和代理之间流动。术语“流入”、“流出”、“上游”及“下游”都是用来描述报文方向

### 报文流入源端服务器

**HTTP 使用术语流入（inbound）和流出（outbound）来描述事务处理（transaction）的方向**。报文流入源端服务器，工作完成之后，会流回用户的 Agent 代理中

### 报文向下游流动

HTTP 报文会像河水一样流动。不管是请求报文还是响应报文，**所有报文都会向下游（downstream）流动**。所有**报文的发送者都在接收者的上游（upstream）**

## 报文的组成部分

HTTP 报文是简单的格式化数据块。

每条报文都包含一条来自客户端的请求，或者一条来自服务器的响应。它们由三个部分组成：对报文进行描述的**起始行（start line）、包含属性的首部（header）块，以及可选的、包含数据的主体（body）部分**

**起始行和首部就是由行分隔的 ASCII 文本。**每行都以一个由**两个字符组成的行终止序列作为结束，其中包括一个回车符（ASCII 码 13）和一个换行符（ASCII 码 10）**。这个行终止序列可以写做 CRLF

实体的主体或报文的主体（或者就称为主体）是一个可选的数据块。与起始行和首部不同的是，**主体中可以包含文本或二进制数据，也可以为空**

### 报文的语法

所有的 HTTP 报文都可以分为两类：
请求报文（request message）和响应报文（response message）。

请求报文会向 Web 服务器请求一个动作。

响应报文会将请求的结果返回给客户端。请求和响应报文的基本报文结构相同

#### 请求报文的格式：

```text
<method> <request-URL> <version>
<headers>

<entity-body>
```

#### 响应报文的格

```text
<version> <status> <reason-phrase>
<headers>

<entity-body>
```

#### 方法（method）

客户端**希望服务器对资源执行的动作。是一个单独的词，比如 GET、HEAD 或 POST。**

#### 请求 URL（request-URL）

**命名了所请求资源，或者 URL 路径组件的完整 URL。**如果直接与服务器进行对话，只要 URL 的路径组件是资源的绝对路径，通常就不会有什么问题——服务器可以假定自己是 URL 的主机 / 端口

#### 版本（version）

报文所使用的 HTTP 版本

```tex
HTTP/<major>.<minor>
```

其中主要版本号（major）和次要版本号（minor）都是整数

#### 状态码（status-code）

这三位数字描述了请求过程中所发生的情况。每个状态码的第一位数字都用于描述状态的一般类别（“成功”、“出错”等）

#### 原因短语（reason-phrase）

数字状态码的可读版本，包含行终止序列之前的所有文本。如：HTTP/1.0 200 NOT OK 和 HTTP/1.0 200 OK

#### 首部（header）

可以有零个或多个首部，每个首部都**包含一个名字，后面跟着一个冒号（:），然后是一个可选的空格，接着是一个值，最后是一个 CRLF**。**首部是由一个空行（CRLF）结束的，表示了首部列表的结束和实体主体部分的开始**

但由于历史原因，**很多客户端和服务器都在没有实体的主体部分时，（错误地）省略了最后的 CRLF**。为了与这些流行但不符合规则的实现进行互通，客户端和服务器都应该接受那些没有最后那个 CRLF 的报文

#### 实体的主体部分（entity-body）

**实体的主体部分包含一个由任意数据组成的数据块。**并不是所有的报文都包含实体的主体部分，有时，报文只是以一个 CRLF 结束

### 起始行

所有的 HTTP 报文都以一个起始行作为开始。

请求报文的起始行说明了**要做些什么。**

响应报文的起始行说明**发生了什么。**

#### 请求行

请求报文请求服务器对资源进行一些操作。

**包含了一个方法和一个请求 URL，这个方法描述了服务器应该执行的操作，**请求 **URL 描述了要对哪个资源执行这个方法**

所有**这些字段都由空格符分隔**

#### 响应行

响应报文**承载了状态信息和操作产生的所有结果数据，将其返回给客户端。**响应报文的起始行，或称为响应行，包含了响应报文使用的 **HTTP 版本、数字状态码，以及描述操作状态的文本形式的原因短语**

所有**这些字段都由空格符分隔**

#### 方法

请求的起始行以方法作为开始，方法用来告知服务器要做些什么

#### 状态码

告诉客户端，发生了什么事情；状态码是在每条响应报文的起始行中返回

200 到 299 之间的**状态码表示成功**

300 到 399 之间的代码表示**资源已经被移走了**

400 到 499 之间的代码表示**客户端的请求出错了**

500 到 599 之间的代码表示**服务器出错了**

#### 原因短语

是响应起始行中的最后一个组件；为状态码提供了文本形式的解释。如：HTTP/1.0 200 OK 中，OK 就是原因短语。原因短语和状态码是成对出现

#### 版本号

版本号会以 HTTP/x.y 的形式出现在请求和响应报文的起始行中。为 HTTP 应用程序提供了一种将自己所遵循的协议版本告知对方的方式

### 首部

HTTP 首部字段**向请求和响应报文中添加了一些附加信息。**本质上来说，它们只是一些**名 / 值对的列表**

#### 首部分类

- 通用首部

  请求报文与响应报文都可以存在

- 请求首部

  提供更多有关请求的信息

- 响应首部

  提供更多有关响应的信息

- 实体首部

  描述主体的长度和内容，或者资源自身

- 扩展首部

  规范中没有定义的新首部

每个 HTTP 首部都有一种**简单的语法：名字后面跟着冒号（ ：），然后跟上可选的空格，再跟上字段值，最后是一个 CRLF**

### 实体的主体部分

实体的主体是 **HTTP 报文的负荷。就是 HTTP 要传输的内容**。

报文可以承载很多类型的数字数据：图片、视频、HTML 文档、软件应用程序、信用卡事务、电子邮件等

## 方法

### 安全方法

GET 方法和 HEAD 方法都被认为是安全的，这就意味着使用 GET 或 HEAD 方法的 HTTP 请求都不会产生什么动作；HTTP 请求**不会在服务器上产生什么结果**

### GET

通常用于请求服务器发送某个资源

### HEAD

服务器在响应中只返回首部。不会返回实体的主体部分。这就允许客户端在未获取实际资源的情况下，对资源的首部进行检查

- 在不获取资源的情况下了解资源的情况（比如，判断其类型）
- 通过查看响应中的状态码，看看某个对象是否存在
- 通过查看首部，测试资源是否被修改了

### PUT

**PUT 方法会向服务器写入文档**；让**服务器用请求的主体部分来创建一个由所请求的 URL 命名的新文档，或者，如果那个 URL 已经存在的话，就用这个主体来替代它**

### POST

**向服务器输入数据**；通常会用它来支持 HTML 的表单。表单中填好的数据通常会被送给服务器，然后由服务器将其发送到它要去的地方（比如，送到一个服务器网关程序中，然后由这个程序对其进行处理）

### TRACE

请求可能要穿过防火墙、代理、网关或其他一些应用程序。每个中间节点都可能会修改原始的 HTTP 请求。TRACE 方法允许客户端在最终将请求发送给服务器时，看看它变成了什么样子

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/9.png)

TRACE 方法主要用于诊断;TRACE 并不提供区分这些方法的机制;

TRACE 请求中**不能带有实体的主体部分。**

TRACE 响应的**实体主体部分包含了响应服务器收到的请求的精确副本**

### OPTIONS

OPTIONS 方法请求 Web 服务器告知其支持的各种功能。**可以询问服务器通常支持哪些方法，或者对某些特殊资源支持哪些方法**

### DELETE

DELETE 方法所做的事情就是**请服务器删除请求 URL 所指定的资源**。但是，**客户端应用程序无法保证删除操作一定会被执行。因为 HTTP 规范允许服务器在不通知客户端的情况下撤销请求**

## 状态码

### 100～199——信息性状态码

**接受的请求正在处理**

### 200～299——成功状态码

客户端发起请求时，这些请求通常都是成功。

#### 200

表示**从客户端发起的请求在服务器被正常处理了**

#### 204

表示服务器接收请求已成功处理了，但返回的响应报文中不含实体的主体部分；通常表示内容没有发生更新。

#### 206

表示客户端指定范围请求，而服务器成功执行了这部分的请求。

### 300～399——重定向状态码

#### 301 

**永久重定向；表示请求的资源被分配了新的URL，以后应使用资源现在所指向URL；**如果之前的链接保存了标签，那么会按照新的链接重新保存。

#### 302

**临时重定向。表示请求的资源被分配了新的URL，本次使用资源现在所指向URL**

#### 303

表示请求的资源存在新的URL,**应使用GET方法定向获取请求的资源。**

#### 304

**表示客户端发送附带条件请求时，服务器允许请求访问资源。未满足时，将返回304（跟重定向没关系）**

### 400～499——客户端错误状态码

#### 400

表示请求报文中**存在语法错误。**

#### 401

**表示发送的请求需要HTTP认证**

#### 403

表示**请求资源的访问被服务器拒绝。**

#### 404

表示在**服务器上无法找到请求资源。**

### 500～599——服务器错误状态码

#### 500

表示在**服务端执行请求时发生错误。也可能在客户端存在问题bug**

#### 503

表示**服务器暂处于负荷状态或正在进行停机维护，现在无法请求**。

## 首部

**首部和方法配合工作，共同决定了客户端和服务器能做什么事情**

### 通用首部

是客户端和服务器都可以使用的通用首部；提供了与报文相关的最基本的信息

#### Cache-Control

操作缓存的工作机制；指令的参数是可选的，多个指令之间通过“,”分隔

Cache-Control: private, max-age=0, no-cache

缓存请求指令
no-cache	无	强制向源服务器再次验证
no-store	无	不缓存请求或响应的任何内容
max-age = [ 秒]	必需	响应的最大Age值
max-stale( = [ 秒])	可省略	接收已过期的响应
min-fresh = [ 秒]	必需	期望在指定时间内的响应仍有效
no-transform	无	代理不可更改媒体类型
only-if-cached	无	从缓存获取资源
cache-extension	-	新指令标记（token）

缓存响应指令

public	无	可向任意方提供响应的缓存
private	可省略	仅向特定用户返回响应
no-cache	可省略	缓存前必须先确认其有效性
no-store	无	不缓存请求或响应的任何内容
no-transform	无	代理不可更改媒体类型
must-revalidate	无	可缓存但必须再向源服务器进行确认
proxy-revalidate	无	要求中间缓存服务器对缓存的响应有效性再进行确认
max-age = [ 秒]	必需	响应的最大Age值
s-maxage = [ 秒]	必需	公共缓存服务器响应的最大Age值
cache-extension	-	新指令标记（token）

## 请求首部字段

从客户端往服务器端发送请求报文中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容

### Accept

Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8

Accept 首部字段可通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级

### Accept-Charset

Accept-Charset: iso-8859-5, unicode-1-1;q=0.8

用来通知服务器用户代理支持的字符集及字符集的相对优先顺序。另外，可一次性指定多种字符集。与首部字段 Accept 相同的是可用权重 q 值来表示相对优先级

### Accept-Encoding

Accept-Encoding: gzip, deflate

用来告知服务器用户代理支持的内容编码及内容编码的优先级顺序。可一次性指定多种内容编码

### Accept-Language

Accept-Language: zh-cn,zh;q=0.7,en-us,en;q=0.3

来告知服务器用户代理能够处理的自然语言集（指中文或英文等），以及自然语言集的相对优先级。可一次指定多种自然语言集

### Authorization

Authorization: Basic dWVub3NlbjpwYXNzd29yZA==

来告知服务器，用户代理的认证信息（证书值）。通常，想要通过服务器认证的用户代理会在接收到返回的 401 状态码响应后，把首部字段 Authorization 加入请求中。共用缓存在接收到含有 Authorization 首部字段的请求时的操作处理会略有差异

### Expect

Expect: 100-continue

告知服务器，期望出现的某种特定行为。因服务器无法理解客户端的期望作出回应而发生错误时，会返回状态码 417 Expectation Failed

### From

用来告知服务器使用用户代理的用户的电子邮件地址。通常，其使用目的就是为了显示搜索引擎等用户代理的负责人的电子邮件联系方式。使用代理时，应尽可能包含 From 首部字段（但可能会因代理不同，将电子邮件地址记录在 User-Agent 首部字段内

### Host

告知服务器，请求的资源所处的互联网主机名和端口号。Host 首部字段在 HTTP/1.1 规范内是唯一一个必须被包含在请求内的首部字段

### If-Match

If-Match: "123456"

形如 If-xxx 这种样式的请求首部字段，都可称为条件请求。服务器接收到附带条件的请求后，只有判断指定条件为真时，才会执行请求

### If-Modified-Since

If-Modified-Since: Thu, 15 Apr 2004 00:00:00 GMT

会告知服务器若 If-Modified-Since 字段值早于资源的更新时间，则希望能处理该请求。而在指定 If-Modified-Since 字段值的日期时间之后，如果请求的资源都没有过更新，则返回状态码 304 Not Modified 的响应

### If-None-Match

首部字段 If-None-Match 属于附带条件之一。它和首部字段 If-Match 作用相反。用于指定 If-None-Match 字段值的实体标记（ETag）值与请求资源的 ETag 不一致时，它就告知服务器处理该请求

### If-Range

它告知服务器若指定的 If-Range 字段值（ETag 值或者时间）和请求资源的 ETag 值或时间相一致时，则作为范围请求处理。反之，则返回全体资源

### If-Unmodified-Since

If-Unmodified-Since: Thu, 03 Jul 2012 00:00:00 GMT

作用的是告知服务器，指定的请求资源只有在字段值内指定的日期时间之后，未发生更新的情况下，才能处理请求。如果在指定日期时间后发生了更新，则以状态码 412 Precondition Failed 作为响应返回

### Max-Forwards

Max-Forwards: 10

每次转发数值减 1。当数值变 0 时返回响应

服务器在往下一个服务器转发请求之前，Max-Forwards 的值减1 后重新赋值。当服务器接收到 Max-Forwards 值为 0 的请求时，则不再进行转发，而是直接返回响应

### Proxy-Authorization

Proxy-Authorization: Basic dGlwOjkpNLAGfFY5

接收到从代理服务器发来的认证质询时，客户端会发送包含首部字段 Proxy-Authorization 的请求，以告知服务器认证所需要的信息

### Range

对于只需获取部分资源的范围请求，包含首部字段 Range 即可告知服务器资源的指定范围。上面的示例表示请求获取从第 5001 字节至第 10000 字节的资源。
接收到附带 Range 首部字段请求的服务器，会在处理请求之后返回状态码为 206 Partial Content 的响应。无法处理该范围请求时，则会返回状态码 200 OK 的响应及全部资源

### Referer

Referer: http://www.hackr.jp/index.htm

知服务器请求的原始资源的 URI

### TE

#### TE: gzip, deflate;q=0.5

首部字段 TE 会告知服务器客户端能够处理响应的传输编码方式及相对优先级

### User-Agent

User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; rv:13.0) Gecko/20100101 Firefox/13.0.1

创建请求的浏览器和用户代理名称等信息传达给服务器

## 响应首部字段

由服务器端向客户端返回响应报文中所使用的字段，用于补充响应的附加信息、服务器信息，以及对客户端的附加要求等信息

### Accept-Ranges

Accept-Ranges: bytes

用来告知客户端服务器是否能处理范围请求，以指定获取服务器端某个部分的资源；

可指定的字段值有两种，可处理范围请求时指定其为 bytes，反之则指定其为 none

### Age

Age: 600

告知客户端，源服务器在多久前创建了响应。字段值的单位为秒

### ETag

ETag: "82e22293907ce725faf67773957acd12"

知客户端实体标识。它是一种可将资源以字符串形式做唯一性标识的方式。服务器会为每份资源分配对应的 ETag 值。
另外，当资源更新时，ETag 值也需要更新。生成 ETag 值时，并没有统一的算法规则，而仅仅是由服务器来分配

### Location

将响应接收方引导至某个与请求 URI 位置不同的资源。
基本上，该字段会配合 3xx ：Redirection 的响应，提供重定向的 URI

### Proxy-Authenticate

Proxy-Authenticate: Basic realm="Usagidesign Auth"

把由代理服务器所要求的认证信息发送给客户端。
它与客户端和服务器之间的 HTTP 访问认证的行为相似，不同之处在于其认证行为是在客户端与代理之间进行

### Retry-After

Retry-After: 120

告知客户端应该在多久之后再次发送请求。主要配合状态码 503 Service Unavailable 响应，或 3xx Redirect 响应一起使用

### Server

Server: Apache/2.2.17 (Unix)

告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。不单单会标出服务器上的软件应用名称，还有可能包括版本号和安装时启用的可选项

### Vary

Vary: Accept-Language

当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从缓存返回响应。反之，则需要先从源服务器端获取资源后才能作为响应返回

### WWW-Authenticate

WWW-Authenticate: Basic realm="Usagidesign Auth"

于 HTTP 访问认证。它会告知客户端适用于访问请求 URI 所指定资源的认证方案（Basic 或是 Digest）和带参数提示的质询（challenge）。状态码 401 Unauthorized 响应中，肯定带有首部字段 WWW-Authenticate

## 实体首部字段

包含在请求报文和响应报文中的实体部分所使用的首部，用于补充内容的更新时间等与实体相关的信息。

### Allow

Allow: GET, HEAD

通知客户端能够支持 Request-URI 指定资源的所有 HTTP 方法。当服务器接收到不支持的 HTTP 方法时，会以状态码 405 Method Not Allowed 作为响应返回。与此同时，还会把所有能支持的 HTTP 方法写入首部字段 Allow 后返回

### Content-Encoding

Content-Encoding: gzip

告知客户端服务器对实体的主体部分选用的内容编码方式。内容编码是指在不丢失实体信息的前提下所进行的压缩

### Content-Language

Content-Language: zh-CN

告知客户端，实体主体使用的自然语言（指中文或英文等语言）

### Content-Length

Content-Length: 15000

表明了实体主体部分的大小（单位是字节）。对实体主体进行内容编码传输时，不能再使用 Content-Length 首部字段

### Content-Location

Content-Location: http://www.hackr.jp/index-ja.html

给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回资源对应的 URI

### Content-MD5

Content-MD5: OGFkZDUwNGVhNGY3N2MxMDIwZmQ4NTBmY2IyTY==

客户端会对接收的报文主体执行相同的 MD5 算法，然后与首部字段 Content-MD5 的字段值比较

是一串由 MD5 算法生成的值，其目的在于检查报文主体在传输过程中是否保持完整，以及确认传输到达

### Content-Range

Content-Range: bytes 5001-10000/10000

针对范围请求，返回响应时使用的首部字段 Content-Range，能告知客户端作为响应返回的实体的哪个部分符合范围请求。字段值以字节为单位，表示当前发送部分及整个实体大小

### Content-Type

Content-Type: text/html; charset=UTF-8

说明了实体主体内对象的媒体类型。和首部字段 Accept 一样，字段值用 type/subtype 形式赋值

### Expires

Expires: Wed, 04 Jul 2012 08:26:05 GMT

将资源失效的日期告知客户端

### Last-Modified

Last-Modified: Wed, 23 May 2012 09:59:55 GMT

指明资源最终修改的时间

# 链接管理

## TCP链接

TCP 为 HTTP 提供了一条可靠的比特传输管道。从 TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来；

TCP 的数据是通过名为 IP 分组（或 IP 数据报）的小数据块来发送；

HTTP 要传送一条报文时，会以流的形式将报文数据的内容通过一条打开的 TCP 连接按序传输。TCP 收到数据流之后，会将数据流砍成被称作段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输

## TCP/IP的分层管理

### 应用层

决定向用户提供应用时服务通信的活动。（http、DNS、FTP）

### 传输层

**提供两台电脑之间的数据传输。（TCP）**

### 网络层（IP）

处理网络上流动的数据包。**规定了通过怎样的路径达到对方电脑，并把数据包传送给对方。**

### 链路层（网络接口层）

**处理连接网络的硬件部分。（网卡、路由、硬件的设备驱动）**

## 确保可靠的TCP协议

提供字节流服务，为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。这样才能确认数据最终是否送达到对方。

### TCP三次握手

1. 发送端首先发送一个带SYN（同步序列编号）标志的数据包给对方
2. 接受端收到后回传一个带有SYN/ACK标志的数据包以示传达确认信息
3. 发送端再回传一个带有ACK（确认字符）标志的数据包

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/10.png)

## 负责域名解析的DNS服务

提供域名到IP地址之间的解析服务;

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/11.png)

## HTTP连接处理

### 串行事务处理时延

如果只对连接进行简单的管理，TCP 的性能时延可能会叠加起来;比如，假设有一个包含了 3 个嵌入图片的 Web 页面。浏览器需要发起 4 个 HTTP 事务来显示此页面： 1 个用于顶层的 HTML 页面，3 个用于嵌入的图片。如果每个事务都需要（串行地建立）一条新的连接，那么连接时延和慢启动时延就会叠加起来

### 并行连接

HTTP **允许客户端打开多条连接，并行地执行多个 HTTP 事务**;

**并行连接通常也会让用户觉得页面加载得更快了，因为多个组件对象同时出现在屏幕上时，用户能够看到加载的进展.**
即使并行连接的速度可能会更快，但并不一定总是更快。客户端的网络带宽不足（比如，浏览器是通过一个 28.8kbps 的 Modem 连接到因特网上去的）时，大部分的时间可能都是用来传送数据;

一个连接到速度较快服务器上的 HTTP 事务就会很容易地耗尽所有可用的 Modem 带宽。如果并行加载多个对象，每个对象都会去竞争这有限的带宽，每个对象都会以较慢的速度按比例加载

### 持久连接

允许 HTTP 设备在事务处理结束之后将 TCP 连接保持在打开状态，以便为未来的 HTTP 请求重用现存的连接。在**事务处理结束之后仍然保持在打开状态的 TCP 连接被称为持久连接**

**持久连接降低了时延和连接建立的开销，将连接保持在已调谐状态**，而且减少了打开连接的潜在数量

### 管道化连接

**允许在持久连接上可选地使用请求管道;在响应到达之前，可以将多条请求放入队列**。当第一条请求通过网络流向地球另一端的服务器时，第二条和第三条请求也可以开始发送了。在高时延网络条件下，这样做可以降低网络的环回时间，提高性能

#### 管道持久化限制

- 如果 HTTP 客户端无法确认连接是持久的，就不应该使用管道
- 必须按照与请求相同的顺序回送 HTTP 响应。HTTP 报文中没有序列号标签，因此如果收到的响应失序了，就没办法将其与请求匹配起来了
- HTTP 客户端必须做好连接会在任意时刻关闭的准备，还要准备好重发所有未完成的管道化请求。如果客户端打开了一条持久连接，并立即发出了 10 条请求，服务器可能在只处理了，比方说，5 条请求之后关闭连接。剩下的 5 条请求会失败，客户端必须能够应对这些过早关闭连接的情况，重新发出这些请求
- HTTP 客户端不应该用管道化的方式发送会产生副作用的请求（比如 POST）

![image](https://github.com/NoahsDante/webNotes/blob/master/http/img/12.png)



